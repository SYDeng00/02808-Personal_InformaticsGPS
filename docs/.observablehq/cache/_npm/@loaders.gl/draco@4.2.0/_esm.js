/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@loaders.gl/draco@4.2.0/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{deduceMeshField as t,getMeshBoundingBox as e}from"../schema@4.2.0/_esm.js";import{loadLibrary as r}from"../worker-utils@4.2.0/_esm.js";const a="4.2.0-beta.2",o={dataType:null,batchType:null,name:"Draco",id:"draco",module:"draco",version:a,worker:!0,extensions:["drc"],mimeTypes:["application/octet-stream"],binary:!0,tests:["DRACO"],options:{draco:{decoderType:"object"==typeof WebAssembly?"wasm":"js",libraryPath:"libs/",extraAttributes:{},attributeNameEntry:void 0}}};function n(e,r,a){const o=a?i(a.metadata):void 0;return t(e,r,o)}function i(t){const e={};for(const r in t)e[`${r}.string`]=JSON.stringify(t[r]);return e}const s={POSITION:"POSITION",NORMAL:"NORMAL",COLOR:"COLOR_0",TEX_COORD:"TEXCOORD_0"},d={1:Int8Array,2:Uint8Array,3:Int16Array,4:Uint16Array,5:Int32Array,6:Uint32Array,9:Float32Array};class c{draco;decoder;metadataQuerier;constructor(t){this.draco=t,this.decoder=new this.draco.Decoder,this.metadataQuerier=new this.draco.MetadataQuerier}destroy(){this.draco.destroy(this.decoder),this.draco.destroy(this.metadataQuerier)}parseSync(t,r={}){const a=new this.draco.DecoderBuffer;a.Init(new Int8Array(t),t.byteLength),this._disableAttributeTransforms(r);const o=this.decoder.GetEncodedGeometryType(a),s=o===this.draco.TRIANGULAR_MESH?new this.draco.Mesh:new this.draco.PointCloud;try{let t;switch(o){case this.draco.TRIANGULAR_MESH:t=this.decoder.DecodeBufferToMesh(a,s);break;case this.draco.POINT_CLOUD:t=this.decoder.DecodeBufferToPointCloud(a,s);break;default:throw new Error("DRACO: Unknown geometry type.")}if(!t.ok()||!s.ptr){const e=`DRACO decompression failed: ${t.error_msg()}`;throw new Error(e)}const d=this._getDracoLoaderData(s,o,r),c=this._getMeshData(s,d,r),u=e(c.attributes),h=function(t,e,r){const a=i(e.metadata),o=[],s=function(t){const e={};for(const r in t){const a=t[r];e[a.name||"undefined"]=a}return e}(e.attributes);for(const e in t){const r=n(e,t[e],s[e]);o.push(r)}if(r){const t=n("indices",r);o.push(t)}return{fields:o,metadata:a}}(c.attributes,d,c.indices);return{loader:"draco",loaderData:d,header:{vertexCount:s.num_points(),boundingBox:u},...c,schema:h}}finally{this.draco.destroy(a),s&&this.draco.destroy(s)}}_getDracoLoaderData(t,e,r){const a=this._getTopLevelMetadata(t),o=this._getDracoAttributes(t,r);return{geometry_type:e,num_attributes:t.num_attributes(),num_points:t.num_points(),num_faces:t instanceof this.draco.Mesh?t.num_faces():0,metadata:a,attributes:o}}_getDracoAttributes(t,e){const r={};for(let a=0;a<t.num_attributes();a++){const o=this.decoder.GetAttribute(t,a),n=this._getAttributeMetadata(t,a);r[o.unique_id()]={unique_id:o.unique_id(),attribute_type:o.attribute_type(),data_type:o.data_type(),num_components:o.num_components(),byte_offset:o.byte_offset(),byte_stride:o.byte_stride(),normalized:o.normalized(),attribute_index:a,metadata:n};const i=this._getQuantizationTransform(o,e);i&&(r[o.unique_id()].quantization_transform=i);const s=this._getOctahedronTransform(o,e);s&&(r[o.unique_id()].octahedron_transform=s)}return r}_getMeshData(t,e,r){const a=this._getMeshAttributes(e,t,r);if(!a.POSITION)throw new Error("DRACO: No position attribute found.");return t instanceof this.draco.Mesh?"triangle-strip"===r.topology?{topology:"triangle-strip",mode:4,attributes:a,indices:{value:this._getTriangleStripIndices(t),size:1}}:{topology:"triangle-list",mode:5,attributes:a,indices:{value:this._getTriangleListIndices(t),size:1}}:{topology:"point-list",mode:0,attributes:a}}_getMeshAttributes(t,e,r){const a={};for(const o of Object.values(t.attributes)){const t=this._deduceAttributeName(o,r);o.name=t;const n=this._getAttributeValues(e,o);if(n){const{value:e,size:r}=n;a[t]={value:e,size:r,byteOffset:o.byte_offset,byteStride:o.byte_stride,normalized:o.normalized}}}return a}_getTriangleListIndices(t){const e=3*t.num_faces(),r=4*e,a=this.draco._malloc(r);try{return this.decoder.GetTrianglesUInt32Array(t,r,a),new Uint32Array(this.draco.HEAPF32.buffer,a,e).slice()}finally{this.draco._free(a)}}_getTriangleStripIndices(t){const e=new this.draco.DracoInt32Array;try{return this.decoder.GetTriangleStripsFromMesh(t,e),function(t){const e=t.size(),r=new Int32Array(e);for(let a=0;a<e;a++)r[a]=t.GetValue(a);return r}(e)}finally{this.draco.destroy(e)}}_getAttributeValues(t,e){const r=d[e.data_type];if(!r)return console.warn(`DRACO: Unsupported attribute type ${e.data_type}`),null;const a=e.num_components,o=t.num_points()*a,n=o*r.BYTES_PER_ELEMENT,i=function(t,e){switch(e){case Float32Array:return t.DT_FLOAT32;case Int8Array:return t.DT_INT8;case Int16Array:return t.DT_INT16;case Int32Array:return t.DT_INT32;case Uint8Array:return t.DT_UINT8;case Uint16Array:return t.DT_UINT16;case Uint32Array:return t.DT_UINT32;default:return t.DT_INVALID}}(this.draco,r);let s;const c=this.draco._malloc(n);try{const a=this.decoder.GetAttribute(t,e.attribute_index);this.decoder.GetAttributeDataArrayForAllPoints(t,a,i,n,c),s=new r(this.draco.HEAPF32.buffer,c,o).slice()}finally{this.draco._free(c)}return{value:s,size:a}}_deduceAttributeName(t,e){const r=t.unique_id;for(const[t,a]of Object.entries(e.extraAttributes||{}))if(a===r)return t;const a=t.attribute_type;for(const t in s){if(this.draco[t]===a)return s[t]}const o=e.attributeNameEntry||"name";return t.metadata[o]?t.metadata[o].string:`CUSTOM_ATTRIBUTE_${r}`}_getTopLevelMetadata(t){const e=this.decoder.GetMetadata(t);return this._getDracoMetadata(e)}_getAttributeMetadata(t,e){const r=this.decoder.GetAttributeMetadata(t,e);return this._getDracoMetadata(r)}_getDracoMetadata(t){if(!t||!t.ptr)return{};const e={},r=this.metadataQuerier.NumEntries(t);for(let a=0;a<r;a++){const r=this.metadataQuerier.GetEntryName(t,a);e[r]=this._getDracoMetadataField(t,r)}return e}_getDracoMetadataField(t,e){const r=new this.draco.DracoInt32Array;try{this.metadataQuerier.GetIntEntryArray(t,e,r);const a=function(t){const e=t.size(),r=new Int32Array(e);for(let a=0;a<e;a++)r[a]=t.GetValue(a);return r}(r);return{int:this.metadataQuerier.GetIntEntry(t,e),string:this.metadataQuerier.GetStringEntry(t,e),double:this.metadataQuerier.GetDoubleEntry(t,e),intArray:a}}finally{this.draco.destroy(r)}}_disableAttributeTransforms(t){const{quantizedAttributes:e=[],octahedronAttributes:r=[]}=t,a=[...e,...r];for(const t of a)this.decoder.SkipAttributeTransform(this.draco[t])}_getQuantizationTransform(t,e){const{quantizedAttributes:r=[]}=e,a=t.attribute_type();if(r.map((t=>this.decoder[t])).includes(a)){const e=new this.draco.AttributeQuantizationTransform;try{if(e.InitFromAttribute(t))return{quantization_bits:e.quantization_bits(),range:e.range(),min_values:new Float32Array([1,2,3]).map((t=>e.min_value(t)))}}finally{this.draco.destroy(e)}}return null}_getOctahedronTransform(t,e){const{octahedronAttributes:r=[]}=e,a=t.attribute_type();if(r.map((t=>this.decoder[t])).includes(a)){const e=new this.draco.AttributeQuantizationTransform;try{if(e.InitFromAttribute(t))return{quantization_bits:e.quantization_bits()}}finally{this.draco.destroy(e)}}return null}}const u="https://www.gstatic.com/draco/versioned/decoders/1.5.6",h={DECODER:"draco_wasm_wrapper.js",DECODER_WASM:"draco_decoder.wasm",FALLBACK_DECODER:"draco_decoder.js",ENCODER:"draco_encoder.js"},l={[h.DECODER]:`${u}/${h.DECODER}`,[h.DECODER_WASM]:`${u}/${h.DECODER_WASM}`,[h.FALLBACK_DECODER]:`${u}/${h.FALLBACK_DECODER}`,[h.ENCODER]:`https://raw.githubusercontent.com/google/draco/1.4.1/javascript/${h.ENCODER}`};let y,_;async function A(t){const e=t.modules||{};return e.draco3d?y||=e.draco3d.createDecoderModule({}).then((t=>({draco:t}))):y||=async function(t){let e,a;if("js"===(t.draco&&t.draco.decoderType))e=await r(l[h.FALLBACK_DECODER],"draco",t,h.FALLBACK_DECODER);else[e,a]=await Promise.all([await r(l[h.DECODER],"draco",t,h.DECODER),await r(l[h.DECODER_WASM],"draco",t,h.DECODER_WASM)]);return e=e||globalThis.DracoDecoderModule,await function(t,e){const r={};e&&(r.wasmBinary=e);return new Promise((e=>{t({...r,onModuleLoaded:t=>e({draco:t})})}))}(e,a)}(t),await y}async function b(t){const e=t.modules||{};return e.draco3d?_||=e.draco3d.createEncoderModule({}).then((t=>({draco:t}))):_||=async function(t){let e=await r(l[h.ENCODER],"draco",t,h.ENCODER);return e=e||globalThis.DracoEncoderModule,new Promise((t=>{e({onModuleLoaded:e=>t({draco:e})})}))}(t),await _}const f={POSITION:"POSITION",NORMAL:"NORMAL",COLOR_0:"COLOR",TEXCOORD_0:"TEX_COORD"},m=()=>{};class E{draco;dracoEncoder;dracoMeshBuilder;dracoMetadataBuilder;log;constructor(t){this.draco=t,this.dracoEncoder=new this.draco.Encoder,this.dracoMeshBuilder=new this.draco.MeshBuilder,this.dracoMetadataBuilder=new this.draco.MetadataBuilder}destroy(){this.destroyEncodedObject(this.dracoMeshBuilder),this.destroyEncodedObject(this.dracoEncoder),this.destroyEncodedObject(this.dracoMetadataBuilder),this.dracoMeshBuilder=null,this.dracoEncoder=null,this.draco=null}destroyEncodedObject(t){t&&this.draco.destroy(t)}encodeSync(t,e={}){return this.log=m,this._setOptions(e),e.pointcloud?this._encodePointCloud(t,e):this._encodeMesh(t,e)}_getAttributesFromMesh(t){const e={...t,...t.attributes};return t.indices&&(e.indices=t.indices),e}_encodePointCloud(t,e){const r=new this.draco.PointCloud;e.metadata&&this._addGeometryMetadata(r,e.metadata);const a=this._getAttributesFromMesh(t);this._createDracoPointCloud(r,a,e);const o=new this.draco.DracoInt8Array;try{const t=this.dracoEncoder.EncodePointCloudToDracoBuffer(r,!1,o);if(!(t>0))throw new Error("Draco encoding failed.");return this.log(`DRACO encoded ${r.num_points()} points\n        with ${r.num_attributes()} attributes into ${t} bytes`),D(o)}finally{this.destroyEncodedObject(o),this.destroyEncodedObject(r)}}_encodeMesh(t,e){const r=new this.draco.Mesh;e.metadata&&this._addGeometryMetadata(r,e.metadata);const a=this._getAttributesFromMesh(t);this._createDracoMesh(r,a,e);const o=new this.draco.DracoInt8Array;try{const t=this.dracoEncoder.EncodeMeshToDracoBuffer(r,o);if(t<=0)throw new Error("Draco encoding failed.");return this.log(`DRACO encoded ${r.num_points()} points\n        with ${r.num_attributes()} attributes into ${t} bytes`),D(o)}finally{this.destroyEncodedObject(o),this.destroyEncodedObject(r)}}_setOptions(t){if("speed"in t&&this.dracoEncoder.SetSpeedOptions(...t.speed),"method"in t){const e=this.draco[t.method||"MESH_SEQUENTIAL_ENCODING"];this.dracoEncoder.SetEncodingMethod(e)}if("quantization"in t)for(const e in t.quantization){const r=t.quantization[e],a=this.draco[e];this.dracoEncoder.SetAttributeQuantization(a,r)}}_createDracoMesh(t,e,r){const a=r.attributesMetadata||{};try{const r=this._getPositionAttribute(e);if(!r)throw new Error("positions");const o=r.length/3;for(let r in e){const n=e[r];r=f[r]||r;const i=this._addAttributeToMesh(t,r,n,o);-1!==i&&this._addAttributeMetadata(t,i,{name:r,...a[r]||{}})}}catch(e){throw this.destroyEncodedObject(t),e}return t}_createDracoPointCloud(t,e,r){const a=r.attributesMetadata||{};try{const r=this._getPositionAttribute(e);if(!r)throw new Error("positions");const o=r.length/3;for(let r in e){const n=e[r];r=f[r]||r;const i=this._addAttributeToMesh(t,r,n,o);-1!==i&&this._addAttributeMetadata(t,i,{name:r,...a[r]||{}})}}catch(e){throw this.destroyEncodedObject(t),e}return t}_addAttributeToMesh(t,e,r,a){if(!ArrayBuffer.isView(r))return-1;const o=this._getDracoAttributeType(e),n=r.length/a;if("indices"===o){const a=r.length/3;return this.log(`Adding attribute ${e}, size ${a}`),this.dracoMeshBuilder.AddFacesToMesh(t,a,r),-1}this.log(`Adding attribute ${e}, size ${n}`);const i=this.dracoMeshBuilder,{buffer:s}=r;switch(r.constructor){case Int8Array:return i.AddInt8Attribute(t,o,a,n,new Int8Array(s));case Int16Array:return i.AddInt16Attribute(t,o,a,n,new Int16Array(s));case Int32Array:return i.AddInt32Attribute(t,o,a,n,new Int32Array(s));case Uint8Array:case Uint8ClampedArray:return i.AddUInt8Attribute(t,o,a,n,new Uint8Array(s));case Uint16Array:return i.AddUInt16Attribute(t,o,a,n,new Uint16Array(s));case Uint32Array:return i.AddUInt32Attribute(t,o,a,n,new Uint32Array(s));case Float32Array:return i.AddFloatAttribute(t,o,a,n,new Float32Array(s));default:return console.warn("Unsupported attribute type",r),-1}}_getDracoAttributeType(t){switch(t.toLowerCase()){case"indices":return"indices";case"position":case"positions":case"vertices":return this.draco.POSITION;case"normal":case"normals":return this.draco.NORMAL;case"color":case"colors":return this.draco.COLOR;case"texcoord":case"texcoords":return this.draco.TEX_COORD;default:return this.draco.GENERIC}}_getPositionAttribute(t){for(const e in t){const r=t[e];if(this._getDracoAttributeType(e)===this.draco.POSITION)return r}return null}_addGeometryMetadata(t,e){const r=new this.draco.Metadata;this._populateDracoMetadata(r,e),this.dracoMeshBuilder.AddMetadata(t,r)}_addAttributeMetadata(t,e,r){const a=new this.draco.Metadata;this._populateDracoMetadata(a,r),this.dracoMeshBuilder.SetMetadataForAttribute(t,e,a)}_populateDracoMetadata(t,e){for(const[a,o]of(r=e).entries&&!r.hasOwnProperty("entries")?r.entries():Object.entries(r))switch(typeof o){case"number":Math.trunc(o)===o?this.dracoMetadataBuilder.AddIntEntry(t,a,o):this.dracoMetadataBuilder.AddDoubleEntry(t,a,o);break;case"object":o instanceof Int32Array&&this.dracoMetadataBuilder.AddIntEntryArray(t,a,o,o.length);break;default:this.dracoMetadataBuilder.AddStringEntry(t,a,o)}var r}}function D(t){const e=t.size(),r=new ArrayBuffer(e),a=new Int8Array(r);for(let r=0;r<e;++r)a[r]=t.GetValue(r);return r}const p={name:"DRACO",id:"draco",module:"draco",version:a,extensions:["drc"],options:{draco:{pointcloud:!1,attributeNameEntry:"name"}},encode:async function(t,e={}){const{draco:r}=await b(e),a=new E(r);try{return a.encodeSync(t,e.draco)}finally{a.destroy()}}};const O={id:"draco-writer",name:"Draco compressed geometry writer",module:"draco",version:a,worker:!0,options:{draco:{},source:null}},w={...o,parse:async function(t,e){const{draco:r}=await A(e),a=new c(r);try{return a.parseSync(t,e?.draco)}finally{a.destroy()}}};export{h as DRACO_EXTERNAL_LIBRARIES,l as DRACO_EXTERNAL_LIBRARY_URLS,w as DracoLoader,o as DracoWorkerLoader,p as DracoWriter,O as DracoWriterWorker};export default null;
