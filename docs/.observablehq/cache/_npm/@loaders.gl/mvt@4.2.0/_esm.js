/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@loaders.gl/mvt@4.2.0/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{flatGeojsonToBinary as t}from"../gis@4.2.0/_esm.js";import e from"../../pbf@3.2.1/_esm.js";import{getPolygonSignedArea as n}from"../../@math.gl/polygon@4.0.1/_esm.js";import{DataSource as o,resolvePath as i}from"../loader-utils@4.2.0/_esm.js";import{getBinaryImageMetadata as s,ImageLoader as r}from"../images@4.2.0/_esm.js";import{TileJSONLoader as a,MVTLoader as l}from"./_esm.js";function u(t){let e=0;for(let n,o,i=0,s=t.length-1;i<t.length;s=i++)n=t[i],o=t[s],e+=(o[0]-n[0])*(n[1]+o[1]);return e}function c(t,e,n){e&&n&&(1===t?e.id=n.readVarint():2===t?function(t,e){const n=t.readVarint()+t.pos;for(;t.pos<n;){const n=e._keys[t.readVarint()],o=e._values[t.readVarint()];e.properties[n]=o}}(n,e):3===t?e.type=n.readVarint():4===t&&(e._geometry=n.pos))}class h{properties;extent;type;id;_pbf;_geometry;_keys;_values;static get types(){return["Unknown","Point","LineString","Polygon"]}constructor(t,e,n,o,i){this.properties={},this.extent=n,this.type=0,this.id=null,this._pbf=t,this._geometry=-1,this._keys=o,this._values=i,t.readFields(c,this,e)}loadGeometry(){const t=this._pbf;t.pos=this._geometry;const e=t.readVarint()+t.pos;let n=1,o=0,i=0,s=0;const r=[];let a;for(;t.pos<e;){if(o<=0){const e=t.readVarint();n=7&e,o=e>>3}if(o--,1===n||2===n)i+=t.readSVarint(),s+=t.readSVarint(),1===n&&(a&&r.push(a),a=[]),a&&a.push([i,s]);else{if(7!==n)throw new Error(`unknown command ${n}`);a&&a.push(a[0].slice())}}return a&&r.push(a),r}bbox(){const t=this._pbf;t.pos=this._geometry;const e=t.readVarint()+t.pos;let n=1,o=0,i=0,s=0,r=1/0,a=-1/0,l=1/0,u=-1/0;for(;t.pos<e;){if(o<=0){const e=t.readVarint();n=7&e,o=e>>3}if(o--,1===n||2===n)i+=t.readSVarint(),s+=t.readSVarint(),i<r&&(r=i),i>a&&(a=i),s<l&&(l=s),s>u&&(u=s);else if(7!==n)throw new Error(`unknown command ${n}`)}return[r,l,a,u]}_toGeoJSON(t){let e,n,o=this.loadGeometry(),i=h.types[this.type];switch(this.type){case 1:const i=[];for(e=0;e<o.length;e++)i[e]=o[e][0];o=i,t(o,this);break;case 2:for(e=0;e<o.length;e++)t(o[e],this);break;case 3:for(o=function(t){const e=t.length;if(e<=1)return[t];const n=[];let o,i;for(let s=0;s<e;s++){const e=u(t[s]);0!==e&&(void 0===i&&(i=e<0),i===e<0?(o&&n.push(o),o=[t[s]]):o&&o.push(t[s]))}return o&&n.push(o),n}(o),e=0;e<o.length;e++)for(n=0;n<o[e].length;n++)t(o[e][n],this)}1===o.length?o=o[0]:i=`Multi${i}`;const s={type:"Feature",geometry:{type:i,coordinates:o},properties:this.properties};return null!==this.id&&(s.id=this.id),s}toGeoJSON(t){if("function"==typeof t)return this._toGeoJSON(t);const{x:e,y:n,z:o}=t,i=this.extent*Math.pow(2,o),s=this.extent*e,r=this.extent*n;return this._toGeoJSON((function(t){for(let e=0;e<t.length;e++){const n=t[e];n[0]=360*(n[0]+s)/i-180;const o=180-360*(n[1]+r)/i;n[1]=360/Math.PI*Math.atan(Math.exp(o*Math.PI/180))-90}}))}}class p{version;name;extent;length;_pbf;_keys;_values;_features;constructor(t,e){this.version=1,this.name="",this.extent=4096,this.length=0,this._pbf=t,this._keys=[],this._values=[],this._features=[],t.readFields(f,this,e),this.length=this._features.length}feature(t){if(t<0||t>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[t];const e=this._pbf.readVarint()+this._pbf.pos;return new h(this._pbf,e,this.extent,this._keys,this._values)}}function f(t,e,n){e&&n&&(15===t?e.version=n.readVarint():1===t?e.name=n.readString():5===t?e.extent=n.readVarint():2===t?e._features.push(n.pos):3===t?e._keys.push(n.readString()):4===t&&e._values.push(function(t){let e=null;const n=t.readVarint()+t.pos;for(;t.pos<n;){const n=t.readVarint()>>3;e=1===n?t.readString():2===n?t.readFloat():3===n?t.readDouble():4===n?t.readVarint64():5===n?t.readVarint():6===n?t.readSVarint():7===n?t.readBoolean():null}return e}(n)))}class m{layers;constructor(t,e){this.layers=t.readFields(d,{},e)}}function d(t,e,n){if(3===t&&n){const t=new p(n,n.readVarint()+n.pos);t.length&&e&&(e[t.name]=t)}}function g(t,e,n){e&&n&&(1===t?e.id=n.readVarint():2===t?function(t,e){const n=t.readVarint()+t.pos;for(;t.pos<n;){const n=e._keys[t.readVarint()],o=e._values[t.readVarint()];e.properties[n]=o}}(n,e):3===t?e.type=n.readVarint():4===t&&(e._geometry=n.pos))}let y,x,_,b,w,M,v;class P{properties;extent;type;id;_pbf;_geometry;_keys;_values;_geometryInfo;constructor(t,e,n,o,i,s){this.properties={},this.extent=n,this.type=0,this.id=null,this._pbf=t,this._geometry=-1,this._keys=o,this._values=i,this._geometryInfo=s,t.readFields(g,this,e)}loadGeometry(){const t=this._pbf;t.pos=this._geometry,y=t.readVarint()+t.pos,x=1,b=0,w=0,M=0,v=0;const e=[],n=[];for(;t.pos<y;)if(b<=0&&(_=t.readVarint(),x=7&_,b=_>>3),b--,1===x||2===x)w+=t.readSVarint(),M+=t.readSVarint(),1===x&&e.push(v),n.push(w,M),v+=2;else{if(7!==x)throw new Error(`unknown command ${x}`);if(v>0){const t=e[e.length-1];n.push(n[t],n[t+1]),v+=2}}return{data:n,indices:e}}_toBinaryCoordinates(t){const e=this.loadGeometry();let o;t(e.data,this);switch(this.type){case 1:this._geometryInfo.pointFeaturesCount++,this._geometryInfo.pointPositionsCount+=e.indices.length,o={type:"Point",...e};break;case 2:this._geometryInfo.lineFeaturesCount++,this._geometryInfo.linePathsCount+=e.indices.length,this._geometryInfo.linePositionsCount+=e.data.length/2,o={type:"LineString",...e};break;case 3:o=function(t){const e=t.indices.length,o="Polygon";if(e<=1)return{type:o,data:t.data,areas:[[n(t.data)]],indices:[t.indices]};const i=[],s=[];let r,a=[],l=[],u=0;for(let o,c,h=0;h<e;h++){c=t.indices[h]-u,o=t.indices[h+1]-u||t.data.length;const e=t.data.slice(c,o),p=n(e);if(0!==p)void 0===r&&(r=p<0),r===p<0?(l.length&&(i.push(a),s.push(l)),l=[c],a=[p]):(a.push(p),l.push(c));else{const e=t.data.slice(0,c),n=t.data.slice(o);t.data=e.concat(n),u+=o-c}}return a&&i.push(a),l.length&&s.push(l),{type:o,areas:i,indices:s,data:t.data}}(e),this._geometryInfo.polygonFeaturesCount++,this._geometryInfo.polygonObjectsCount+=o.indices.length;for(const t of o.indices)this._geometryInfo.polygonRingsCount+=t.length;this._geometryInfo.polygonPositionsCount+=o.data.length/2;break;default:throw new Error(`Invalid geometry type: ${this.type}`)}const i={type:"Feature",geometry:o,properties:this.properties};return null!==this.id&&(i.id=this.id),i}toBinaryCoordinates(t){if("function"==typeof t)return this._toBinaryCoordinates(t);const{x:e,y:n,z:o}=t,i=this.extent*Math.pow(2,o),s=this.extent*e,r=this.extent*n;return this._toBinaryCoordinates((t=>function(t,e,n,o){for(let i=0,s=t.length;i<s;i+=2){t[i]=360*(t[i]+e)/o-180;const s=180-360*(t[i+1]+n)/o;t[i+1]=360/Math.PI*Math.atan(Math.exp(s*Math.PI/180))-90}}(t,s,r,i)))}}class S{version;name;extent;length;_pbf;_keys;_values;_features;constructor(t,e){this.version=1,this.name="",this.extent=4096,this.length=0,this._pbf=t,this._keys=[],this._values=[],this._features=[],t.readFields(V,this,e),this.length=this._features.length}feature(t,e){if(t<0||t>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[t];const n=this._pbf.readVarint()+this._pbf.pos;return new P(this._pbf,n,this.extent,this._keys,this._values,e)}}function V(t,e,n){e&&n&&(15===t?e.version=n.readVarint():1===t?e.name=n.readString():5===t?e.extent=n.readVarint():2===t?e._features.push(n.pos):3===t?e._keys.push(n.readString()):4===t&&e._values.push(function(t){let e=null;const n=t.readVarint()+t.pos;for(;t.pos<n;){const n=t.readVarint()>>3;e=1===n?t.readString():2===n?t.readFloat():3===n?t.readDouble():4===n?t.readVarint64():5===n?t.readVarint():6===n?t.readSVarint():7===n?t.readBoolean():null}return e}(n)))}class T{layers;constructor(t,e){this.layers=t.readFields(I,{},e)}}function I(t,e,n){if(3===t&&n){const t=new S(n,n.readVarint()+n.pos);t.length&&e&&(e[t.name]=t)}}function L(t,e){const n=function(t){if(!t?.mvt)throw new Error("mvt options required");const e="wgs84"===t.mvt?.coordinates,{tileIndex:n}=t.mvt,o=n&&Number.isFinite(n.x)&&Number.isFinite(n.y)&&Number.isFinite(n.z);if(e&&!o)throw new Error("MVT Loader: WGS84 coordinates need tileIndex property");return t.mvt}(e),o=e?.gis?.format||e?.mvt?.shape||e?.shape;switch(o){case"columnar-table":return{shape:"columnar-table",data:z(t,n)};case"geojson-table":return{shape:"geojson-table",type:"FeatureCollection",features:C(t,n)};case"geojson":return C(t,n);case"binary-geometry":case"binary":return z(t,n);default:throw new Error(o||"undefined shape")}}function z(n,o){const[i,s]=function(t,n){const o=[],i={coordLength:2,pointPositionsCount:0,pointFeaturesCount:0,linePositionsCount:0,linePathsCount:0,lineFeaturesCount:0,polygonPositionsCount:0,polygonObjectsCount:0,polygonRingsCount:0,polygonFeaturesCount:0};if(t.byteLength<=0)return[o,i];const s=new T(new e(t)),r=n&&Array.isArray(n.layers)?n.layers:Object.keys(s.layers);return r.forEach((t=>{const e=s.layers[t];if(e)for(let s=0;s<e.length;s++){const r=k(e.feature(s,i),n,t);o.push(r)}})),[o,i]}(n,o),r=t(i,s);return r.byteLength=n.byteLength,r}function C(t,n){if(t.byteLength<=0)return[];const o=[],i=new m(new e(t));return(Array.isArray(n.layers)?n.layers:Object.keys(i.layers)).forEach((t=>{const e=i.layers[t];if(e)for(let i=0;i<e.length;i++){const s=F(e.feature(i),n,t);o.push(s)}})),o}function F(t,e,n){const o=t.toGeoJSON("wgs84"===e.coordinates?e.tileIndex:j);return e.layerProperty&&(o.properties[e.layerProperty]=n),o}function k(t,e,n){const o=t.toBinaryCoordinates("wgs84"===e.coordinates?e.tileIndex:E);return e.layerProperty&&o.properties&&(o.properties[e.layerProperty]=n),o}function j(t,e){const{extent:n}=e;for(let e=0;e<t.length;e++){const o=t[e];o[0]/=n,o[1]/=n}}function E(t,e){const{extent:n}=e;for(let e=0,o=t.length;e<o;++e)t[e]/=n}const Y={dataType:null,batchType:null,name:"Mapbox Vector Tile",id:"mvt",module:"mvt",version:"4.2.0-beta.2",extensions:["mvt","pbf"],mimeTypes:["application/vnd.mapbox-vector-tile","application/x-protobuf"],worker:!0,category:"geometry",options:{mvt:{shape:"geojson",coordinates:"local",layerProperty:"layerName",layers:void 0,tileIndex:null}}},N={...Y,parse:async(t,e)=>L(t,e),parseSync:L,binary:!0},O=t=>null!==t&&"object"==typeof t;function X(t,e){if(!t||!O(t))return null;let n={name:t.name||"",description:t.description||""};if("string"==typeof t.generator&&(n.generator=t.generator),"string"==typeof t.generator_options&&(n.generatorOptions=t.generator_options),n.boundingBox=Z(t.bounds)||Z(t.antimeridian_adjusted_bounds),n.center=function(t){const e=G(t);if(Array.isArray(e)&&3===e.length&&J(e[0])&&$(e[1])&&(n=e[2],Number.isFinite(n)&&n>=0&&n<=22))return e;var n;return null}(t.center),n.maxZoom=A(t.maxzoom),n.minZoom=A(t.minzoom),"string"==typeof t?.json)try{n.metaJson=JSON.parse(t.json)}catch(t){console.warn("Failed to parse tilejson.json field",t)}const o=function(t,e){if(O(t)&&Array.isArray(t.layers))return t.layers.map((t=>function(t,e){const n=[],o={},i=t.attributes||[];for(const t of i){const i=t.attribute;if("string"==typeof i)if(i.split("|").length>1){const e=i.split("|")[0];o[e]=o[e]||[],o[e].push(t),console.warn("ignoring tilestats indexed field",e)}else n[i]||n.push(B(t,e))}return{name:t.layer||"",dominantGeometry:t.geometry,fields:n}}(t,e)));return[]}(t.tilestats||n.metaJson?.tilestats,e),i=function(t){if(!Array.isArray(t))return[];return t.map((t=>function(t){const e=Object.entries(t.fields||[]).map((([t,e])=>({name:t,...R(String(e))}))),n={...t};return delete n.fields,{name:t.id||"",...n,fields:e}}(t)))}(t.vector_layers),s=function(t,e){return t.map((t=>{const n=e.find((e=>e.name===t.name)),o=n?.fields||[],i={...t};return delete i.fields,{...i,...n,fields:o}}))}(i,o);return n={...n,layers:s},null===n.maxZoom&&s.length>0&&(n.maxZoom=s[0].maxZoom||null),null===n.minZoom&&s.length>0&&(n.minZoom=s[0].minZoom||null),n}function Z(t){const e=G(t);if(Array.isArray(e)&&4===e.length&&[e[0],e[2]].every(J)&&[e[1],e[3]].every($))return[[e[0],e[1]],[e[2],e[3]]]}function A(t){const e="string"==typeof t?parseFloat(t):"number"==typeof t?t:null;return null===e||isNaN(e)?null:e}function $(t){return Number.isFinite(t)&&t<=90&&t>=-90}function J(t){return Number.isFinite(t)&&t<=180&&t>=-180}function G(t){return"string"==typeof t?t.split(",").map(parseFloat):Array.isArray(t)?t:null}const U={number:{type:"float32"},numeric:{type:"float32"},string:{type:"utf8"},vachar:{type:"utf8"},float:{type:"float32"},int:{type:"int32"},int4:{type:"int32"},boolean:{type:"boolean"},bool:{type:"boolean"}};function B(t={},e){const n=R(t.type),o={name:t.attribute,...n};return"number"==typeof t.min&&(o.min=t.min),"number"==typeof t.max&&(o.max=t.max),"number"==typeof t.count&&(o.uniqueValueCount=t.count),t.values&&(o.values=t.values),o.values&&"number"==typeof e.maxValues&&(o.values=o.values?.slice(0,e.maxValues)),o}function R(t){const e=t.toLowerCase();return U[e]||{type:"string"}}const D={dataType:null,batchType:null,name:"TileJSON",id:"tilejson",module:"pmtiles",version:"4.2.0-beta.2",worker:!0,extensions:["json"],mimeTypes:["application/json"],text:!0,options:{tilejson:{maxValues:void 0}},parse:async(t,e)=>{const n=(new TextDecoder).decode(t);return X(JSON.parse(n),{...D.options.tilejson,...e?.tilejson})},parseTextSync:(t,e)=>X(JSON.parse(t),{...D.options.tilejson,...e?.tilejson})};class q extends o{props;url;metadataUrl=null;data;schema="tms";metadata;extension;mimeType=null;constructor(t){var e;super(t),this.props=t,this.url=i(t.url),this.metadataUrl=void 0===t.metadataUrl?`${this.url}/tilejson.json`:t.metadataUrl,this.extension=t.extension||".png",this.data=this.url,this.getTileData=this.getTileData.bind(this),this.metadata=this.getMetadata(),e=this.url,/(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))|(?=.*{x})(?=.*({y}|{-y})(?=.*{z}))/.test(e)&&(this.schema="template")}async getMetadata(){if(!this.metadataUrl)return null;let t;try{t=await this.fetch(this.metadataUrl)}catch(t){return console.error(t.message),null}if(!t.ok)return console.error(t.statusText),null;const e=await t.text();return a.parseTextSync?.(e)||null}getTileMIMEType(){return this.mimeType}async getTile(t){const{x:e,y:n,zoom:o}=t,i=this.getTileURL(e,n,o),s=await this.fetch(i);if(!s.ok)return null;return await s.arrayBuffer()}async getTileData(t){const{x:e,y:n,z:o}=t.index,i=await this.getTile({x:e,y:n,zoom:o,layers:[]});if(null===i)return null;const r=s(i);return this.mimeType=this.mimeType||r?.mimeType||"application/vnd.mapbox-vector-tile","application/vnd.mapbox-vector-tile"===this.mimeType?await this._parseVectorTile(i,{x:e,y:n,zoom:o,layers:[]}):await this._parseImageTile(i)}async getImageTile(t){const e=await this.getTile(t);return e?this._parseImageTile(e):null}async _parseImageTile(t){return await r.parse(t,this.loadOptions)}async getVectorTile(t){const e=await this.getTile(t);return e?this._parseVectorTile(e,t):null}async _parseVectorTile(t,e){const n={shape:"geojson-table",mvt:{coordinates:"wgs84",tileIndex:{x:e.x,y:e.y,z:e.zoom},...this.loadOptions?.mvt},...this.loadOptions};return await l.parse(t,n)}getMetadataUrl(){return this.metadataUrl}getTileURL(t,e,n){switch(this.schema){case"xyz":return`${this.url}/${t}/${e}/${n}${this.extension}`;case"tms":return`${this.url}/${n}/${t}/${e}${this.extension}`;case"template":return function(t,e,n,o,i="0"){if(Array.isArray(t)){t=t[(s=i,Math.abs(s.split("").reduce(((t,e)=>(t<<5)-t+e.charCodeAt(0)|0),0))%t.length)]}var s;let r=t;r=r.replace(W,String(e)),r=r.replace(H,String(n)),r=r.replace(K,String(o)),Number.isInteger(n)&&Number.isInteger(o)&&(r=r.replace(/\{-y\}/g,String(Math.pow(2,o)-n-1)));return r}(this.url,t,e,n,"0");default:throw new Error(this.schema)}}}const W=new RegExp("{x}","g"),H=new RegExp("{y}","g"),K=new RegExp("{z}","g");function Q(t,e,n,o){let i=o;const s=n-e>>1;let r,a=n-e;const l=t[e],u=t[e+1],c=t[n],h=t[n+1];for(let o=e+3;o<n;o+=3){const e=tt(t[o],t[o+1],l,u,c,h);if(e>i)r=o,i=e;else if(e===i){const t=Math.abs(o-s);t<a&&(r=o,a=t)}}i>o&&(r-e>3&&Q(t,e,r,o),t[r+2]=i,n-r>3&&Q(t,r,n,o))}function tt(t,e,n,o,i,s){let r=i-n,a=s-o;if(0!==r||0!==a){const l=((t-n)*r+(e-o)*a)/(r*r+a*a);l>1?(n=i,o=s):l>0&&(n+=r*l,o+=a*l)}return r=t-n,a=e-o,r*r+a*a}function et(t,e,n,o){const i={id:null==t?null:t,type:e,geometry:n,tags:o,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};if("Point"===e||"MultiPoint"===e||"LineString"===e)nt(i,n);else if("Polygon"===e)nt(i,n[0]);else if("MultiLineString"===e)for(const t of n)nt(i,t);else if("MultiPolygon"===e)for(const t of n)nt(i,t[0]);return i}function nt(t,e){for(let n=0;n<e.length;n+=3)t.minX=Math.min(t.minX,e[n]),t.minY=Math.min(t.minY,e[n+1]),t.maxX=Math.max(t.maxX,e[n]),t.maxY=Math.max(t.maxY,e[n+1])}function ot(t,e,n,o){if(!e.geometry)return;const i=e.geometry.coordinates,s=e.geometry.type,r=Math.pow(n.tolerance/((1<<n.maxZoom)*n.extent),2);let a=[],l=e.id;if(n.promoteId?l=e.properties[n.promoteId]:n.generateId&&(l=o||0),"Point"===s)it(i,a);else if("MultiPoint"===s)for(const t of i)it(t,a);else if("LineString"===s)st(i,a,r,!1);else if("MultiLineString"===s){if(n.lineMetrics){for(const n of i)a=[],st(n,a,r,!1),t.push(et(l,"LineString",a,e.properties));return}rt(i,a,r,!1)}else if("Polygon"===s)rt(i,a,r,!0);else{if("MultiPolygon"!==s){if("GeometryCollection"===s){for(const i of e.geometry.geometries)ot(t,{id:l,geometry:i,properties:e.properties},n,o);return}throw new Error("Input data is not a valid GeoJSON object.")}for(const t of i){const e=[];rt(t,e,r,!0),a.push(e)}}t.push(et(l,s,a,e.properties))}function it(t,e){e.push(at(t[0]),lt(t[1]),0)}function st(t,e,n,o){let i,s,r=0;for(let n=0;n<t.length;n++){const a=at(t[n][0]),l=lt(t[n][1]);e.push(a,l,0),n>0&&(r+=o?(i*l-a*s)/2:Math.sqrt(Math.pow(a-i,2)+Math.pow(l-s,2))),i=a,s=l}const a=e.length-3;e[2]=1,Q(e,0,a,n),e[a+2]=1,e.size=Math.abs(r),e.start=0,e.end=e.size}function rt(t,e,n,o){for(let i=0;i<t.length;i++){const s=[];st(t[i],s,n,o),e.push(s)}}function at(t){return t/360+.5}function lt(t){const e=Math.sin(t*Math.PI/180),n=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return n<0?0:n>1?1:n}function ut(t,e,n,o,i,s,r,a){if(o/=e,s>=(n/=e)&&r<o)return t;if(r<n||s>=o)return null;const l=[];for(const e of t){const t=e.geometry;let s=e.type;const r=0===i?e.minX:e.minY,u=0===i?e.maxX:e.maxY;if(r>=n&&u<o){l.push(e);continue}if(u<n||r>=o)continue;let c=[];if("Point"===s||"MultiPoint"===s)ct(t,c,n,o,i);else if("LineString"===s)ht(t,c,n,o,i,!1,a.lineMetrics);else if("MultiLineString"===s)ft(t,c,n,o,i,!1);else if("Polygon"===s)ft(t,c,n,o,i,!0);else if("MultiPolygon"===s)for(const e of t){const t=[];ft(e,t,n,o,i,!0),t.length&&c.push(t)}if(c.length){if(a.lineMetrics&&"LineString"===s){for(const t of c)l.push(et(e.id,s,t,e.tags));continue}"LineString"!==s&&"MultiLineString"!==s||(1===c.length?(s="LineString",c=c[0]):s="MultiLineString"),"Point"!==s&&"MultiPoint"!==s||(s=3===c.length?"Point":"MultiPoint"),l.push(et(e.id,s,c,e.tags))}}return l.length?l:null}function ct(t,e,n,o,i){for(let s=0;s<t.length;s+=3){const r=t[s+i];r>=n&&r<=o&&mt(e,t[s],t[s+1],t[s+2])}}function ht(t,e,n,o,i,s,r){let a=pt(t);const l=0===i?dt:gt;let u,c,h=t.start;for(let p=0;p<t.length-3;p+=3){const f=t[p],m=t[p+1],d=t[p+2],g=t[p+3],y=t[p+4],x=0===i?f:m,_=0===i?g:y;let b=!1;r&&(u=Math.sqrt(Math.pow(f-g,2)+Math.pow(m-y,2))),x<n?_>n&&(c=l(a,f,m,g,y,n),r&&(a.start=h+u*c)):x>o?_<o&&(c=l(a,f,m,g,y,o),r&&(a.start=h+u*c)):mt(a,f,m,d),_<n&&x>=n&&(c=l(a,f,m,g,y,n),b=!0),_>o&&x<=o&&(c=l(a,f,m,g,y,o),b=!0),!s&&b&&(r&&(a.end=h+u*c),e.push(a),a=pt(t)),r&&(h+=u)}let p=t.length-3;const f=t[p],m=t[p+1],d=t[p+2],g=0===i?f:m;g>=n&&g<=o&&mt(a,f,m,d),p=a.length-3,s&&p>=3&&(a[p]!==a[0]||a[p+1]!==a[1])&&mt(a,a[0],a[1],a[2]),a.length&&e.push(a)}function pt(t){const e=[];return e.size=t.size,e.start=t.start,e.end=t.end,e}function ft(t,e,n,o,i,s){for(const r of t)ht(r,e,n,o,i,s,!1)}function mt(t,e,n,o){t.push(e,n,o)}function dt(t,e,n,o,i,s){const r=(s-e)/(o-e);return mt(t,s,n+(i-n)*r,1),r}function gt(t,e,n,o,i,s){const r=(s-n)/(i-n);return mt(t,e+(o-e)*r,s,1),r}function yt(t,e){const n=[];for(let o=0;o<t.length;o++){const i=t[o],s=i.type;let r;if("Point"===s||"MultiPoint"===s||"LineString"===s)r=xt(i.geometry,e);else if("MultiLineString"===s||"Polygon"===s){r=[];for(const t of i.geometry)r.push(xt(t,e))}else if("MultiPolygon"===s){r=[];for(const t of i.geometry){const n=[];for(const o of t)n.push(xt(o,e));r.push(n)}}n.push(et(i.id,s,r,i.tags))}return n}function xt(t,e){const n=[];n.size=t.size,void 0!==t.start&&(n.start=t.start,n.end=t.end);for(let o=0;o<t.length;o+=3)n.push(t[o]+e,t[o+1],t[o+2]);return n}function _t(t,e){if(t.transformed)return t;const n=1<<t.z,o=t.x,i=t.y;for(const s of t.features){const t=s.geometry,r=s.type;if(s.geometry=[],1===r)for(let r=0;r<t.length;r+=2)s.geometry.push(bt(t[r],t[r+1],e,n,o,i));else for(let r=0;r<t.length;r++){const a=[];for(let s=0;s<t[r].length;s+=2)a.push(bt(t[r][s],t[r][s+1],e,n,o,i));s.geometry.push(a)}}return t.transformed=!0,t}function bt(t,e,n,o,i,s){return[Math.round(n*(t*o-i)),Math.round(n*(e*o-s))]}function wt(t,e,n,o,i){const s=e===i.maxZoom?0:i.tolerance/((1<<e)*i.extent),r={features:[],numPoints:0,numSimplified:0,numFeatures:t.length,source:null,x:n,y:o,z:e,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0};for(const e of t)Mt(r,e,s,i);return r}function Mt(t,e,n,o){const i=e.geometry,s=e.type,r=[];if(t.minX=Math.min(t.minX,e.minX),t.minY=Math.min(t.minY,e.minY),t.maxX=Math.max(t.maxX,e.maxX),t.maxY=Math.max(t.maxY,e.maxY),"Point"===s||"MultiPoint"===s)for(let e=0;e<i.length;e+=3)r.push(i[e],i[e+1]),t.numPoints++,t.numSimplified++;else if("LineString"===s)vt(r,i,t,n,!1,!1);else if("MultiLineString"===s||"Polygon"===s)for(let e=0;e<i.length;e++)vt(r,i[e],t,n,"Polygon"===s,0===e);else if("MultiPolygon"===s)for(let e=0;e<i.length;e++){const o=i[e];for(let e=0;e<o.length;e++)vt(r,o[e],t,n,!0,0===e)}if(r.length){let n=e.tags||null;if("LineString"===s&&o.lineMetrics){n={};for(const t in e.tags)n[t]=e.tags[t];n.mapbox_clip_start=i.start/i.size,n.mapbox_clip_end=i.end/i.size}const a={geometry:r,type:"Polygon"===s||"MultiPolygon"===s?3:"LineString"===s||"MultiLineString"===s?2:1,tags:n};null!==e.id&&(a.id=e.id),t.features.push(a)}}function vt(t,e,n,o,i,s){const r=o*o;if(o>0&&e.size<(i?r:o))return void(n.numPoints+=e.length/3);const a=[];for(let t=0;t<e.length;t+=3)(0===o||e[t+2]>r)&&(n.numSimplified++,a.push(e[t],e[t+1])),n.numPoints++;i&&function(t,e){let n=0;for(let e=0,o=t.length-2;e<t.length;o=e,e+=2)n+=(t[e]-t[o])*(t[e+1]+t[o+1]);if(n>0===e)for(let e=0,n=t.length;e<n/2;e+=2){const o=t[e],i=t[e+1];t[e]=t[n-2-e],t[e+1]=t[n-1-e],t[n-2-e]=o,t[n-1-e]=i}}(a,s),t.push(a)}const Pt={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:void 0,generateId:!1,debug:0};class St{options;tiles={};tileCoords=[];stats={};total=0;constructor(t,e){this.options={...Pt,...e};const n=(e=this.options).debug;if(n&&console.time("preprocess data"),this.options.maxZoom<0||this.options.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(e.promoteId&&this.options.generateId)throw new Error("promoteId and generateId cannot be used together.");let o=function(t,e){const n=[];if("FeatureCollection"===t.type)for(let o=0;o<t.features.length;o++)ot(n,t.features[o],e,o);else"Feature"===t.type?ot(n,t,e):ot(n,{geometry:t},e);return n}(t,e);n&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",e.indexMaxZoom,e.indexMaxPoints),console.time("generate tiles")),o=function(t,e){const n=e.buffer/e.extent;let o=t;const i=ut(t,1,-1-n,n,0,-1,2,e),s=ut(t,1,1-n,2+n,0,-1,2,e);return(i||s)&&(o=ut(t,1,-n,1+n,0,-1,2,e)||[],i&&(o=yt(i,1).concat(o)),s&&(o=o.concat(yt(s,-1)))),o}(o,this.options),o.length&&this.splitTile(o,0,0,0),n&&(o.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)))}getTile(t,e,n){const{extent:o,debug:i}=this.options;if(t<0||t>24)return null;const s=1<<t,r=Vt(t,e=e+s&s-1,n);if(this.tiles[r])return _t(this.tiles[r],o);i>1&&console.log("drilling down to z%d-%d-%d",t,e,n);let a,l=t,u=e,c=n;for(;!a&&l>0;)l--,u>>=1,c>>=1,a=this.tiles[Vt(l,u,c)];return a&&a.source?(i>1&&(console.log("found parent tile z%d-%d-%d",l,u,c),console.time("drilling down")),this.splitTile(a.source,l,u,c,t,e,n),i>1&&console.timeEnd("drilling down"),this.tiles[r]?_t(this.tiles[r],o):null):null}splitTile(t,e,n,o,i,s,r){const a=[t,e,n,o],l=this.options,u=l.debug;for(;a.length;){o=a.pop(),n=a.pop(),e=a.pop(),t=a.pop();const c=1<<e,h=Vt(e,n,o);let p=this.tiles[h];if(!p&&(u>1&&console.time("creation"),p=this.tiles[h]=wt(t,e,n,o,l),this.tileCoords.push({z:e,x:n,y:o}),u)){u>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",e,n,o,p.numFeatures,p.numPoints,p.numSimplified),console.timeEnd("creation"));const t=`z${e}`;this.stats[t]=(this.stats[t]||0)+1,this.total++}if(p.source=t,void 0===i){if(e===l.indexMaxZoom||p.numPoints<=l.indexMaxPoints)continue}else{if(e===l.maxZoom||e===i)continue;if(void 0!==i){const t=i-e;if(n!==s>>t||o!==r>>t)continue}}if(p.source=null,0===t.length)continue;u>1&&console.time("clipping");const f=.5*l.buffer/l.extent,m=.5-f,d=.5+f,g=1+f;let y=null,x=null,_=null,b=null,w=ut(t,c,n-f,n+d,0,p.minX,p.maxX,l),M=ut(t,c,n+m,n+g,0,p.minX,p.maxX,l);t=null,w&&(y=ut(w,c,o-f,o+d,1,p.minY,p.maxY,l),x=ut(w,c,o+m,o+g,1,p.minY,p.maxY,l),w=null),M&&(_=ut(M,c,o-f,o+d,1,p.minY,p.maxY,l),b=ut(M,c,o+m,o+g,1,p.minY,p.maxY,l),M=null),u>1&&console.timeEnd("clipping"),a.push(y||[],e+1,2*n,2*o),a.push(x||[],e+1,2*n,2*o+1),a.push(_||[],e+1,2*n+1,2*o),a.push(b||[],e+1,2*n+1,2*o+1)}}}function Vt(t,e,n){return 32*((1<<t)*n+e)+t}export{St as GeoJSONTiler,N as MVTLoader,q as MVTSource,Y as MVTWorkerLoader,D as TileJSONLoader};export default null;
