/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@loaders.gl/zip@4.2.0/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import e from"../../jszip@3.10.1/_esm.js";import{concatenateArrayBuffers as t,compareArrayBuffers as n,FileHandleFile as i,NodeFile as a,path as s,NodeFilesystem as r,isBrowser as o,isFileProvider as f,concatenateArrayBuffersFromArray as c}from"../loader-utils@4.2.0/_esm.js";import{CRC32Hash as l,MD5Hash as u}from"../crypto@4.2.0/_esm.js";import{fetchFile as h}from"../core@4.2.0/_esm.js";import{DeflateCompression as d}from"../compression@4.2.0/_esm.js";const w={dataType:null,batchType:null,id:"zip",module:"zip",name:"Zip Archive",version:"4.2.0-beta.2",extensions:["zip"],mimeTypes:["application/zip"],category:"archive",tests:["PK"],options:{},parse:async function(t,n={}){const i=[],a={};try{const s=new e;return(await s.loadAsync(t,n)).forEach(((e,t)=>{const r=t.name,o=async function(e,t,n={}){try{return await e.file(t).async(n.dataType||"arraybuffer")}catch(e){return n.log.error(`Unable to read ${t} from zip archive: ${e}`),e}}(s,r,n).then((t=>{a[e]=t}));i.push(o)})),await Promise.all(i),a}catch(e){throw n.log.error(`Unable to read zip archive: ${e}`),e}}};const g={name:"Zip Archive",id:"zip",module:"zip",version:"4.2.0-beta.2",extensions:["zip"],category:"archive",mimeTypes:["application/zip"],options:{zip:{onUpdate:()=>{}},jszip:{}},encode:async function(t,n={}){const i=new e;for(const e in t){const a=t[e];i.file(e,a,n?.jszip||{})}const a={...g.options.zip,...n?.zip},s={...g.options?.jszip,...n.jszip};try{return await i.generateAsync({...s,type:"arraybuffer"},a.onUpdate)}catch(e){throw n.log.error(`Unable to encode zip archive: ${e}`),e}}};function p(e){let t;const n=new Uint8Array(e);for(t=0;t<e;t+=1)n[t]=0;return n}function m(e,t,n){const i=e.toString(n||8);return"000000000000".substr(i.length+12-t)+i}const z={fileName:100,fileMode:8,uid:8,gid:8,fileSize:12,mtime:12,checksum:8,type:1,linkName:100,ustar:8,owner:32,group:32,majorNumber:8,minorNumber:8,filenamePrefix:155,padding:12};let y,b,U;const N=512;class B{written;out;blocks=[];length;constructor(e){this.written=0,y=(e||20)*N,this.out=p(y),this.blocks=[],this.length=0,this.save=this.save.bind(this),this.clear=this.clear.bind(this),this.append=this.append.bind(this)}append(e,t,n){let i;if("string"==typeof t)t=function(e,t,n){let i,a;for(t=t||p(e.length),n=n||0,i=0,a=e.length;i<a;i+=1)t[n]=e.charCodeAt(i),n+=1;return t}(t);else if(t.constructor&&t.constructor!==Uint8Array.prototype.constructor){const e=/function\s*([$A-Za-z_][0-9A-Za-z_]*)\s*\(/.exec(t.constructor.toString());throw`Invalid input type. You gave me: ${e&&e[1]}`}const a=(n=n||{}).mode||4095&parseInt("777",8),s=n.mtime||Math.floor(Number(new Date)/1e3),r=n.uid||0,o=n.gid||0,f={fileName:e,fileMode:m(a,7),uid:m(r,7),gid:m(o,7),fileSize:m(t.length,11),mtime:m(s,11),checksum:"        ",type:"0",ustar:"ustar  ",owner:n.owner||"",group:n.group||""};i=0,Object.keys(f).forEach((e=>{let t;const n=f[e];let a;for(t=0,a=n.length;t<a;t+=1)i+=n.charCodeAt(t)})),f.checksum=`${m(i,6)}\0 `;const c=function(e,t){const n=p(512);let i=0;return Object.entries(z).forEach((([t,a])=>{const s=e[t]||"";let r,o;for(r=0,o=s.length;r<o;r+=1)n[i]=s.charCodeAt(r),i+=1;i+=a-r})),"function"==typeof t?t(n,i):n}(f);b=Math.ceil(c.length/N)*N,U=Math.ceil(t.length/N)*N,this.blocks.push({header:c,input:t,headerLength:b,inputLength:U})}save(){const e=[],t=new Array;let n=0;const i=Math.pow(2,20);let a=new Array;return this.blocks.forEach(((e=[])=>{n+e.headerLength+e.inputLength>i&&(t.push({blocks:a,length:n}),a=[],n=0),a.push(e),n+=e.headerLength+e.inputLength})),t.push({blocks:a,length:n}),t.forEach(((t=[])=>{const n=new Uint8Array(t.length);let i=0;t.blocks.forEach(((e=[])=>{n.set(e.header,i),i+=e.headerLength,n.set(e.input,i),i+=e.inputLength})),e.push(n)})),e.push(new Uint8Array(1024)),new Blob(e,{type:"octet/stream"})}clear(){this.written=0,this.out=p(y)}}const D={recordsPerBlock:20};class A{static get properties(){return{id:"tar",name:"TAR",extensions:["tar"],mimeTypes:["application/x-tar"],builder:A,options:D}}options;tape;count=0;constructor(e){this.options={...D,...e},this.tape=new B(this.options.recordsPerBlock)}addFile(e,t){this.tape.append(e,new Uint8Array(t)),this.count++}async build(){return new Response(this.tape.save()).arrayBuffer()}}const v=async(e,t)=>{const n=[await e.getUint8(e.length-1n),await e.getUint8(e.length-2n),await e.getUint8(e.length-3n),void 0];let i=0n;for(let a=e.length-4n;a>-1;a--)if(n[3]=n[2],n[2]=n[1],n[1]=n[0],n[0]=await e.getUint8(a),n.every(((e,n)=>e===t[n]))){i=a;break}return i},O=new Uint8Array([1,0]);function L(e){const n={...e,zip64Length:8*(e.offset?1:0)+16*(e.size?1:0)},i=[];for(const e of I){if(!n[e.name??""]&&!e.default)continue;const t=new DataView(new ArrayBuffer(e.size));x[e.size](t,0,n[e.name??""]??e.default),i.push(t.buffer)}return t(...i)}function E(e,t,n,i){x[t](e,Number(n),i)}const x={2:(e,t,n)=>{e.setUint16(t,Number(n>65535?65535:n),!0)},4:(e,t,n)=>{e.setUint32(t,Number(n>4294967295?4294967295:n),!0)},8:(e,t,n)=>{e.setBigUint64(t,BigInt(n),!0)}},I=[{size:2,default:new DataView(O.buffer).getUint16(0,!0)},{size:2,name:"zip64Length"},{size:8,name:"size"},{size:8,name:"size"},{size:8,name:"offset"}],S=new Uint8Array([80,75,5,6]),C=new Uint8Array([80,75,6,7]),P=new Uint8Array([80,75,6,6]),k=8n,j=10n,V=12n,T=16n,H=22n,F=8n,$=24n,M=32n,R=40n,Z=48n,_=56n,W=async e=>{const t=await v(e,S);let i=BigInt(await e.getUint16(t+k)),a=BigInt(await e.getUint32(t+T)),s=t-20n,r=0n;const o=await e.slice(s,s+4n);if(n(o,C)){r=await e.getBigUint64(s+F);const t=await e.slice(r,r+4n);if(!n(t,P.buffer))throw new Error("zip64 EoCD not found");i=await e.getBigUint64(r+$),a=await e.getBigUint64(r+Z)}else s=0n;return{cdRecordsNumber:i,cdStartOffset:a,offsets:{zip64EoCDOffset:r,zip64EoCDLocatorOffset:s,zipEoCDOffset:t}}};function G(e){const n=new DataView(new ArrayBuffer(Number(H)));for(const t of K)E(n,t.size,t.offset,e[t.name??""]??t.default??0);const i=function(e){const t=new DataView(new ArrayBuffer(Number(20)));for(const n of Y)E(t,n.size,n.offset,e[n.name??""]??n.default??0);return t.buffer}(e),a=function(e){const t=new DataView(new ArrayBuffer(Number(_)));for(const n of q)E(t,n.size,n.offset,e[n.name??""]??n.default??0);return t.buffer}(e);return t(a,i,n.buffer)}const K=[{offset:0,size:4,default:new DataView(S.buffer).getUint32(0,!0)},{offset:4,size:2,default:0},{offset:6,size:2,default:0},{offset:8,size:2,name:"recordsNumber"},{offset:10,size:2,name:"recordsNumber"},{offset:12,size:4,name:"cdSize"},{offset:16,size:4,name:"cdOffset"},{offset:20,size:2,default:0}];const Y=[{offset:0,size:4,default:new DataView(C.buffer).getUint32(0,!0)},{offset:4,size:4,default:0},{offset:8,size:8,name:"eoCDStart"},{offset:16,size:4,default:1}],q=[{offset:0,size:4,default:new DataView(P.buffer).getUint32(0,!0)},{offset:4,size:8,default:44},{offset:12,size:2,default:45},{offset:14,size:2,default:45},{offset:16,size:4,default:0},{offset:20,size:4,default:0},{offset:24,size:8,name:"recordsNumber"},{offset:32,size:8,name:"recordsNumber"},{offset:40,size:8,name:"cdSize"},{offset:48,size:8,name:"cdOffset"}],J=20n,Q=24n,X=28n,ee=30n,te=32n,ne=42n,ie=46n,ae=new Uint8Array([80,75,1,2]),se=async(e,t)=>{const i=await t.slice(e,e+4n);if(!n(i,ae.buffer))return null;const a=BigInt(await t.getUint32(e+J)),s=BigInt(await t.getUint32(e+Q)),r=await t.getUint16(e+ee),o=BigInt(await t.getUint16(e+te)),f=await t.getUint16(e+X),c=await t.slice(e+ie,e+ie+BigInt(f)),l=(new TextDecoder).decode(c),u=e+ie+BigInt(f),h=await t.getUint32(e+ne),d=BigInt(h),w=new DataView(await t.slice(u,u+BigInt(r))),g={uncompressedSize:s,compressedSize:a,localHeaderOffset:d,startDisk:o},p=fe(g,w);return{...g,...p,extraFieldLength:r,fileNameLength:f,fileName:l,extraOffset:u}};async function*re(e){const{cdStartOffset:t}=await W(e);let n=await se(t,e);for(;n;)yield n,n=await se(n.extraOffset+BigInt(n.extraFieldLength),e)}const oe=(...e)=>e[0]+16*e[1],fe=(e,t)=>{const n=ce(e),i={};if(n.length>0){const e=n.reduce(((e,t)=>e+t.length),0),a=new Uint8Array(t.buffer).findIndex(((t,n,i)=>1===oe(i[n],i[n+1])&&oe(i[n+2],i[n+3])===e));let s=0;for(const e of n){const n=s;i[e.name]=t.getBigUint64(a+4+n,!0),s=n+e.length}}return i},ce=e=>{const t=[];return e.uncompressedSize===BigInt(4294967295)&&t.push({name:"uncompressedSize",length:8}),e.compressedSize===BigInt(4294967295)&&t.push({name:"compressedSize",length:8}),e.localHeaderOffset===BigInt(4294967295)&&t.push({name:"localHeaderOffset",length:8}),e.startDisk===BigInt(4294967295)&&t.push({name:"startDisk",length:4}),t};function le(e){const n={...e,fnlength:e.fileName.length,extraLength:0};let i=new ArrayBuffer(0);const a={};n.offset>=4294967295&&(a.offset=n.offset,n.offset=BigInt(4294967295)),n.length>=4294967295&&(a.size=n.length,n.length=4294967295),Object.keys(a).length&&(i=L(a),n.extraLength=i.byteLength);const s=new DataView(new ArrayBuffer(Number(ie)));for(const e of ue)E(s,e.size,e.offset,n[e.name??""]??e.default??0);const r=(new TextEncoder).encode(n.fileName);return t(s.buffer,r,i)}const ue=[{offset:0,size:4,default:new DataView(ae.buffer).getUint32(0,!0)},{offset:4,size:2,default:45},{offset:6,size:2,default:45},{offset:8,size:2,default:0},{offset:10,size:2,default:0},{offset:12,size:2,default:0},{offset:14,size:2,default:0},{offset:16,size:4,name:"crc32"},{offset:20,size:4,name:"length"},{offset:24,size:4,name:"length"},{offset:28,size:2,name:"fnlength"},{offset:30,size:2,default:0,name:"extraLength"},{offset:32,size:2,default:0},{offset:34,size:2,default:0},{offset:36,size:2,default:0},{offset:38,size:4,default:0},{offset:42,size:4,name:"offset"}],he=8n,de=18n,we=22n,ge=26n,pe=28n,me=30n,ze=new Uint8Array([80,75,3,4]),ye=async(e,t)=>{const i=await t.slice(e,e+4n);if(!n(i,ze))return null;const a=await t.getUint16(e+ge),s=(new TextDecoder).decode(await t.slice(e+me,e+me+BigInt(a))).split("\\").join("/"),r=await t.getUint16(e+pe);let o=e+me+BigInt(a+r);const f=await t.getUint16(e+he);let c=BigInt(await t.getUint32(e+de)),l=BigInt(await t.getUint32(e+we));const u=e+me+BigInt(a);let h=4n;return l===BigInt(4294967295)&&(l=await t.getBigUint64(u+h),h+=8n),c===BigInt(4294967295)&&(c=await t.getBigUint64(u+h),h+=8n),o===BigInt(4294967295)&&(o=await t.getBigUint64(u+h)),{fileNameLength:a,fileName:s,extraFieldLength:r,fileDataOffset:o,compressedSize:c,compressionMethod:f}};function be(e){const n={...e,extraLength:0,fnlength:e.fileName.length};let i=new ArrayBuffer(0);const a={};n.length>=4294967295&&(a.size=n.length,n.length=4294967295),Object.keys(a).length&&(i=L(a),n.extraLength=i.byteLength);const s=new DataView(new ArrayBuffer(Number(me)));for(const e of Ue)E(s,e.size,e.offset,n[e.name??""]??e.default??0);const r=(new TextEncoder).encode(n.fileName);return t(s.buffer,r,i)}const Ue=[{offset:0,size:4,default:new DataView(ze.buffer).getUint32(0,!0)},{offset:4,size:2,default:45},{offset:6,size:2,default:0},{offset:8,size:2,default:0},{offset:10,size:2,default:0},{offset:12,size:2,default:0},{offset:14,size:4,name:"crc32"},{offset:18,size:4,name:"length"},{offset:22,size:4,name:"length"},{offset:26,size:2,name:"fnlength"},{offset:28,size:2,default:0,name:"extraLength"}];async function Ne(e,n,i){const a=parseInt(await(new l).hash(n,"hex"),16),s=be({crc32:a,fileName:e,length:n.byteLength}),r=le({crc32:a,fileName:e,offset:i,length:n.byteLength});return[new Uint8Array(t(s,n)),new Uint8Array(r)]}async function Be(e,n,a){const s=new i(e,!0),[r,o,f]=await async function(e){const t=await W(e),n=t.cdStartOffset,i=Number(t.offsets.zip64EoCDOffset?t.offsets.zip64EoCDOffset-n:t.offsets.zipEoCDOffset-n),a=await e.slice(n,e.length);return await e.truncate(Number(n)),[a.slice(0,i),a.slice(i,a.byteLength),t]}(s),c=s.length,[l,u]=await Ne(a,n,c);await s.append(l);const h=t(r,u),d=s.length;await s.append(new Uint8Array(h));const w=s.length;await s.append(function(e,t,n,i,a){const s=new DataView(e),r=t.zip64EoCDOffset?t.zipEoCDOffset-t.zip64EoCDOffset:0n;Number(a)<=65535&&(E(s,2,r+k,a),E(s,2,r+j,a)),i-n<=4294967295&&E(s,4,r+V,i-n),n<4294967295&&E(s,4,r+T,n),t.zip64EoCDLocatorOffset&&t.zip64EoCDOffset&&(E(s,8,t.zip64EoCDLocatorOffset-t.zip64EoCDOffset+F,i),E(s,8,Z,n),E(s,8,$,a),E(s,8,M,a),E(s,8,R,i-n));return new Uint8Array(s.buffer)}(o,f.offsets,d,w,f.cdRecordsNumber+1n))}async function De(e,n,i){const r=function(e){async function*t(){const t=await ve(e);for(const n of t){const t=await(await h(s.join(e,n))).arrayBuffer();yield{path:n,file:t}}}return t()}(e),o=new a(n,"w"),f=[],c=[];for await(const e of r)await Ae(e,o,c,f);if(i){const e=await i(f);await Ae(e,o,c)}const l=(await o.stat()).bigsize,u=t(...c);await o.append(new Uint8Array(u));const d=(await o.stat()).bigsize;await o.append(new Uint8Array(G({recordsNumber:c.length,cdSize:u.byteLength,cdOffset:l,eoCDStart:d})))}async function Ae(e,t,n,i){const a=(await t.stat()).bigsize;i?.push({fileName:e.path,localHeaderOffset:a});const[s,r]=await Ne(e.path,e.file,a);await t.append(s),n.push(r)}async function ve(e,t="",n){const i=n||new r({}),a=await i.readdir(Oe(e,t)),s=[];for(const n of a){const a=Oe(e,t,n);if((await i.stat(a)).isDirectory){const i=await ve(e,Oe(t,n));s.push(...i)}else s.push(Oe(t,n))}return s}function Oe(...e){const t=e.filter((e=>e.length));return s.join(...t)}const Le={0:async e=>e,8:async e=>{const t=new d({raw:!0});return await t.decompress(e)}};class Ee{fileProvider=null;fileName;archive=null;constructor(e){if("string"==typeof e){if(this.fileName=e,o)throw new Error("Cannot open file for random access in a WEB browser");this.fileProvider=new i(e)}else e instanceof xe?(this.fileProvider=e.fileProvider,this.archive=e,this.fileName=e.fileName):f(e)&&(this.fileProvider=e)}async destroy(){this.fileProvider&&await this.fileProvider.destroy()}async readdir(){if(!this.fileProvider)throw new Error("No data detected in the zip archive");const e=[],t=re(this.fileProvider);for await(const n of t)e.push(n.fileName);return e}async stat(e){const t=await this.getCDFileHeader(e);return{...t,size:Number(t.uncompressedSize)}}async fetch(e){let t;if(this.fileName&&0===e.indexOf(this.fileName)&&(e=e.substring(this.fileName.length+1)),this.archive)t=await this.archive.getFile(e,"http");else{if(!this.fileProvider)throw new Error("No data detected in the zip archive");const n=await this.getCDFileHeader(e),i=await ye(n.localHeaderOffset,this.fileProvider);if(!i)throw new Error("Local file header has not been found in the zip archive`");const a=Le[i.compressionMethod.toString()];if(!a)throw Error("Only Deflation compression is supported");const s=await this.fileProvider.slice(i.fileDataOffset,i.fileDataOffset+i.compressedSize);t=await a(s)}const n=new Response(t);return Object.defineProperty(n,"url",{value:e?`${this.fileName||""}/${e}`:this.fileName||""}),n}async getCDFileHeader(e){if(!this.fileProvider)throw new Error("No data detected in the zip archive");const t=re(this.fileProvider);let n=null;for await(const i of t)if(i.fileName===e){n=i;break}if(!n)throw new Error("File has not been found in the zip archive");return n}}class xe{fileProvider;fileName;constructor(e,t,n){this.fileProvider=e,this.fileName=n}async getFileWithoutHash(e){const t=new Ee(this.fileProvider),n=await t.fetch(e);return await n.arrayBuffer()}}function Ie(e){const t=new DataView(e),n={};for(let i=0;i<e.byteLength;i+=24){const a=t.getBigUint64(i+16,!0);n[[...new Uint8Array(e,i,16)].map((e=>e.toString(16).padStart(2,"0"))).join("")]=a}return n}async function Se(e){return async function(e){const t=new u,n=new TextEncoder,i={};for await(const a of e){const e=a.fileName.split("\\").join("/").toLocaleLowerCase(),s=n.encode(e).buffer;i[await t.hash(s,"hex")]=a.localHeaderOffset}return i}(re(e))}async function Ce(e){const n=new u,i=new TextEncoder,a=[];for await(const r of e){let e=r.fileName.split("\\").join("/");"3dSceneLayer.json.gz"!==e&&(e=e.toLocaleLowerCase());const o=i.encode(e).buffer,f=await n.hash(o,"hex");a.push(t(ke(f),(s=r.localHeaderOffset,new BigUint64Array([s]).buffer)))}var s;const r=a.sort(Pe);return c(r)}function Pe(e,t){const n=new BigUint64Array(e),i=new BigUint64Array(t);return Number(n[0]===i[0]?n[1]-i[1]:n[0]-i[0])}function ke(e){const t=e.match(/../g)?.map((e=>parseInt(e,16)));return new Uint8Array(t??new Array(16)).buffer}export{ae as CD_HEADER_SIGNATURE,xe as IndexedArchive,A as TarBuilder,Le as ZIP_COMPRESSION_HANDLERS,Ee as ZipFileSystem,w as ZipLoader,g as ZipWriter,Be as addOneFile,Ce as composeHashFile,De as createZip,le as generateCDHeader,be as generateLocalHeader,ze as localHeaderSignature,Se as makeHashTableFromZipHeaders,re as makeZipCDHeaderIterator,W as parseEoCDRecord,Ie as parseHashTable,se as parseZipCDFileHeader,ye as parseZipLocalFileHeader,v as searchFromTheEnd};export default null;
