/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@loaders.gl/terrain@4.2.0/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{concatenateTypedArrays as e,parseFromContext as t}from"../loader-utils@4.2.0/_esm.js";import{getMeshBoundingBox as s}from"../schema@4.2.0/_esm.js";import i from"../../@mapbox/martini@0.2.0/_esm.js";const n=new Map([["centerX",Float64Array.BYTES_PER_ELEMENT],["centerY",Float64Array.BYTES_PER_ELEMENT],["centerZ",Float64Array.BYTES_PER_ELEMENT],["minHeight",Float32Array.BYTES_PER_ELEMENT],["maxHeight",Float32Array.BYTES_PER_ELEMENT],["boundingSphereCenterX",Float64Array.BYTES_PER_ELEMENT],["boundingSphereCenterY",Float64Array.BYTES_PER_ELEMENT],["boundingSphereCenterZ",Float64Array.BYTES_PER_ELEMENT],["boundingSphereRadius",Float64Array.BYTES_PER_ELEMENT],["horizonOcclusionPointX",Float64Array.BYTES_PER_ELEMENT],["horizonOcclusionPointY",Float64Array.BYTES_PER_ELEMENT],["horizonOcclusionPointZ",Float64Array.BYTES_PER_ELEMENT]]);function r(e){return e>>1^-(1&e)}function a(e,t,s,i,n=!0){let r;if(r=2===i?new Uint16Array(e,t,s):new Uint32Array(e,t,s),!n)return r;let a=0;for(let e=0;e<r.length;++e){const t=r[e];r[e]=a-t,0===t&&++a}return r}function o(e){return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const h={header:0,vertices:1,triangleIndices:2,edgeIndices:3,extensions:4},l={maxDecodingStep:h.extensions};function d(e,t){const s=Object.assign({},l,t),i=new DataView(e),{header:d,headerEndPosition:u}=function(e){let t=0;const s={};for(const[i,r]of n){const n=8===r?e.getFloat64:e.getFloat32;s[i]=n.call(e,t,!0),t+=r}return{header:s,headerEndPosition:t}}(i);if(s.maxDecodingStep<h.vertices)return{header:d};const{vertexData:c,vertexDataEndPosition:g}=function(e,t){let s=t;const i=e.getUint32(s,!0),n=new Uint16Array(3*i);s+=Uint32Array.BYTES_PER_ELEMENT;const a=Uint16Array.BYTES_PER_ELEMENT,o=i*a,h=s,l=h+o,d=l+o;let u=0,c=0,g=0;for(let t=0;t<i;t++)u+=r(e.getUint16(h+a*t,!0)),c+=r(e.getUint16(l+a*t,!0)),g+=r(e.getUint16(d+a*t,!0)),n[t]=u,n[t+i]=c,n[t+2*i]=g;return s+=3*o,{vertexData:n,vertexDataEndPosition:s}}(i,u);if(s.maxDecodingStep<h.triangleIndices)return{header:d,vertexData:c};const{triangleIndices:_,triangleIndicesEndPosition:E}=function(e,t,s){let i=s;const n=t.length/3>65536?Uint32Array.BYTES_PER_ELEMENT:Uint16Array.BYTES_PER_ELEMENT;i%n!=0&&(i+=n-i%n);const r=e.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const o=3*r,h=a(e.buffer,i,o,n);return i+=o*n,{triangleIndicesEndPosition:i,triangleIndices:h}}(i,c,g);if(s.maxDecodingStep<h.edgeIndices)return{header:d,vertexData:c,triangleIndices:_};const{westIndices:f,southIndices:T,eastIndices:m,northIndices:p,edgeIndicesEndPosition:I}=function(e,t,s){let i=s;const n=t.length/3>65536?Uint32Array.BYTES_PER_ELEMENT:Uint16Array.BYTES_PER_ELEMENT,r=e.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const o=a(e.buffer,i,r,n,!1);i+=r*n;const h=e.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const l=a(e.buffer,i,h,n,!1);i+=h*n;const d=e.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const u=a(e.buffer,i,d,n,!1);i+=d*n;const c=e.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const g=a(e.buffer,i,c,n,!1);return i+=c*n,{edgeIndicesEndPosition:i,westIndices:o,southIndices:l,eastIndices:u,northIndices:g}}(i,c,E);if(s.maxDecodingStep<h.extensions)return{header:d,vertexData:c,triangleIndices:_,westIndices:f,northIndices:p,eastIndices:m,southIndices:T};const{extensions:P}=function(e,t){const s={};if(e.byteLength<=t)return{extensions:s,extensionsEndPosition:t};let i=t;for(;i<e.byteLength;){const t=e.getUint8(i,!0);i+=Uint8Array.BYTES_PER_ELEMENT;const r=e.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const a=new DataView(e.buffer,i,r);switch(t){case 1:s.vertexNormals=(n=a,new Uint8Array(n.buffer,n.byteOffset,n.byteLength));break;case 2:s.waterMask=o(a)}i+=r}var n;return{extensions:s,extensionsEndPosition:i}}(i,I);return{header:d,vertexData:c,triangleIndices:_,westIndices:f,northIndices:p,eastIndices:m,southIndices:T,extensions:P}}function u(t,s,i,n){const r=n?function(e,t){e.westIndices.sort(((e,s)=>t[3*e+1]-t[3*s+1])),e.eastIndices.sort(((e,s)=>t[3*s+1]-t[3*e+1])),e.southIndices.sort(((e,s)=>t[3*s]-t[3*e])),e.northIndices.sort(((e,s)=>t[3*e]-t[3*s]));const s=[];for(const t in e){const i=e[t];for(let e=0;e<i.length-1;e++)s.push([i[e],i[e+1]])}return s}(n,t.POSITION.value):function(e){const t=[];for(let s=0;s<e.length;s+=3)t.push([e[s],e[s+1]]),t.push([e[s+1],e[s+2]]),t.push([e[s+2],e[s]]);t.sort(((e,t)=>Math.min(...e)-Math.min(...t)||Math.max(...e)-Math.max(...t)));const s=[];let i=0;for(;i<t.length;)t[i][0]===t[i+1]?.[1]&&t[i][1]===t[i+1]?.[0]?i+=2:(s.push(t[i]),i++);return s}(s),a=new t.POSITION.value.constructor(6*r.length),o=new t.TEXCOORD_0.value.constructor(4*r.length),h=new s.constructor(6*r.length);for(let e=0;e<r.length;e++){c({edge:r[e],edgeIndex:e,attributes:t,skirtHeight:i,newPosition:a,newTexcoord0:o,newTriangles:h})}t.POSITION.value=e(t.POSITION.value,a),t.TEXCOORD_0.value=e(t.TEXCOORD_0.value,o);return{attributes:t,triangles:s instanceof Array?s.concat(h):e(s,h)}}function c({edge:e,edgeIndex:t,attributes:s,skirtHeight:i,newPosition:n,newTexcoord0:r,newTriangles:a}){const o=s.POSITION.value.length,h=2*t,l=2*t+1;n.set(s.POSITION.value.subarray(3*e[0],3*e[0]+3),3*h),n[3*h+2]=n[3*h+2]-i,n.set(s.POSITION.value.subarray(3*e[1],3*e[1]+3),3*l),n[3*l+2]=n[3*l+2]-i,r.set(s.TEXCOORD_0.value.subarray(2*e[0],2*e[0]+2),2*h),r.set(s.TEXCOORD_0.value.subarray(2*e[1],2*e[1]+2),2*l);const d=2*t*3;a[d]=e[0],a[d+1]=o/3+l,a[d+2]=e[1],a[d+3]=o/3+l,a[d+4]=e[0],a[d+5]=o/3+h}function g(e,t={}){const{bounds:i}=t,{header:n,vertexData:r,triangleIndices:a,westIndices:o,northIndices:l,eastIndices:c,southIndices:g}=d(e,h.triangleIndices);let _=a,E=function(e,t,s){const{minHeight:i,maxHeight:n}=t,[r,a,o,h]=s||[0,0,1,1],l=o-r,d=h-a,u=n-i,c=e.length/3,g=new Float32Array(3*c),_=new Float32Array(2*c);for(let t=0;t<c;t++){const s=e[t]/32767,n=e[t+c]/32767,o=e[t+2*c]/32767;g[3*t+0]=s*l+r,g[3*t+1]=n*d+a,g[3*t+2]=o*u+i,_[2*t+0]=s,_[2*t+1]=n}return{POSITION:{value:g,size:3},TEXCOORD_0:{value:_,size:2}}}(r,n,i);const f=s(E);if(t?.skirtHeight){const{attributes:e,triangles:s}=u(E,_,t.skirtHeight,{westIndices:o,northIndices:l,eastIndices:c,southIndices:g});E=e,_=s}return{loaderData:{header:{}},header:{vertexCount:_.length,boundingBox:f},schema:void 0,topology:"triangle-list",mode:4,indices:{value:_,size:1},attributes:E}}class _{constructor(e,t,s=t){this.data=e,this.width=t,this.height=s,this.coords=[],this.triangles=[],this._halfedges=[],this._candidates=[],this._queueIndices=[],this._queue=[],this._errors=[],this._rms=[],this._pending=[],this._pendingLen=0,this._rmsSum=0;const i=t-1,n=s-1,r=this._addPoint(0,0),a=this._addPoint(i,0),o=this._addPoint(0,n),h=this._addPoint(i,n),l=this._addTriangle(h,r,o,-1,-1,-1);this._addTriangle(r,h,a,l,-1,-1),this._flush()}run(e=1){for(;this.getMaxError()>e;)this.refine()}refine(){this._step(),this._flush()}getMaxError(){return this._errors[0]}getRMSD(){return this._rmsSum>0?Math.sqrt(this._rmsSum/(this.width*this.height)):0}heightAt(e,t){return this.data[this.width*t+e]}_flush(){const e=this.coords;for(let t=0;t<this._pendingLen;t++){const s=this._pending[t],i=2*this.triangles[3*s+0],n=2*this.triangles[3*s+1],r=2*this.triangles[3*s+2];this._findCandidate(e[i],e[i+1],e[n],e[n+1],e[r],e[r+1],s)}this._pendingLen=0}_findCandidate(e,t,s,i,n,r,a){const o=Math.min(e,s,n),h=Math.min(t,i,r),l=Math.max(e,s,n),d=Math.max(t,i,r);let u=E(s,i,n,r,o,h),c=E(n,r,e,t,o,h),g=E(e,t,s,i,o,h);const _=i-t,f=e-s,T=r-i,m=s-n,p=t-r,I=n-e,P=E(e,t,s,i,n,r),S=this.heightAt(e,t)/P,y=this.heightAt(s,i)/P,w=this.heightAt(n,r)/P;let b=0,x=0,v=0,M=0;for(let e=h;e<=d;e++){let t=0;u<0&&0!==T&&(t=Math.max(t,Math.floor(-u/T))),c<0&&0!==p&&(t=Math.max(t,Math.floor(-c/p))),g<0&&0!==_&&(t=Math.max(t,Math.floor(-g/_)));let s=u+T*t,i=c+p*t,n=g+_*t,r=!1;for(let a=o+t;a<=l;a++){if(s>=0&&i>=0&&n>=0){r=!0;const t=S*s+y*i+w*n,o=Math.abs(t-this.heightAt(a,e));M+=o*o,o>b&&(b=o,x=a,v=e)}else if(r)break;s+=T,i+=p,n+=_}u+=m,c+=I,g+=f}(x===e&&v===t||x===s&&v===i||x===n&&v===r)&&(b=0),this._candidates[2*a]=x,this._candidates[2*a+1]=v,this._rms[a]=M,this._queuePush(a,b,M)}_step(){const e=this._queuePop(),t=3*e+0,s=3*e+1,i=3*e+2,n=this.triangles[t],r=this.triangles[s],a=this.triangles[i],o=this.coords[2*n],h=this.coords[2*n+1],l=this.coords[2*r],d=this.coords[2*r+1],u=this.coords[2*a],c=this.coords[2*a+1],g=this._candidates[2*e],_=this._candidates[2*e+1],f=this._addPoint(g,_);if(0===E(o,h,l,d,g,_))this._handleCollinear(f,t);else if(0===E(l,d,u,c,g,_))this._handleCollinear(f,s);else if(0===E(u,c,o,h,g,_))this._handleCollinear(f,i);else{const e=this._halfedges[t],o=this._halfedges[s],h=this._halfedges[i],l=this._addTriangle(n,r,f,e,-1,-1,t),d=this._addTriangle(r,a,f,o,-1,l+1),u=this._addTriangle(a,n,f,h,l+2,d+1);this._legalize(l),this._legalize(d),this._legalize(u)}}_addPoint(e,t){const s=this.coords.length>>1;return this.coords.push(e,t),s}_addTriangle(e,t,s,i,n,r,a=this.triangles.length){const o=a/3;return this.triangles[a+0]=e,this.triangles[a+1]=t,this.triangles[a+2]=s,this._halfedges[a+0]=i,this._halfedges[a+1]=n,this._halfedges[a+2]=r,i>=0&&(this._halfedges[i]=a+0),n>=0&&(this._halfedges[n]=a+1),r>=0&&(this._halfedges[r]=a+2),this._candidates[2*o+0]=0,this._candidates[2*o+1]=0,this._queueIndices[o]=-1,this._rms[o]=0,this._pending[this._pendingLen++]=o,a}_legalize(e){const t=this._halfedges[e];if(t<0)return;const s=e-e%3,i=t-t%3,n=s+(e+1)%3,r=s+(e+2)%3,a=i+(t+2)%3,o=i+(t+1)%3,h=this.triangles[r],l=this.triangles[e],d=this.triangles[n],u=this.triangles[a],c=this.coords;if(!function(e,t,s,i,n,r,a,o){const h=e-a,l=t-o,d=s-a,u=i-o,c=n-a,g=r-o,_=d*d+u*u,E=c*c+g*g;return h*(u*E-_*g)-l*(d*E-_*c)+(h*h+l*l)*(d*g-u*c)<0}(c[2*h],c[2*h+1],c[2*l],c[2*l+1],c[2*d],c[2*d+1],c[2*u],c[2*u+1]))return;const g=this._halfedges[n],_=this._halfedges[r],E=this._halfedges[a],f=this._halfedges[o];this._queueRemove(s/3),this._queueRemove(i/3);const T=this._addTriangle(h,u,d,-1,E,g,s),m=this._addTriangle(u,h,l,T,_,f,i);this._legalize(T+1),this._legalize(m+2)}_handleCollinear(e,t){const s=t-t%3,i=s+(t+1)%3,n=s+(t+2)%3,r=this.triangles[n],a=this.triangles[t],o=this.triangles[i],h=this._halfedges[i],l=this._halfedges[n],d=this._halfedges[t];if(d<0){const t=this._addTriangle(e,r,a,-1,l,-1,s),i=this._addTriangle(r,e,o,t,-1,h);return this._legalize(t+1),void this._legalize(i+2)}const u=d-d%3,c=u+(d+2)%3,g=u+(d+1)%3,_=this.triangles[c],E=this._halfedges[c],f=this._halfedges[g];this._queueRemove(u/3);const T=this._addTriangle(r,a,e,l,-1,-1,s),m=this._addTriangle(a,_,e,f,-1,T+1,u),p=this._addTriangle(_,o,e,E,-1,m+1),I=this._addTriangle(o,r,e,h,T+2,p+1);this._legalize(T),this._legalize(m),this._legalize(p),this._legalize(I)}_queuePush(e,t,s){const i=this._queue.length;this._queueIndices[e]=i,this._queue.push(e),this._errors.push(t),this._rmsSum+=s,this._queueUp(i)}_queuePop(){const e=this._queue.length-1;return this._queueSwap(0,e),this._queueDown(0,e),this._queuePopBack()}_queuePopBack(){const e=this._queue.pop();return this._errors.pop(),this._rmsSum-=this._rms[e],this._queueIndices[e]=-1,e}_queueRemove(e){const t=this._queueIndices[e];if(t<0){const t=this._pending.indexOf(e);if(-1===t)throw new Error("Broken triangulation (something went wrong).");return void(this._pending[t]=this._pending[--this._pendingLen])}const s=this._queue.length-1;s!==t&&(this._queueSwap(t,s),this._queueDown(t,s)||this._queueUp(t)),this._queuePopBack()}_queueLess(e,t){return this._errors[e]>this._errors[t]}_queueSwap(e,t){const s=this._queue[e],i=this._queue[t];this._queue[e]=i,this._queue[t]=s,this._queueIndices[s]=t,this._queueIndices[i]=e;const n=this._errors[e];this._errors[e]=this._errors[t],this._errors[t]=n}_queueUp(e){let t=e;for(;;){const e=t-1>>1;if(e===t||!this._queueLess(t,e))break;this._queueSwap(e,t),t=e}}_queueDown(e,t){let s=e;for(;;){const e=2*s+1;if(e>=t||e<0)break;const i=e+1;let n=e;if(i<t&&this._queueLess(i,e)&&(n=i),!this._queueLess(n,s))break;this._queueSwap(s,n),s=n}return s>e}}function E(e,t,s,i,n,r){return(s-n)*(t-r)-(i-r)*(e-n)}function f(e,t){const{meshMaxError:i,bounds:n,elevationDecoder:r}=t,{data:a,width:o,height:h}=e;let l,d;switch(t.tesselator){case"martini":l=p(a,o,h,r,t.tesselator),d=T(i,o,l);break;case"delatin":l=p(a,o,h,r,t.tesselator),d=m(i,o,h,l);break;default:o!==h||h&o-1?(l=p(a,o,h,r,"delatin"),d=m(i,o,h,l)):(l=p(a,o,h,r,"martini"),d=T(i,o,l))}const{vertices:c}=d;let{triangles:g}=d,_=function(e,t,s,i,n){const r=s+1,a=e.length/2,o=new Float32Array(3*a),h=new Float32Array(2*a),[l,d,u,c]=n||[0,0,s,i],g=(u-l)/s,_=(c-d)/i;for(let n=0;n<a;n++){const a=e[2*n],d=e[2*n+1],u=d*r+a;o[3*n+0]=a*g+l,o[3*n+1]=-d*_+c,o[3*n+2]=t[u],h[2*n+0]=a/s,h[2*n+1]=d/i}return{POSITION:{value:o,size:3},TEXCOORD_0:{value:h,size:2}}}(c,l,o,h,n);const E=s(_);if(t.skirtHeight){const{attributes:e,triangles:s}=u(_,g,t.skirtHeight);_=e,g=s}return{loaderData:{header:{}},header:{vertexCount:g.length,boundingBox:E},mode:4,indices:{value:Uint32Array.from(g),size:1},attributes:_}}function T(e,t,s){const n=new i(t+1).createTile(s),{vertices:r,triangles:a}=n.getMesh(e);return{vertices:r,triangles:a}}function m(e,t,s,i){const n=new _(i,t+1,s+1);n.run(e);const{coords:r,triangles:a}=n;return{vertices:r,triangles:a}}function p(e,t,s,i,n){const{rScaler:r,bScaler:a,gScaler:o,offset:h}=i,l=new Float32Array((t+1)*(s+1));for(let i=0,n=0;n<s;n++)for(let s=0;s<t;s++,i++){const t=4*i,s=e[t+0],d=e[t+1],u=e[t+2];l[i+n]=s*r+d*o+u*a+h}if("martini"===n){for(let e=(t+1)*t,s=0;s<t;s++,e++)l[e]=l[e-t-1];for(let e=s,t=0;t<s+1;t++,e+=s+1)l[e]=l[e-1]}return l}const I="4.2.0-beta.2",P={dataType:null,batchType:null,name:"Terrain",id:"terrain",module:"terrain",version:I,worker:!0,extensions:["png","pngraw","jpg","jpeg","gif","webp","bmp"],mimeTypes:["image/png","image/jpeg","image/gif","image/webp","image/bmp"],options:{terrain:{tesselator:"auto",bounds:void 0,meshMaxError:10,elevationDecoder:{rScaler:1,gScaler:0,bScaler:0,offset:0},skirtHeight:void 0}}},S={dataType:null,batchType:null,name:"Quantized Mesh",id:"quantized-mesh",module:"terrain",version:I,worker:!0,extensions:["terrain"],mimeTypes:["application/vnd.quantized-mesh"],options:{"quantized-mesh":{bounds:[0,0,1,1],skirtHeight:null}}},y={...P,parse:w};async function w(e,s,i){const n={...s,mimeType:"application/x.image",image:{...s?.image,type:"data"}};return f(await t(e,[],n,i),{...y.options.terrain,...s?.terrain})}const b={...S,parseSync:(e,t)=>g(e,t?.["quantized-mesh"]),parse:async(e,t)=>g(e,t?.["quantized-mesh"])};export{b as QuantizedMeshLoader,S as QuantizedMeshWorkerLoader,y as TerrainLoader,P as TerrainWorkerLoader,w as parseTerrain};export default null;
