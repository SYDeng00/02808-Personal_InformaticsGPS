/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@loaders.gl/gis@4.2.0/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{getTableLength as e,getTableRowAsObject as t}from"../schema@4.2.0/_esm.js";import{earcut as n,getPolygonSignedArea as o}from"../../@math.gl/polygon@4.0.1/_esm.js";const i={$schema:"http://json-schema.org/draft-07/schema#",title:"GeoParquet",description:"Parquet metadata included in the geo field.",type:"object",required:["version","primary_column","columns"],properties:{version:{type:"string",const:"1.0.0-beta.1"},primary_column:{type:"string",minLength:1},columns:{type:"object",minProperties:1,patternProperties:{".+":{type:"object",required:["encoding","geometry_types"],properties:{encoding:{type:"string",const:"WKB"},geometry_types:{type:"array",uniqueItems:!0,items:{type:"string",pattern:"^(GeometryCollection|(Multi)?(Point|LineString|Polygon))( Z)?$"}},crs:{oneOf:[{$ref:"https://proj.org/schemas/v0.5/projjson.schema.json"},{type:"null"}]},edges:{type:"string",enum:["planar","spherical"]},orientation:{type:"string",const:"counterclockwise"},bbox:{type:"array",items:{type:"number"},oneOf:[{description:"2D bbox consisting of (xmin, ymin, xmax, ymax)",minItems:4,maxItems:4},{description:"3D bbox consisting of (xmin, ymin, zmin, xmax, ymax, zmax)",minItems:6,maxItems:6}]},epoch:{type:"number"}}}},additionalProperties:!1}}};function r(e){const t=u(e,"geo");if(!t)return null;for(const e of Object.values(t.columns||{}))e.encoding&&(e.encoding=e.encoding.toLowerCase());return t}function s(e,t){const n=JSON.stringify(t);e.metadata.geo=n}function a(e){const t=r(e);if(!t)return;const{version:n,primary_column:o,columns:i}=t;n&&(e.metadata["geo.version"]=n),o&&(e.metadata["geo.primary_column"]=o),e.metadata["geo.columns"]=Object.keys(i||{}).join("");for(const[t,n]of Object.entries(i||{})){const i=e.fields.find((e=>e.name===t));i&&(i.name===o&&c(i,"geo.primary_field","true"),l(i,n))}}function l(e,t){for(const[n,o]of Object.entries(t||{}))switch(n){case"geometry_types":c(e,`geo.${n}`,o.join(","));break;case"bbox":c(e,`geo.crs.${n}`,JSON.stringify(o));break;case"crs":for(const[t,n]of Object.entries(o||{}))if("id"===t){c(e,`geo.crs.${t}`,"object"==typeof n?`${n?.authority}:${n?.code}`:JSON.stringify(n))}else c(e,`geo.crs.${t}`,"string"==typeof n?n:JSON.stringify(n));break;default:c(e,`geo.${n}`,"string"==typeof o?o:JSON.stringify(o))}}function c(e,t,n){e.metadata=e.metadata||{},e.metadata[t]=n}function u(e,t){const n=e.metadata[t];if(!n)return null;try{const e=JSON.parse(n);return e&&"object"==typeof e?e:null}catch{return null}}function p(e,t){const n=u(e,t);for(const[o,i]of Object.entries(n||{}))e.metadata[`${t}.${o}`]="string"==typeof i?i:JSON.stringify(i)}const g=["geoarrow.multipolygon","geoarrow.polygon","geoarrow.multilinestring","geoarrow.linestring","geoarrow.multipoint","geoarrow.point","geoarrow.wkb","geoarrow.wkt"],f="ARROW:extension:name",y="ARROW:extension:metadata";function d(e){const t={};for(const n of e.fields){const e=m(n);e&&(t[n.name]=e)}return t}function m(e){let t=null,n=e.metadata?.[f];n&&(n=n.toLowerCase(),"wkb"===n&&(n="geoarrow.wkb"),"wkt"===n&&(n="geoarrow.wkt"),g.includes(n)?(t=t||{},t.encoding=n):console.warn(`Invalid GeoArrow encoding: ${n}`));const o=e.metadata?.[y];if(o)try{t=JSON.parse(o)}catch(e){console.warn("Failed to parse GeoArrow metadata",e)}return t||null}function h(n,o,i){const s=r(o),a=s?.primary_column;if(!a)throw new Error("no geometry column");const l=s.columns[a],c=[],u=e(n);for(let e=0;e<u;e++){const o=t(n,e),r=P(o[a],l,i);delete o[a];const s={type:"Feature",geometry:r,properties:o};c.push(s)}return{shape:"geojson-table",schema:o,type:"FeatureCollection",features:c}}function P(e,t,n){if("wkt"===t.encoding){const t=n.find((e=>"wkt"===e.id));return t?.parseTextSync?.(e)||null}{const t=n.find((e=>"wkb"===e.id)),o=ArrayBuffer.isView(e)?e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength):e,i=t?.parseSync?.(o,{wkb:{shape:"geojson-geometry"}});return i}}function b(e,t,n){const o=function(e){const t={};for(const n of e)if(n.properties)for(const e in n.properties){const o=n.properties[e];t[e]=x(o,t[e])}return t}(e),i=Object.keys(o).filter((e=>o[e]!==Array));return function(e,t,n){const{pointPositionsCount:o,pointFeaturesCount:i,linePositionsCount:r,linePathsCount:s,lineFeaturesCount:a,polygonPositionsCount:l,polygonObjectsCount:c,polygonRingsCount:u,polygonFeaturesCount:p,propArrayTypes:g,coordLength:f}=t,{numericPropKeys:y=[],PositionDataType:d=Float32Array,triangulate:m=!0}=n,h=e[0]&&"id"in e[0],P=e.length>65535?Uint32Array:Uint16Array,b={type:"Point",positions:new d(o*f),globalFeatureIds:new P(o),featureIds:i>65535?new Uint32Array(o):new Uint16Array(o),numericProps:{},properties:[],fields:[]},F={type:"LineString",pathIndices:r>65535?new Uint32Array(s+1):new Uint16Array(s+1),positions:new d(r*f),globalFeatureIds:new P(r),featureIds:a>65535?new Uint32Array(r):new Uint16Array(r),numericProps:{},properties:[],fields:[]},k={type:"Polygon",polygonIndices:l>65535?new Uint32Array(c+1):new Uint16Array(c+1),primitivePolygonIndices:l>65535?new Uint32Array(u+1):new Uint16Array(u+1),positions:new d(l*f),globalFeatureIds:new P(l),featureIds:p>65535?new Uint32Array(l):new Uint16Array(l),numericProps:{},properties:[],fields:[]};m&&(k.triangles=[]);for(const e of[b,F,k])for(const t of y){const n=g[t];e.numericProps[t]=new n(e.positions.length/f)}F.pathIndices[s]=r,k.polygonIndices[c]=l,k.primitivePolygonIndices[u]=l;const x={pointPosition:0,pointFeature:0,linePosition:0,linePath:0,lineFeature:0,polygonPosition:0,polygonObject:0,polygonRing:0,polygonFeature:0,feature:0};for(const t of e){const e=t.geometry,n=t.properties||{};switch(e.type){case"Point":w(e,b,x,f,n),b.properties.push(j(n,y)),h&&b.fields.push({id:t.id}),x.pointFeature++;break;case"LineString":I(e,F,x,f,n),F.properties.push(j(n,y)),h&&F.fields.push({id:t.id}),x.lineFeature++;break;case"Polygon":v(e,k,x,f,n),k.properties.push(j(n,y)),h&&k.fields.push({id:t.id}),x.polygonFeature++;break;default:throw new Error("Invalid geometry type")}x.feature++}return function(e,t,n,o){const i={shape:"binary-feature-collection",points:{...e,positions:{value:e.positions,size:o},globalFeatureIds:{value:e.globalFeatureIds,size:1},featureIds:{value:e.featureIds,size:1},numericProps:A(e.numericProps,1)},lines:{...t,positions:{value:t.positions,size:o},pathIndices:{value:t.pathIndices,size:1},globalFeatureIds:{value:t.globalFeatureIds,size:1},featureIds:{value:t.featureIds,size:1},numericProps:A(t.numericProps,1)},polygons:{...n,positions:{value:n.positions,size:o},polygonIndices:{value:n.polygonIndices,size:1},primitivePolygonIndices:{value:n.primitivePolygonIndices,size:1},globalFeatureIds:{value:n.globalFeatureIds,size:1},featureIds:{value:n.featureIds,size:1},numericProps:A(n.numericProps,1)}};i.polygons&&n.triangles&&(i.polygons.triangles={value:new Uint32Array(n.triangles),size:1});return i}(b,F,k,f)}(e,{propArrayTypes:o,...t},{numericPropKeys:n&&n.numericPropKeys||i,PositionDataType:n?n.PositionDataType:Float32Array,triangulate:!n||n.triangulate})}function w(e,t,n,o,i){t.positions.set(e.data,n.pointPosition*o);const r=e.data.length/o;k(t,i,n.pointPosition,r),t.globalFeatureIds.fill(n.feature,n.pointPosition,n.pointPosition+r),t.featureIds.fill(n.pointFeature,n.pointPosition,n.pointPosition+r),n.pointPosition+=r}function I(e,t,n,o,i){t.positions.set(e.data,n.linePosition*o);const r=e.data.length/o;k(t,i,n.linePosition,r),t.globalFeatureIds.fill(n.feature,n.linePosition,n.linePosition+r),t.featureIds.fill(n.lineFeature,n.linePosition,n.linePosition+r);for(let i=0,r=e.indices.length;i<r;++i){const s=e.indices[i],a=i===r-1?e.data.length:e.indices[i+1];t.pathIndices[n.linePath++]=n.linePosition,n.linePosition+=(a-s)/o}}function v(e,t,n,o,i){t.positions.set(e.data,n.polygonPosition*o);const r=e.data.length/o;k(t,i,n.polygonPosition,r),t.globalFeatureIds.fill(n.feature,n.polygonPosition,n.polygonPosition+r),t.featureIds.fill(n.polygonFeature,n.polygonPosition,n.polygonPosition+r);for(let i=0,r=e.indices.length;i<r;++i){const r=n.polygonPosition;t.polygonIndices[n.polygonObject++]=r;const s=e.areas[i],a=e.indices[i],l=e.indices[i+1];for(let i=0,r=a.length;i<r;++i){const s=a[i],c=i===r-1?void 0===l?e.data.length:l[0]:a[i+1];t.primitivePolygonIndices[n.polygonRing++]=n.polygonPosition,n.polygonPosition+=(c-s)/o}F(t,s,a,{startPosition:r,endPosition:n.polygonPosition,coordLength:o})}}function F(e,t,o,{startPosition:i,endPosition:r,coordLength:s}){if(!e.triangles)return;const a=i*s,l=r*s,c=e.positions.subarray(a,l),u=o[0],p=o.slice(1).map((e=>(e-u)/s)),g=n(c,p,s,t);for(let t=0,n=g.length;t<n;++t)e.triangles.push(i+g[t])}function A(e,t){const n={};for(const o in e)n[o]={value:e[o],size:t};return n}function k(e,t,n,o){for(const i in e.numericProps)if(i in t){const r=t[i];e.numericProps[i].fill(r,n,n+o)}}function j(e,t){const n={};for(const o in e)t.includes(o)||(n[o]=e[o]);return n}function x(e,t){return t!==Array&&Number.isFinite(e)?t===Float64Array||Math.fround(e)!==e?Float64Array:Float32Array:Array}function L(e,t={coordLength:2,fixRingWinding:!0}){return e.map((e=>function(e,t){const{geometry:n}=e;if("GeometryCollection"===n.type)throw new Error("GeometryCollection type not supported");const o=[],i=[];let r,s;switch(n.type){case"Point":s="Point",O(n.coordinates,o,i,t);break;case"MultiPoint":s="Point",n.coordinates.map((e=>O(e,o,i,t)));break;case"LineString":s="LineString",C(n.coordinates,o,i,t);break;case"MultiLineString":s="LineString",n.coordinates.map((e=>C(e,o,i,t)));break;case"Polygon":s="Polygon",r=[],S(n.coordinates,o,i,r,t);break;case"MultiPolygon":s="Polygon",r=[],n.coordinates.map((e=>S(e,o,i,r,t)));break;default:throw new Error(`Unknown type: ${s}`)}return{...e,geometry:{type:s,indices:i,data:o,areas:r}}}(e,t)))}function O(e,t,n,o){n.push(t.length),t.push(...e);for(let n=e.length;n<o.coordLength;n++)t.push(0)}function C(e,t,n,o){n.push(t.length);for(const n of e){t.push(...n);for(let e=n.length;e<o.coordLength;e++)t.push(0)}}function S(e,t,n,i,r){let s=0;const a=[],l=[];for(const n of e){const e=n.map((e=>e.slice(0,2)));let i=o(e.flat());const c=i<0;r.fixRingWinding&&(0===s&&!c||s>0&&c)&&(n.reverse(),i=-i),a.push(i),C(n,t,l,r),s++}s>0&&(i.push(a),n.push(l))}function z(e,t={fixRingWinding:!0,triangulate:!0}){const n=function(e){let t=0,n=0,o=0,i=0,r=0,s=0,a=0,l=0,c=0;const u=new Set;for(const p of e){const e=p.geometry;switch(e.type){case"Point":n++,t++,u.add(e.coordinates.length);break;case"MultiPoint":n++,t+=e.coordinates.length;for(const t of e.coordinates)u.add(t.length);break;case"LineString":r++,o+=e.coordinates.length,i++;for(const t of e.coordinates)u.add(t.length);break;case"MultiLineString":r++;for(const t of e.coordinates){o+=t.length,i++;for(const e of t)u.add(e.length)}break;case"Polygon":c++,a++,l+=e.coordinates.length;const p=e.coordinates.flat();s+=p.length;for(const e of p)u.add(e.length);break;case"MultiPolygon":c++;for(const t of e.coordinates){a++,l+=t.length;const e=t.flat();s+=e.length;for(const t of e)u.add(t.length)}break;default:throw new Error(`Unsupported geometry type: ${e.type}`)}}return{coordLength:u.size>0?Math.max(...u):2,pointPositionsCount:t,pointFeaturesCount:n,linePositionsCount:o,linePathsCount:i,lineFeaturesCount:r,polygonPositionsCount:s,polygonObjectsCount:a,polygonRingsCount:l,polygonFeaturesCount:c}}(e),o=n.coordLength,{fixRingWinding:i}=t;return b(L(e,{coordLength:o,fixRingWinding:i}),n,{numericPropKeys:t.numericPropKeys,PositionDataType:t.PositionDataType||Float32Array,triangulate:t.triangulate})}function U(e,t){const n=t?.globalFeatureId;return void 0!==n?function(e,t){const n=R(e);for(const e of n){let n=0,o=e.featureIds.value[0];for(let i=0;i<e.featureIds.value.length;i++){const r=e.featureIds.value[i];if(r!==o){if(t===e.globalFeatureIds.value[n])return M(e,n,i);n=i,o=r}}if(t===e.globalFeatureIds.value[n])return M(e,n,e.featureIds.value.length)}throw new Error(`featureId:${t} not found`)}(e,n):function(e,t){const n=R(e);return function(e){const t=[];for(const n of e){if(0===n.featureIds.value.length)continue;let e=0,o=n.featureIds.value[0];for(let i=0;i<n.featureIds.value.length;i++){const r=n.featureIds.value[i];r!==o&&(t.push(M(n,e,i)),e=i,o=r)}t.push(M(n,e,n.featureIds.value.length))}return t}(n)}(e,t?.type)}function $(e,t,n){switch(e.type){case"Point":return function(e,t,n){const{positions:o}=e,i=_(o,t,n);if(i.length>1)return{type:"MultiPoint",coordinates:i};return{type:"Point",coordinates:i[0]}}(e,t,n);case"LineString":return function(e,t=-1/0,n=1/0){const{positions:o}=e,i=e.pathIndices.value.filter((e=>e>=t&&e<=n));if(!(i.length>2)){return{type:"LineString",coordinates:_(o,i[0],i[1])}}const r=[];for(let e=0;e<i.length-1;e++){const t=_(o,i[e],i[e+1]);r.push(t)}return{type:"MultiLineString",coordinates:r}}(e,t,n);case"Polygon":return N(e,t,n);default:const o=e;throw new Error(`Unsupported geometry type: ${o?.type}`)}}function R(e,t){const n=[];return e.points&&(e.points.type="Point",n.push(e.points)),e.lines&&(e.lines.type="LineString",n.push(e.lines)),e.polygons&&(e.polygons.type="Polygon",n.push(e.polygons)),n}function M(e,t,n){const o=$(e,t,n),i=function(e,t=0,n){const o=Object.assign({},e.properties[e.featureIds.value[t]]);for(const n in e.numericProps)o[n]=e.numericProps[n].value[t];return o}(e,t),r=function(e,t=0,n){return e.fields&&e.fields[e.featureIds.value[t]]}(e,t);return{type:"Feature",geometry:o,properties:i,...r}}function N(e,t=-1/0,n=1/0){const{positions:o}=e,i=e.polygonIndices.value.filter((e=>e>=t&&e<=n)),r=e.primitivePolygonIndices.value.filter((e=>e>=t&&e<=n));if(!(i.length>2)){const e=[];for(let t=0;t<r.length-1;t++){const n=_(o,r[t],r[t+1]);e.push(n)}return{type:"Polygon",coordinates:e}}const s=[];for(let t=0;t<i.length-1;t++){const n=N(e,i[t],i[t+1]).coordinates;s.push(n)}return{type:"MultiPolygon",coordinates:s}}function _(e,t,n){t=t||0,n=n||e.value.length/e.size;const o=[];for(let i=t;i<n;i++){const t=Array();for(let n=i*e.size;n<(i+1)*e.size;n++)t.push(Number(e.value[n]));o.push(t)}return o}function J(e,t){return e.points&&T(e.points,t),e.lines&&T(e.lines,t),e.polygons&&T(e.polygons,t),e}function T(e,t){const{positions:n}=e;for(let e=0;e<n.value.length;e+=n.size){const o=t(Array.from(n.value.subarray(e,e+n.size)));n.value.set(o,e)}}function W(e,t){for(const n of e)n.geometry.coordinates=D(n.geometry.coordinates,t);return e}function D(e,t){return function(e){return Array.isArray(e)&&Number.isFinite(e[0])&&Number.isFinite(e[1])}(e)?t(e):e.map((e=>D(e,t)))}export{i as GEOPARQUET_METADATA_JSON_SCHEMA,U as binaryToGeojson,$ as binaryToGeometry,h as convertWKBTableToGeoJSON,b as flatGeojsonToBinary,z as geojsonToBinary,L as geojsonToFlatGeojson,r as getGeoMetadata,d as getGeometryColumnsFromSchema,s as setGeoMetadata,J as transformBinaryCoords,W as transformGeoJsonCoords,a as unpackGeoMetadata,p as unpackJSONStringMetadata};export default null;
