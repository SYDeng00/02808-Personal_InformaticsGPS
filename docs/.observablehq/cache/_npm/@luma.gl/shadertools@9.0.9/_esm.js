/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@luma.gl/shadertools@9.0.9/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{log as e}from"../core@9.0.9/_esm.js";import{Matrix4 as n}from"../../@math.gl/core@4.0.1/_esm.js";const t=e=>`${e}`;function o(e,n){if(!e)throw new Error(n||"shadertools: assertion failed.")}const r={number:{type:"number",validate:(e,n)=>Number.isFinite(e)&&"object"==typeof n&&(void 0===n.max||e<=n.max)&&(void 0===n.min||e>=n.min)},array:{type:"array",validate:(e,n)=>Array.isArray(e)||ArrayBuffer.isView(e)}};function i(e){let n=s(e);if("object"!==n)return{value:e,...r[n],type:n};if("object"==typeof e)return e?void 0!==e.type?{...e,...r[e.type],type:e.type}:void 0===e.value?{type:"object",value:e}:(n=s(e.value),{...e,...r[n],type:n}):{type:"object",value:null};throw new Error("props")}function s(e){return Array.isArray(e)||ArrayBuffer.isView(e)?"array":typeof e}const a={vertex:"#ifdef MODULE_LOGDEPTH\nlogdepth_adjustPosition(gl_Position);\n#endif\n",fragment:"#ifdef MODULE_MATERIAL\ngl_FragColor = material_filterColor(gl_FragColor);\n#endif\n#ifdef MODULE_LIGHTING\ngl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n#ifdef MODULE_FOG\ngl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n#ifdef MODULE_PICKING\ngl_FragColor = picking_filterHighlightColor(gl_FragColor);\ngl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n#ifdef MODULE_LOGDEPTH\nlogdepth_setFragDepth();\n#endif\n"},l=/void\s+main\s*\([^)]*\)\s*\{\n?/,c=/}\n?[^{}]*$/,u=[],_="__LUMA_INJECT_DECLARATIONS__";function f(e){const n=e.slice(0,2);switch(n){case"vs":return"vertex";case"fs":return"fragment";default:throw new Error(n)}}function d(e,n,t,o=!1){const r="vertex"===n;for(const n in t){const o=t[n];o.sort(((e,n)=>e.order-n.order)),u.length=o.length;for(let e=0,n=o.length;e<n;++e)u[e]=o[e].injection;const i=`${u.join("\n")}\n`;switch(n){case"vs:#decl":r&&(e=e.replace(_,i));break;case"vs:#main-start":r&&(e=e.replace(l,(e=>e+i)));break;case"vs:#main-end":r&&(e=e.replace(c,(e=>i+e)));break;case"fs:#decl":r||(e=e.replace(_,i));break;case"fs:#main-start":r||(e=e.replace(l,(e=>e+i)));break;case"fs:#main-end":r||(e=e.replace(c,(e=>i+e)));break;default:e=e.replace(n,(e=>e+i))}}return e=e.replace(_,""),o&&(e=e.replace(/\}\s*$/,(e=>e+a[n]))),e}function p(e){const n={};return o(Array.isArray(e)&&e.length>1),e.forEach((e=>{for(const t in e)n[t]=n[t]?`${n[t]}\n${e[t]}`:e[t]})),n}let h=1;class m{name;vs;fs;getModuleUniforms;dependencies;deprecations;defines;injections;uniforms={};uniformTypes={};static instantiateModules(e){return e.map((e=>{if(e instanceof m)return e;o("string"!=typeof e,`Shader module use by name is deprecated. Import shader module '${JSON.stringify(e)}' and use it directly.`),e.name||(console.warn("shader module has no name"),e.name="shader-module-"+h++);const n=new m(e);return n.dependencies=m.instantiateModules(e.dependencies||[]),n}))}constructor(e){const{name:n,vs:t,fs:r,dependencies:s=[],uniformPropTypes:a={},getUniforms:l,deprecations:c=[],defines:u={},inject:_={}}=e;o("string"==typeof n),this.name=n,this.vs=t,this.fs=r,this.getModuleUniforms=l,this.dependencies=m.instantiateModules(s),this.deprecations=this._parseDeprecationDefinitions(c),this.defines=u,this.injections=function(e){const n={vertex:{},fragment:{}};for(const t in e){let o=e[t];"string"==typeof o&&(o={order:0,injection:o}),n[f(t)][t]=o}return n}(_),a&&(this.uniforms=function(e){const n={};for(const[t,o]of Object.entries(e))n[t]=i(o);return n}(a))}getModuleSource(e){let n;switch(e){case"vertex":n=this.vs||"";break;case"fragment":n=this.fs||"";break;default:o(!1)}const t=this.name.toUpperCase().replace(/[^0-9a-z]/gi,"_");return`// ----- MODULE ${this.name} ---------------\n\n#define MODULE_${t}\n${n}\n\n`}getUniforms(e,n){return this.getModuleUniforms?this.getModuleUniforms(e,n):function(e,n,t){const r={};for(const[i,s]of Object.entries(n))e&&i in e&&!s.private?(s.validate&&o(s.validate(e[i],s),`${t}: invalid ${i}`),r[i]=e[i]):r[i]=s.value;return r}(e,this.uniforms,this.name)}getDefines(){return this.defines}checkDeprecations(e,n){this.deprecations.forEach((t=>{t.regex?.test(e)&&(t.deprecated?n.deprecated(t.old,t.new)():n.removed(t.old,t.new)())}))}_parseDeprecationDefinitions(e){return e.forEach((e=>{if("function"===e.type)e.regex=new RegExp(`\\b${e.old}\\(`);else e.regex=new RegExp(`${e.type} ${e.old};`)})),e}_defaultGetUniforms(e={}){const n={},t=this.uniforms;for(const r in t){const i=t[r];r in e&&!i.private?(i.validate&&o(i.validate(e[r],i),`${this.name}: invalid ${r}`),n[r]=e[r]):n[r]=i.value}return n}}function g(e){if(e.source&&"webgpu"===e.platformInfo.type){return{...e,vs:void 0,fs:void 0}}if(!e.vs)throw new Error("no vertex shader");const n=v(e.platformInfo,e.vs);let t;return e.fs&&(t=v(e.platformInfo,e.fs)),{...e,vs:n,fs:t}}function v(e,n){if("string"==typeof n)return n;if("webgpu"===e.type){if(n?.wgsl)return n.wgsl;throw new Error("WebGPU does not support GLSL shaders")}if(n?.glsl)return n.glsl;throw new Error("WebGL does not support WGSL shaders")}function x(e){return function(e){const n={},t={};return b({modules:e,level:0,moduleMap:n,moduleDepth:t}),Object.keys(t).sort(((e,n)=>t[n]-t[e])).map((e=>n[e]))}(m.instantiateModules(e))}function b(e){const{modules:n,level:t,moduleMap:o,moduleDepth:r}=e;if(t>=5)throw new Error("Possible loop in shader dependency graph");for(const e of n)o[e.name]=e,(void 0===r[e.name]||r[e.name]<t)&&(r[e.name]=t);for(const e of n)e.dependencies&&b({modules:e.dependencies,level:t+1,moduleMap:o,moduleDepth:r})}const A=[[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,"#version 300 es\n"],[/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g,"textureLod("],[/\btexture(2D|2DProj|Cube)(EXT)?\(/g,"texture("]],y=[...A,[k("attribute"),"in $1"],[k("varying"),"out $1"]],P=[...A,[k("varying"),"in $1"]];function w(e,n){for(const[t,o]of n)e=e.replace(t,o);return e}function k(e){return new RegExp(`\\b${e}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`,"g")}function L(e,n){let t="";for(const o in e){const r=e[o];if(t+=`void ${r.signature} {\n`,r.header&&(t+=`  ${r.header}`),n[o]){const e=n[o];e.sort(((e,n)=>e.order-n.order));for(const n of e)t+=`  ${n.injection}\n`}r.footer&&(t+=`  ${r.footer}`),t+="}\n"}return t}function F(e){const n={vertex:{},fragment:{}};for(const t of e){let e,o;"string"!=typeof t?(e=t,o=e.hook):(e={},o=t),o=o.trim();const[r,i]=o.split(":"),s=o.replace(/\(.+/,""),a=Object.assign(e,{signature:i});switch(r){case"vs":n.vertex[s]=a;break;case"fs":n.fragment[s]=a;break;default:throw new Error(r)}}return n}function I(e,n){return{name:N(e,n),language:"glsl",version:T(e)}}function N(e,n="unnamed"){const t=/#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(e);return t?t[1]:n}function T(e){let n=100;const t=e.match(/[^\s]+/g);if(t&&t.length>=2&&"#version"===t[0]){const e=parseInt(t[1],10);Number.isFinite(e)&&(n=e)}if(100!==n&&300!==n)throw new Error(`Invalid GLSL version ${n}`);return n}const S=`\n\n${_}\n`,E="precision highp float;\n";function C(e){const{vs:n,fs:t}=e,o=x(e.modules||[]);return{vs:M(e.platformInfo,{...e,source:n,stage:"vertex",modules:o}),fs:M(e.platformInfo,{...e,source:t,stage:"fragment",modules:o}),getUniforms:R(o)}}function U(e,n){const{source:t,stage:r,modules:i,hookFunctions:s=[],inject:a={},log:l}=n;o("string"==typeof t,"shader source must be a string");const c=t;let u="";const _=F(s),f={},p={},h={};for(const e in a){const n="string"==typeof a[e]?{injection:a[e],order:0}:a[e],t=/^(v|f)s:(#)?([\w-]+)$/.exec(e);if(t){const o=t[2],r=t[3];o?"decl"===r?p[e]=[n]:h[e]=[n]:f[e]=[n]}else h[e]=[n]}const m="webgpu"!==e.type?i:[];for(const e of m){l&&e.checkDeprecations(c,l);u+=e.getModuleSource(r,"wgsl");const n=e.injections[r];for(const e in n){const t=/^(v|f)s:#([\w-]+)$/.exec(e);if(t){const o="decl"===t[2]?p:h;o[e]=o[e]||[],o[e].push(n[e])}else f[e]=f[e]||[],f[e].push(n[e])}}return u+=S,u=d(u,r,p),u+=L(_[r],f),u+=c,u=d(u,r,h),u}function M(e,n){const{id:t,source:r,stage:i,language:s="glsl",modules:a,defines:l={},hookFunctions:c=[],inject:u={},prologue:_=!0,log:f}=n;o("string"==typeof r,"shader source must be a string");const p="glsl"===s?I(r).version:-1,h=e.shaderLanguageVersion,m=100===p?"#version 100":"#version 300 es",g=r.split("\n").slice(1).join("\n"),v={};a.forEach((e=>{Object.assign(v,e.getDefines())})),Object.assign(v,l);let x="";switch(s){case"wgsl":break;case"glsl":x=_?`${m}\n\n// ----- PROLOGUE -------------------------\n${function(e){const{id:n,source:t,stage:o}=e,r=n&&-1===t.indexOf("SHADER_NAME");return r?`\n#define SHADER_NAME ${n}_${o}\n\n`:""}({id:t,source:r,stage:i})}\n#define SHADER_TYPE_${i.toUpperCase()}\n${function(e){switch(e?.gpu.toLowerCase()){case"apple":return"#define APPLE_GPU\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";case"nvidia":return"#define NVIDIA_GPU\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";case"intel":return"#define INTEL_GPU\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";case"amd":return"#define AMD_GPU\n";default:return"#define DEFAULT_GPU\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n"}}(e)}\n${"fragment"===i?E:""}\n\n// ----- APPLICATION DEFINES -------------------------\n\n${function(e={}){let n="";for(const t in e){const o=e[t];(o||Number.isFinite(o))&&(n+=`#define ${t.toUpperCase()} ${e[t]}\n`)}return n}(v)}\n\n`:`${m}\n`}const b=F(c),A={},k={},N={};for(const e in u){const n="string"==typeof u[e]?{injection:u[e],order:0}:u[e],t=/^(v|f)s:(#)?([\w-]+)$/.exec(e);if(t){const o=t[2],r=t[3];o?"decl"===r?k[e]=[n]:N[e]=[n]:A[e]=[n]}else N[e]=[n]}for(const e of a){f&&e.checkDeprecations(g,f);x+=e.getModuleSource(i);const n=e.injections[i];for(const e in n){const t=/^(v|f)s:#([\w-]+)$/.exec(e);if(t){const o="decl"===t[2]?k:N;o[e]=o[e]||[],o[e].push(n[e])}else A[e]=A[e]||[],A[e].push(n[e])}}return x+="// ----- MAIN SHADER SOURCE -------------------------",x+=S,x=d(x,i,k),x+=L(b[i],A),x+=g,x=d(x,i,N),"glsl"===s&&p!==h&&(x=function(e,n){if(300!==Number(e.match(/^#version[ \t]+(\d+)/m)?.[1]||100))throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");switch(n){case"vertex":return w(e,y);case"fragment":return w(e,P);default:throw new Error(n)}}(x,i)),x.trim()}function R(e){return function(n){const t={};for(const o of e){const e=o.getUniforms(n,t);Object.assign(t,e)}return t}}class O{static defaultShaderAssembler;_hookFunctions=[];_defaultModules=[];static getDefaultShaderAssembler(){return O.defaultShaderAssembler=O.defaultShaderAssembler||new O,O.defaultShaderAssembler}addDefaultModule(e){this._defaultModules.find((n=>n.name===("string"==typeof e?e:e.name)))||this._defaultModules.push(e)}removeDefaultModule(e){const n="string"==typeof e?e:e.name;this._defaultModules=this._defaultModules.filter((e=>e.name!==n))}addShaderHook(e,n){n&&(e=Object.assign(n,{hook:e})),this._hookFunctions.push(e)}assembleShader(e){const n=this._getModuleList(e.modules),t=this._hookFunctions,o=g(e),r=function(e){const n=x(e.modules||[]);return{source:U(e.platformInfo,{...e,source:e.source,stage:"vertex",modules:n}),getUniforms:R(n)}}({platformInfo:e.platformInfo,...o,modules:n,hookFunctions:t});return{...r,modules:n}}assembleShaderPair(e){const n=g(e),t=this._getModuleList(e.modules),o=this._hookFunctions,{platformInfo:r}=e;return{..."wgsl"===e.platformInfo.shaderLanguage?function(e){const n=x(e.modules||[]);return{vs:U(e.platformInfo,{...e,source:e.vs,stage:"vertex",modules:n}),fs:U(e.platformInfo,{...e,source:e.fs,stage:"fragment",modules:n}),getUniforms:R(n)}}({platformInfo:r,...n,modules:t,hookFunctions:o}):C({platformInfo:r,...n,modules:t,hookFunctions:o}),modules:t}}_getModuleList(e=[]){const n=new Array(this._defaultModules.length+e.length),t={};let o=0;for(let e=0,r=this._defaultModules.length;e<r;++e){const r=this._defaultModules[e],i=r.name;n[o++]=r,t[i]=!0}for(let r=0,i=e.length;r<i;++r){const i=e[r],s=i.name;t[s]||(n[o++]=i,t[s]=!0)}return n.length=o,m.instantiateModules(n)}}function X(e){if(!e.normalized&&(e.normalized=!0,e.uniformPropTypes&&!e.getUniforms)){const n=new m(e);e.getUniforms=n.getUniforms.bind(n)}return e}function z(e,n){n=Array.isArray(n)?n:[n];const t=e.replace(/^\s+/,"").split(/\s+/),[o,r,i]=t;if(!n.includes(o)||!r||!i)return null;return{qualifier:o,type:r,name:i.split(";")[0]}}function B(e){const{input:n,inputChannels:t,output:o}=e||{};if(!n)return"#version 300 es\nout vec4 transform_output;\nvoid main() {\ntransform_output = vec4(0);\n}";if(!t)throw new Error("inputChannels");return`#version 300 es\nin ${function(e){switch(e){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4";default:throw new Error(`invalid channels: ${e}`)}}(t)} ${n};\nout vec4 ${o};\nvoid main() {\n  ${o} = ${Y(n,t)};\n}`}function Q(e){switch(e){case"float":return"x";case"vec2":return"xy";case"vec3":return"xyz";case"vec4":return"xyzw";default:throw new Error(e)}}function D(e){switch(e){case"float":return 1;case"vec2":return 2;case"vec3":return 3;case"vec4":return 4;default:throw new Error(e)}}function Y(e,n){switch(n){case 1:return`vec4(${e}, 0.0, 0.0, 1.0)`;case 2:return`vec4(${e}, 0.0, 1.0)`;case 3:return`vec4(${e}, 1.0)`;case 4:return e;default:throw new Error(`invalid channels: ${n}`)}}function H(e){return"string"==typeof e?e.charAt(0).toUpperCase()+e.slice(1):e}function V(e,n){return function(e,n){const t=[];switch(n.uniforms){case"scoped-interface-blocks":case"unscoped-interface-blocks":t.push(`uniform ${H(e.name)} {`)}for(const[o,r]of Object.entries(e.uniformTypes||{})){const i=W(r);switch(n.uniforms){case"scoped-interface-blocks":t.push(`  ${i} ${o};`);break;case"unscoped-interface-blocks":t.push(`  ${i} ${e.name}_${o};`);break;case"uniforms":t.push(`uniform ${i} ${e.name}_${o};`)}}switch(n.uniforms){case"scoped-interface-blocks":t.push(`} ${e.name};`);break;case"unscoped-interface-blocks":t.push("};")}return t.push(""),t.join("\n")}(e,n)}function W(e){return{f32:"float",i32:"int",u32:"uint","vec2<f32>":"vec2","vec3<f32>":"vec3","vec4<f32>":"vec4","vec2<i32>":"ivec2","vec3<i32>":"ivec3","vec4<i32>":"ivec4","vec2<u32>":"uvec2","vec3<u32>":"uvec3","vec4<u32>":"uvec4","mat2x2<f32>":"mat2","mat2x3<f32>":"mat2x3","mat2x4<f32>":"mat2x4","mat3x2<f32>":"mat3x2","mat3x3<f32>":"mat3","mat3x4<f32>":"mat3x4","mat4x2<f32>":"mat4x2","mat4x3<f32>":"mat4x3","mat4x4<f32>":"mat4"}[e]}function G(e,n){return function(e,n){const t=[];t.push(`struct ${H(e.name)} {`);for(const[n,o]of Object.entries(e?.uniformTypes||{})){const e=o;t.push(`  ${n} : ${e};`)}return t.push("};"),t.push(`var<uniform> ${e.name} : ${H(e.name)};`),t.join("\n")}(e)}function q(e,n){switch(n.shaderLanguage){case"glsl":return V(e,n);case"wgsl":return G(e)}}class j{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}}class ${constructor(){}get isAstNode(){return!0}get astNodeType(){return""}evaluate(e){throw new Error("Cannot evaluate node")}evaluateString(e){return this.evaluate(e).toString()}}class K extends ${constructor(){super()}}class Z extends K{constructor(e,n,t,o){super(),this.name=e,this.args=n,this.returnType=t,this.body=o}get astNodeType(){return"function"}}class J extends K{constructor(e){super(),this.expression=e}get astNodeType(){return"staticAssert"}}class ee extends K{constructor(e,n){super(),this.condition=e,this.body=n}get astNodeType(){return"while"}}class ne extends K{constructor(e){super(),this.body=e}get astNodeType(){return"continuing"}}class te extends K{constructor(e,n,t,o){super(),this.init=e,this.condition=n,this.increment=t,this.body=o}get astNodeType(){return"for"}}class oe extends K{constructor(e,n,t,o,r){super(),this.name=e,this.type=n,this.storage=t,this.access=o,this.value=r}get astNodeType(){return"var"}}class re extends K{constructor(e,n,t){super(),this.name=e,this.type=n,this.value=t}get astNodeType(){return"override"}}class ie extends K{constructor(e,n,t,o,r){super(),this.name=e,this.type=n,this.storage=t,this.access=o,this.value=r}get astNodeType(){return"let"}}class se extends K{constructor(e,n,t,o,r){super(),this.name=e,this.type=n,this.storage=t,this.access=o,this.value=r}get astNodeType(){return"const"}evaluate(e){return this.value.evaluate(e)}}var ae,le,ce,ue,_e;!function(e){e.increment="++",e.decrement="--"}(ae||(ae={})),function(e){e.parse=function(n){const t=n;if("parse"==t)throw new Error("Invalid value for IncrementOperator");return e[t]}}(ae||(ae={}));class fe extends K{constructor(e,n){super(),this.operator=e,this.variable=n}get astNodeType(){return"increment"}}!function(e){e.assign="=",e.addAssign="+=",e.subtractAssin="-=",e.multiplyAssign="*=",e.divideAssign="/=",e.moduloAssign="%=",e.andAssign="&=",e.orAssign="|=",e.xorAssign="^=",e.shiftLeftAssign="<<=",e.shiftRightAssign=">>="}(le||(le={})),function(e){e.parse=function(n){const t=n;if("parse"==t)throw new Error("Invalid value for AssignOperator");return e[t]}}(le||(le={}));class de extends K{constructor(e,n,t){super(),this.operator=e,this.variable=n,this.value=t}get astNodeType(){return"assign"}}class pe extends K{constructor(e,n){super(),this.name=e,this.args=n}get astNodeType(){return"call"}}class he extends K{constructor(e,n){super(),this.body=e,this.continuing=n}get astNodeType(){return"loop"}}class me extends K{constructor(e,n){super(),this.condition=e,this.body=n}get astNodeType(){return"body"}}class ge extends K{constructor(e,n,t,o){super(),this.condition=e,this.body=n,this.elseif=t,this.else=o}get astNodeType(){return"if"}}class ve extends K{constructor(e){super(),this.value=e}get astNodeType(){return"return"}}class xe extends K{constructor(e){super(),this.name=e}get astNodeType(){return"enable"}}class be extends K{constructor(e,n){super(),this.name=e,this.type=n}get astNodeType(){return"alias"}}class Ae extends K{constructor(){super()}get astNodeType(){return"discard"}}class ye extends K{constructor(){super()}get astNodeType(){return"break"}}class Pe extends K{constructor(){super()}get astNodeType(){return"continue"}}class we extends K{constructor(e){super(),this.name=e}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}}class ke extends we{constructor(e,n){super(e),this.members=n}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(e){for(let n=0;n<this.members.length;n++)if(this.members[n].name==e)return n;return-1}}class Le extends we{constructor(e,n,t){super(e),this.format=n,this.access=t}get astNodeType(){return"template"}}class Fe extends we{constructor(e,n,t,o){super(e),this.storage=n,this.type=t,this.access=o}get astNodeType(){return"pointer"}}class Ie extends we{constructor(e,n,t,o){super(e),this.attributes=n,this.format=t,this.count=o}get astNodeType(){return"array"}get isArray(){return!0}}class Ne extends we{constructor(e,n,t){super(e),this.format=n,this.access=t}get astNodeType(){return"sampler"}}class Te extends ${constructor(){super()}}class Se extends Te{constructor(e){super(),this.value=e}get astNodeType(){return"stringExpr"}toString(){return this.value}evaluateString(){return this.value}}class Ee extends Te{constructor(e,n){super(),this.type=e,this.args=n}get astNodeType(){return"createExpr"}}class Ce extends Te{constructor(e,n){super(),this.name=e,this.args=n}get astNodeType(){return"callExpr"}evaluate(e){switch(this.name){case"abs":return Math.abs(this.args[0].evaluate(e));case"acos":return Math.acos(this.args[0].evaluate(e));case"acosh":return Math.acosh(this.args[0].evaluate(e));case"asin":return Math.asin(this.args[0].evaluate(e));case"asinh":return Math.asinh(this.args[0].evaluate(e));case"atan":return Math.atan(this.args[0].evaluate(e));case"atan2":return Math.atan2(this.args[0].evaluate(e),this.args[1].evaluate(e));case"atanh":return Math.atanh(this.args[0].evaluate(e));case"ceil":return Math.ceil(this.args[0].evaluate(e));case"clamp":return Math.min(Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e)),this.args[2].evaluate(e));case"cos":return Math.cos(this.args[0].evaluate(e));case"degrees":return 180*this.args[0].evaluate(e)/Math.PI;case"distance":return Math.sqrt(Math.pow(this.args[0].evaluate(e)-this.args[1].evaluate(e),2));case"dot":case"exp":return Math.exp(this.args[0].evaluate(e));case"exp2":return Math.pow(2,this.args[0].evaluate(e));case"floor":return Math.floor(this.args[0].evaluate(e));case"fma":return this.args[0].evaluate(e)*this.args[1].evaluate(e)+this.args[2].evaluate(e);case"fract":case"modf":return this.args[0].evaluate(e)-Math.floor(this.args[0].evaluate(e));case"inverseSqrt":return 1/Math.sqrt(this.args[0].evaluate(e));case"log":return Math.log(this.args[0].evaluate(e));case"log2":return Math.log2(this.args[0].evaluate(e));case"max":return Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e));case"min":return Math.min(this.args[0].evaluate(e),this.args[1].evaluate(e));case"mix":return this.args[0].evaluate(e)*(1-this.args[2].evaluate(e))+this.args[1].evaluate(e)*this.args[2].evaluate(e);case"pow":return Math.pow(this.args[0].evaluate(e),this.args[1].evaluate(e));case"radians":return this.args[0].evaluate(e)*Math.PI/180;case"round":return Math.round(this.args[0].evaluate(e));case"sign":return Math.sign(this.args[0].evaluate(e));case"sin":return Math.sin(this.args[0].evaluate(e));case"sinh":return Math.sinh(this.args[0].evaluate(e));case"saturate":return Math.min(Math.max(this.args[0].evaluate(e),0),1);case"smoothstep":return this.args[0].evaluate(e)*this.args[0].evaluate(e)*(3-2*this.args[0].evaluate(e));case"sqrt":return Math.sqrt(this.args[0].evaluate(e));case"step":return this.args[0].evaluate(e)<this.args[1].evaluate(e)?0:1;case"tan":return Math.tan(this.args[0].evaluate(e));case"tanh":return Math.tanh(this.args[0].evaluate(e));case"trunc":return Math.trunc(this.args[0].evaluate(e));default:throw new Error("Non const function: "+this.name)}}}class Ue extends Te{constructor(e){super(),this.name=e}get astNodeType(){return"varExpr"}}class Me extends Te{constructor(e,n){super(),this.name=e,this.initializer=n}get astNodeType(){return"constExpr"}evaluate(e){var n,t;if(this.initializer instanceof Ee){const o=null===(n=this.postfix)||void 0===n?void 0:n.evaluateString(e),r=null===(t=this.initializer.type)||void 0===t?void 0:t.name,i=e.structs.get(r),s=null==i?void 0:i.getMemberIndex(o);if(-1!=s){return this.initializer.args[s].evaluate(e)}console.log(s)}return this.initializer.evaluate(e)}}class Re extends Te{constructor(e){super(),this.value=e}get astNodeType(){return"literalExpr"}evaluate(){return this.value}}class Oe extends Te{constructor(e,n){super(),this.type=e,this.value=n}get astNodeType(){return"bitcastExpr"}}class Xe extends Te{constructor(e,n){super(),this.type=e,this.args=n}get astNodeType(){return"typecastExpr"}evaluate(e){return this.args[0].evaluate(e)}}class ze extends Te{constructor(e){super(),this.contents=e}get astNodeType(){return"groupExpr"}evaluate(e){return this.contents[0].evaluate(e)}}class Be extends Te{constructor(){super()}}class Qe extends Be{constructor(e,n){super(),this.operator=e,this.right=n}get astNodeType(){return"unaryOp"}evaluate(e){switch(this.operator){case"+":return this.right.evaluate(e);case"-":return-this.right.evaluate(e);case"!":return this.right.evaluate(e)?0:1;case"~":return~this.right.evaluate(e);default:throw new Error("Unknown unary operator: "+this.operator)}}}class De extends Be{constructor(e,n,t){super(),this.operator=e,this.left=n,this.right=t}get astNodeType(){return"binaryOp"}evaluate(e){switch(this.operator){case"+":return this.left.evaluate(e)+this.right.evaluate(e);case"-":return this.left.evaluate(e)-this.right.evaluate(e);case"*":return this.left.evaluate(e)*this.right.evaluate(e);case"/":return this.left.evaluate(e)/this.right.evaluate(e);case"%":return this.left.evaluate(e)%this.right.evaluate(e);case"==":return this.left.evaluate(e)==this.right.evaluate(e)?1:0;case"!=":return this.left.evaluate(e)!=this.right.evaluate(e)?1:0;case"<":return this.left.evaluate(e)<this.right.evaluate(e)?1:0;case">":return this.left.evaluate(e)>this.right.evaluate(e)?1:0;case"<=":return this.left.evaluate(e)<=this.right.evaluate(e)?1:0;case">=":return this.left.evaluate(e)>=this.right.evaluate(e)?1:0;case"&&":return this.left.evaluate(e)&&this.right.evaluate(e)?1:0;case"||":return this.left.evaluate(e)||this.right.evaluate(e)?1:0;default:throw new Error(`Unknown operator ${this.operator}`)}}}class Ye extends ${constructor(){super()}}class He extends Ye{constructor(e,n){super(),this.selector=e,this.body=n}get astNodeType(){return"case"}}class Ve extends Ye{constructor(e){super(),this.body=e}get astNodeType(){return"default"}}class We extends ${constructor(e,n,t){super(),this.name=e,this.type=n,this.attributes=t}get astNodeType(){return"argument"}}class Ge extends ${constructor(e,n){super(),this.condition=e,this.body=n}get astNodeType(){return"elseif"}}class qe extends ${constructor(e,n,t){super(),this.name=e,this.type=n,this.attributes=t}get astNodeType(){return"member"}}class je extends ${constructor(e,n){super(),this.name=e,this.value=n}get astNodeType(){return"attribute"}}!function(e){e[e.token=0]="token",e[e.keyword=1]="keyword",e[e.reserved=2]="reserved"}(ue||(ue={}));class $e{constructor(e,n,t){this.name=e,this.type=n,this.rule=t}toString(){return this.name}}class Ke{}ce=Ke,Ke.none=new $e("",ue.reserved,""),Ke.eof=new $e("EOF",ue.token,""),Ke.reserved={asm:new $e("asm",ue.reserved,"asm"),bf16:new $e("bf16",ue.reserved,"bf16"),do:new $e("do",ue.reserved,"do"),enum:new $e("enum",ue.reserved,"enum"),f16:new $e("f16",ue.reserved,"f16"),f64:new $e("f64",ue.reserved,"f64"),handle:new $e("handle",ue.reserved,"handle"),i8:new $e("i8",ue.reserved,"i8"),i16:new $e("i16",ue.reserved,"i16"),i64:new $e("i64",ue.reserved,"i64"),mat:new $e("mat",ue.reserved,"mat"),premerge:new $e("premerge",ue.reserved,"premerge"),regardless:new $e("regardless",ue.reserved,"regardless"),typedef:new $e("typedef",ue.reserved,"typedef"),u8:new $e("u8",ue.reserved,"u8"),u16:new $e("u16",ue.reserved,"u16"),u64:new $e("u64",ue.reserved,"u64"),unless:new $e("unless",ue.reserved,"unless"),using:new $e("using",ue.reserved,"using"),vec:new $e("vec",ue.reserved,"vec"),void:new $e("void",ue.reserved,"void")},Ke.keywords={array:new $e("array",ue.keyword,"array"),atomic:new $e("atomic",ue.keyword,"atomic"),bool:new $e("bool",ue.keyword,"bool"),f32:new $e("f32",ue.keyword,"f32"),i32:new $e("i32",ue.keyword,"i32"),mat2x2:new $e("mat2x2",ue.keyword,"mat2x2"),mat2x3:new $e("mat2x3",ue.keyword,"mat2x3"),mat2x4:new $e("mat2x4",ue.keyword,"mat2x4"),mat3x2:new $e("mat3x2",ue.keyword,"mat3x2"),mat3x3:new $e("mat3x3",ue.keyword,"mat3x3"),mat3x4:new $e("mat3x4",ue.keyword,"mat3x4"),mat4x2:new $e("mat4x2",ue.keyword,"mat4x2"),mat4x3:new $e("mat4x3",ue.keyword,"mat4x3"),mat4x4:new $e("mat4x4",ue.keyword,"mat4x4"),ptr:new $e("ptr",ue.keyword,"ptr"),sampler:new $e("sampler",ue.keyword,"sampler"),sampler_comparison:new $e("sampler_comparison",ue.keyword,"sampler_comparison"),struct:new $e("struct",ue.keyword,"struct"),texture_1d:new $e("texture_1d",ue.keyword,"texture_1d"),texture_2d:new $e("texture_2d",ue.keyword,"texture_2d"),texture_2d_array:new $e("texture_2d_array",ue.keyword,"texture_2d_array"),texture_3d:new $e("texture_3d",ue.keyword,"texture_3d"),texture_cube:new $e("texture_cube",ue.keyword,"texture_cube"),texture_cube_array:new $e("texture_cube_array",ue.keyword,"texture_cube_array"),texture_multisampled_2d:new $e("texture_multisampled_2d",ue.keyword,"texture_multisampled_2d"),texture_storage_1d:new $e("texture_storage_1d",ue.keyword,"texture_storage_1d"),texture_storage_2d:new $e("texture_storage_2d",ue.keyword,"texture_storage_2d"),texture_storage_2d_array:new $e("texture_storage_2d_array",ue.keyword,"texture_storage_2d_array"),texture_storage_3d:new $e("texture_storage_3d",ue.keyword,"texture_storage_3d"),texture_depth_2d:new $e("texture_depth_2d",ue.keyword,"texture_depth_2d"),texture_depth_2d_array:new $e("texture_depth_2d_array",ue.keyword,"texture_depth_2d_array"),texture_depth_cube:new $e("texture_depth_cube",ue.keyword,"texture_depth_cube"),texture_depth_cube_array:new $e("texture_depth_cube_array",ue.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new $e("texture_depth_multisampled_2d",ue.keyword,"texture_depth_multisampled_2d"),texture_external:new $e("texture_external",ue.keyword,"texture_external"),u32:new $e("u32",ue.keyword,"u32"),vec2:new $e("vec2",ue.keyword,"vec2"),vec3:new $e("vec3",ue.keyword,"vec3"),vec4:new $e("vec4",ue.keyword,"vec4"),bitcast:new $e("bitcast",ue.keyword,"bitcast"),block:new $e("block",ue.keyword,"block"),break:new $e("break",ue.keyword,"break"),case:new $e("case",ue.keyword,"case"),continue:new $e("continue",ue.keyword,"continue"),continuing:new $e("continuing",ue.keyword,"continuing"),default:new $e("default",ue.keyword,"default"),discard:new $e("discard",ue.keyword,"discard"),else:new $e("else",ue.keyword,"else"),enable:new $e("enable",ue.keyword,"enable"),fallthrough:new $e("fallthrough",ue.keyword,"fallthrough"),false:new $e("false",ue.keyword,"false"),fn:new $e("fn",ue.keyword,"fn"),for:new $e("for",ue.keyword,"for"),function:new $e("function",ue.keyword,"function"),if:new $e("if",ue.keyword,"if"),let:new $e("let",ue.keyword,"let"),const:new $e("const",ue.keyword,"const"),loop:new $e("loop",ue.keyword,"loop"),while:new $e("while",ue.keyword,"while"),private:new $e("private",ue.keyword,"private"),read:new $e("read",ue.keyword,"read"),read_write:new $e("read_write",ue.keyword,"read_write"),return:new $e("return",ue.keyword,"return"),storage:new $e("storage",ue.keyword,"storage"),switch:new $e("switch",ue.keyword,"switch"),true:new $e("true",ue.keyword,"true"),alias:new $e("alias",ue.keyword,"alias"),type:new $e("type",ue.keyword,"type"),uniform:new $e("uniform",ue.keyword,"uniform"),var:new $e("var",ue.keyword,"var"),override:new $e("override",ue.keyword,"override"),workgroup:new $e("workgroup",ue.keyword,"workgroup"),write:new $e("write",ue.keyword,"write"),r8unorm:new $e("r8unorm",ue.keyword,"r8unorm"),r8snorm:new $e("r8snorm",ue.keyword,"r8snorm"),r8uint:new $e("r8uint",ue.keyword,"r8uint"),r8sint:new $e("r8sint",ue.keyword,"r8sint"),r16uint:new $e("r16uint",ue.keyword,"r16uint"),r16sint:new $e("r16sint",ue.keyword,"r16sint"),r16float:new $e("r16float",ue.keyword,"r16float"),rg8unorm:new $e("rg8unorm",ue.keyword,"rg8unorm"),rg8snorm:new $e("rg8snorm",ue.keyword,"rg8snorm"),rg8uint:new $e("rg8uint",ue.keyword,"rg8uint"),rg8sint:new $e("rg8sint",ue.keyword,"rg8sint"),r32uint:new $e("r32uint",ue.keyword,"r32uint"),r32sint:new $e("r32sint",ue.keyword,"r32sint"),r32float:new $e("r32float",ue.keyword,"r32float"),rg16uint:new $e("rg16uint",ue.keyword,"rg16uint"),rg16sint:new $e("rg16sint",ue.keyword,"rg16sint"),rg16float:new $e("rg16float",ue.keyword,"rg16float"),rgba8unorm:new $e("rgba8unorm",ue.keyword,"rgba8unorm"),rgba8unorm_srgb:new $e("rgba8unorm_srgb",ue.keyword,"rgba8unorm_srgb"),rgba8snorm:new $e("rgba8snorm",ue.keyword,"rgba8snorm"),rgba8uint:new $e("rgba8uint",ue.keyword,"rgba8uint"),rgba8sint:new $e("rgba8sint",ue.keyword,"rgba8sint"),bgra8unorm:new $e("bgra8unorm",ue.keyword,"bgra8unorm"),bgra8unorm_srgb:new $e("bgra8unorm_srgb",ue.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new $e("rgb10a2unorm",ue.keyword,"rgb10a2unorm"),rg11b10float:new $e("rg11b10float",ue.keyword,"rg11b10float"),rg32uint:new $e("rg32uint",ue.keyword,"rg32uint"),rg32sint:new $e("rg32sint",ue.keyword,"rg32sint"),rg32float:new $e("rg32float",ue.keyword,"rg32float"),rgba16uint:new $e("rgba16uint",ue.keyword,"rgba16uint"),rgba16sint:new $e("rgba16sint",ue.keyword,"rgba16sint"),rgba16float:new $e("rgba16float",ue.keyword,"rgba16float"),rgba32uint:new $e("rgba32uint",ue.keyword,"rgba32uint"),rgba32sint:new $e("rgba32sint",ue.keyword,"rgba32sint"),rgba32float:new $e("rgba32float",ue.keyword,"rgba32float"),static_assert:new $e("static_assert",ue.keyword,"static_assert")},Ke.tokens={decimal_float_literal:new $e("decimal_float_literal",ue.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),hex_float_literal:new $e("hex_float_literal",ue.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),int_literal:new $e("int_literal",ue.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new $e("uint_literal",ue.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),ident:new $e("ident",ue.token,/[a-zA-Z][0-9a-zA-Z_]*/),and:new $e("and",ue.token,"&"),and_and:new $e("and_and",ue.token,"&&"),arrow:new $e("arrow ",ue.token,"->"),attr:new $e("attr",ue.token,"@"),attr_left:new $e("attr_left",ue.token,"[["),attr_right:new $e("attr_right",ue.token,"]]"),forward_slash:new $e("forward_slash",ue.token,"/"),bang:new $e("bang",ue.token,"!"),bracket_left:new $e("bracket_left",ue.token,"["),bracket_right:new $e("bracket_right",ue.token,"]"),brace_left:new $e("brace_left",ue.token,"{"),brace_right:new $e("brace_right",ue.token,"}"),colon:new $e("colon",ue.token,":"),comma:new $e("comma",ue.token,","),equal:new $e("equal",ue.token,"="),equal_equal:new $e("equal_equal",ue.token,"=="),not_equal:new $e("not_equal",ue.token,"!="),greater_than:new $e("greater_than",ue.token,">"),greater_than_equal:new $e("greater_than_equal",ue.token,">="),shift_right:new $e("shift_right",ue.token,">>"),less_than:new $e("less_than",ue.token,"<"),less_than_equal:new $e("less_than_equal",ue.token,"<="),shift_left:new $e("shift_left",ue.token,"<<"),modulo:new $e("modulo",ue.token,"%"),minus:new $e("minus",ue.token,"-"),minus_minus:new $e("minus_minus",ue.token,"--"),period:new $e("period",ue.token,"."),plus:new $e("plus",ue.token,"+"),plus_plus:new $e("plus_plus",ue.token,"++"),or:new $e("or",ue.token,"|"),or_or:new $e("or_or",ue.token,"||"),paren_left:new $e("paren_left",ue.token,"("),paren_right:new $e("paren_right",ue.token,")"),semicolon:new $e("semicolon",ue.token,";"),star:new $e("star",ue.token,"*"),tilde:new $e("tilde",ue.token,"~"),underscore:new $e("underscore",ue.token,"_"),xor:new $e("xor",ue.token,"^"),plus_equal:new $e("plus_equal",ue.token,"+="),minus_equal:new $e("minus_equal",ue.token,"-="),times_equal:new $e("times_equal",ue.token,"*="),division_equal:new $e("division_equal",ue.token,"/="),modulo_equal:new $e("modulo_equal",ue.token,"%="),and_equal:new $e("and_equal",ue.token,"&="),or_equal:new $e("or_equal",ue.token,"|="),xor_equal:new $e("xor_equal",ue.token,"^="),shift_right_equal:new $e("shift_right_equal",ue.token,">>="),shift_left_equal:new $e("shift_left_equal",ue.token,"<<=")},Ke.storage_class=[ce.keywords.function,ce.keywords.private,ce.keywords.workgroup,ce.keywords.uniform,ce.keywords.storage],Ke.access_mode=[ce.keywords.read,ce.keywords.write,ce.keywords.read_write],Ke.sampler_type=[ce.keywords.sampler,ce.keywords.sampler_comparison],Ke.sampled_texture_type=[ce.keywords.texture_1d,ce.keywords.texture_2d,ce.keywords.texture_2d_array,ce.keywords.texture_3d,ce.keywords.texture_cube,ce.keywords.texture_cube_array],Ke.multisampled_texture_type=[ce.keywords.texture_multisampled_2d],Ke.storage_texture_type=[ce.keywords.texture_storage_1d,ce.keywords.texture_storage_2d,ce.keywords.texture_storage_2d_array,ce.keywords.texture_storage_3d],Ke.depth_texture_type=[ce.keywords.texture_depth_2d,ce.keywords.texture_depth_2d_array,ce.keywords.texture_depth_cube,ce.keywords.texture_depth_cube_array,ce.keywords.texture_depth_multisampled_2d],Ke.texture_external_type=[ce.keywords.texture_external],Ke.any_texture_type=[...ce.sampled_texture_type,...ce.multisampled_texture_type,...ce.storage_texture_type,...ce.depth_texture_type,...ce.texture_external_type],Ke.texel_format=[ce.keywords.r8unorm,ce.keywords.r8snorm,ce.keywords.r8uint,ce.keywords.r8sint,ce.keywords.r16uint,ce.keywords.r16sint,ce.keywords.r16float,ce.keywords.rg8unorm,ce.keywords.rg8snorm,ce.keywords.rg8uint,ce.keywords.rg8sint,ce.keywords.r32uint,ce.keywords.r32sint,ce.keywords.r32float,ce.keywords.rg16uint,ce.keywords.rg16sint,ce.keywords.rg16float,ce.keywords.rgba8unorm,ce.keywords.rgba8unorm_srgb,ce.keywords.rgba8snorm,ce.keywords.rgba8uint,ce.keywords.rgba8sint,ce.keywords.bgra8unorm,ce.keywords.bgra8unorm_srgb,ce.keywords.rgb10a2unorm,ce.keywords.rg11b10float,ce.keywords.rg32uint,ce.keywords.rg32sint,ce.keywords.rg32float,ce.keywords.rgba16uint,ce.keywords.rgba16sint,ce.keywords.rgba16float,ce.keywords.rgba32uint,ce.keywords.rgba32sint,ce.keywords.rgba32float],Ke.const_literal=[ce.tokens.int_literal,ce.tokens.uint_literal,ce.tokens.decimal_float_literal,ce.tokens.hex_float_literal,ce.keywords.true,ce.keywords.false],Ke.literal_or_ident=[ce.tokens.ident,ce.tokens.int_literal,ce.tokens.uint_literal,ce.tokens.decimal_float_literal,ce.tokens.hex_float_literal],Ke.element_count_expression=[ce.tokens.int_literal,ce.tokens.uint_literal,ce.tokens.ident],Ke.template_types=[ce.keywords.vec2,ce.keywords.vec3,ce.keywords.vec4,ce.keywords.mat2x2,ce.keywords.mat2x3,ce.keywords.mat2x4,ce.keywords.mat3x2,ce.keywords.mat3x3,ce.keywords.mat3x4,ce.keywords.mat4x2,ce.keywords.mat4x3,ce.keywords.mat4x4,ce.keywords.atomic,ce.keywords.bitcast,...ce.any_texture_type],Ke.attribute_name=[ce.tokens.ident,ce.keywords.block],Ke.assignment_operators=[ce.tokens.equal,ce.tokens.plus_equal,ce.tokens.minus_equal,ce.tokens.times_equal,ce.tokens.division_equal,ce.tokens.modulo_equal,ce.tokens.and_equal,ce.tokens.or_equal,ce.tokens.xor_equal,ce.tokens.shift_right_equal,ce.tokens.shift_left_equal],Ke.increment_operators=[ce.tokens.plus_plus,ce.tokens.minus_minus];class Ze{constructor(e,n,t){this.type=e,this.lexeme=n,this.line=t}toString(){return this.lexeme}isTemplateType(){return-1!=Ke.template_types.indexOf(this.type)}isArrayType(){return this.type==Ke.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}}class Je{constructor(e){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=null!=e?e:""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new Ze(Ke.eof,"",this._line)),this._tokens}scanToken(){let e=this._advance();if("\n"==e)return this._line++,!0;if(this._isWhitespace(e))return!0;if("/"==e){if("/"==this._peekAhead()){for(;"\n"!=e;){if(this._isAtEnd())return!0;e=this._advance()}return this._line++,!0}if("*"==this._peekAhead()){this._advance();let n=1;for(;n>0;){if(this._isAtEnd())return!0;if(e=this._advance(),"\n"==e)this._line++;else if("*"==e){if("/"==this._peekAhead()&&(this._advance(),n--,0==n))return!0}else"/"==e&&"*"==this._peekAhead()&&(this._advance(),n++)}return!0}}let n=Ke.none;for(;;){let t=this._findType(e);const o=this._peekAhead();if(">"==e&&(">"==o||"="==o)){let e=!1,n=this._tokens.length-1;for(let t=0;t<5&&n>=0;++t,--n)if(this._tokens[n].type===Ke.tokens.less_than){n>0&&this._tokens[n-1].isArrayOrTemplateType()&&(e=!0);break}if(e)return this._addToken(t),!0}if(t===Ke.none){let o=e,r=0;const i=2;for(let e=0;e<i;++e)if(o+=this._peekAhead(e),t=this._findType(o),t!==Ke.none){r=e;break}if(t===Ke.none)return n!==Ke.none&&(this._current--,this._addToken(n),!0);e=o,this._current+=r+1}if(n=t,this._isAtEnd())break;e+=this._advance()}return n!==Ke.none&&(this._addToken(n),!0)}_findType(e){for(const n in Ke.keywords){const t=Ke.keywords[n];if(this._match(e,t.rule))return t}for(const n in Ke.tokens){const t=Ke.tokens[n];if(this._match(e,t.rule))return t}return Ke.none}_match(e,n){if("string"==typeof n){if(n==e)return!0}else{const t=n.exec(e);if(t&&0==t.index&&t[0]==e)return!0}return!1}_isAtEnd(){return this._current>=this._source.length}_isWhitespace(e){return" "==e||"\t"==e||"\r"==e}_advance(e=0){let n=this._source[this._current];return e=e||0,e++,this._current+=e,n}_peekAhead(e=0){return e=e||0,this._current+e>=this._source.length?"\0":this._source[this._current+e]}_addToken(e){const n=this._source.substring(this._start,this._current);this._tokens.push(new Ze(e,n,this._line))}}class en{constructor(){this._tokens=[],this._current=0,this._context=new j}parse(e){this._initialize(e);let n=[];for(;!this._isAtEnd();){const e=this._global_decl_or_directive();if(!e)break;n.push(e)}return n}_initialize(e){if(e)if("string"==typeof e){const n=new Je(e);this._tokens=n.scanTokens()}else this._tokens=e;else this._tokens=[];this._current=0}_error(e,n){return console.error(e,n),{token:e,message:n,toString:function(){return`${n}`}}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==Ke.eof}_match(e){if(e instanceof $e)return!!this._check(e)&&(this._advance(),!0);for(let n=0,t=e.length;n<t;++n){const t=e[n];if(this._check(t))return this._advance(),!0}return!1}_consume(e,n){if(this._check(e))return this._advance();throw this._error(this._peek(),n)}_check(e){if(this._isAtEnd())return!1;const n=this._peek();if(e instanceof Array){let t=n.type;return-1!=e.indexOf(t)}return n.type==e}_advance(){return this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(Ke.tokens.semicolon)&&!this._isAtEnd(););if(this._match(Ke.keywords.alias)){const e=this._type_alias();return this._consume(Ke.tokens.semicolon,"Expected ';'"),e}if(this._match(Ke.keywords.enable)){const e=this._enable_directive();return this._consume(Ke.tokens.semicolon,"Expected ';'"),e}const e=this._attribute();if(this._check(Ke.keywords.var)){const n=this._global_variable_decl();return null!=n&&(n.attributes=e),this._consume(Ke.tokens.semicolon,"Expected ';'."),n}if(this._check(Ke.keywords.override)){const n=this._override_variable_decl();return null!=n&&(n.attributes=e),this._consume(Ke.tokens.semicolon,"Expected ';'."),n}if(this._check(Ke.keywords.let)){const n=this._global_let_decl();return null!=n&&(n.attributes=e),this._consume(Ke.tokens.semicolon,"Expected ';'."),n}if(this._check(Ke.keywords.const)){const n=this._global_const_decl();return null!=n&&(n.attributes=e),this._consume(Ke.tokens.semicolon,"Expected ';'."),n}if(this._check(Ke.keywords.struct)){const n=this._struct_decl();return null!=n&&(n.attributes=e),n}if(this._check(Ke.keywords.fn)){const n=this._function_decl();return null!=n&&(n.attributes=e),n}return null}_function_decl(){if(!this._match(Ke.keywords.fn))return null;const e=this._consume(Ke.tokens.ident,"Expected function name.").toString();this._consume(Ke.tokens.paren_left,"Expected '(' for function arguments.");const n=[];if(!this._check(Ke.tokens.paren_right))do{if(this._check(Ke.tokens.paren_right))break;const e=this._attribute(),t=this._consume(Ke.tokens.ident,"Expected argument name.").toString();this._consume(Ke.tokens.colon,"Expected ':' for argument type.");const o=this._attribute(),r=this._type_decl();null!=r&&(r.attributes=o,n.push(new We(t,r,e)))}while(this._match(Ke.tokens.comma));this._consume(Ke.tokens.paren_right,"Expected ')' after function arguments.");let t=null;if(this._match(Ke.tokens.arrow)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}const o=this._compound_statement();return new Z(e,n,t,o)}_compound_statement(){const e=[];for(this._consume(Ke.tokens.brace_left,"Expected '{' for block.");!this._check(Ke.tokens.brace_right);){const n=this._statement();null!==n&&e.push(n)}return this._consume(Ke.tokens.brace_right,"Expected '}' for block."),e}_statement(){for(;this._match(Ke.tokens.semicolon)&&!this._isAtEnd(););if(this._check(Ke.keywords.if))return this._if_statement();if(this._check(Ke.keywords.switch))return this._switch_statement();if(this._check(Ke.keywords.loop))return this._loop_statement();if(this._check(Ke.keywords.for))return this._for_statement();if(this._check(Ke.keywords.while))return this._while_statement();if(this._check(Ke.keywords.continuing))return this._continuing_statement();if(this._check(Ke.keywords.static_assert))return this._static_assert_statement();if(this._check(Ke.tokens.brace_left))return this._compound_statement();let e=null;return e=this._check(Ke.keywords.return)?this._return_statement():this._check([Ke.keywords.var,Ke.keywords.let,Ke.keywords.const])?this._variable_statement():this._match(Ke.keywords.discard)?new Ae:this._match(Ke.keywords.break)?new ye:this._match(Ke.keywords.continue)?new Pe:this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement(),null!=e&&this._consume(Ke.tokens.semicolon,"Expected ';' after statement."),e}_static_assert_statement(){if(!this._match(Ke.keywords.static_assert))return null;let e=this._optional_paren_expression();return new J(e)}_while_statement(){if(!this._match(Ke.keywords.while))return null;let e=this._optional_paren_expression();const n=this._compound_statement();return new ee(e,n)}_continuing_statement(){if(!this._match(Ke.keywords.continuing))return null;const e=this._compound_statement();return new ne(e)}_for_statement(){if(!this._match(Ke.keywords.for))return null;this._consume(Ke.tokens.paren_left,"Expected '('.");const e=this._check(Ke.tokens.semicolon)?null:this._for_init();this._consume(Ke.tokens.semicolon,"Expected ';'.");const n=this._check(Ke.tokens.semicolon)?null:this._short_circuit_or_expression();this._consume(Ke.tokens.semicolon,"Expected ';'.");const t=this._check(Ke.tokens.paren_right)?null:this._for_increment();this._consume(Ke.tokens.paren_right,"Expected ')'.");const o=this._compound_statement();return new te(e,n,t,o)}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(Ke.keywords.var)){const e=this._variable_decl();if(null===e)throw this._error(this._peek(),"Variable declaration expected.");let n=null;return this._match(Ke.tokens.equal)&&(n=this._short_circuit_or_expression()),new oe(e.name,e.type,e.storage,e.access,n)}if(this._match(Ke.keywords.let)){const e=this._consume(Ke.tokens.ident,"Expected name for let.").toString();let n=null;if(this._match(Ke.tokens.colon)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}this._consume(Ke.tokens.equal,"Expected '=' for let.");const t=this._short_circuit_or_expression();return new ie(e,n,null,null,t)}if(this._match(Ke.keywords.const)){const e=this._consume(Ke.tokens.ident,"Expected name for const.").toString();let n=null;if(this._match(Ke.tokens.colon)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}this._consume(Ke.tokens.equal,"Expected '=' for const.");const t=this._short_circuit_or_expression();return new se(e,n,null,null,t)}return null}_increment_decrement_statement(){const e=this._current,n=this._unary_expression();if(null==n)return null;if(!this._check(Ke.increment_operators))return this._current=e,null;const t=this._consume(Ke.increment_operators,"Expected increment operator");return new fe(t.type===Ke.tokens.plus_plus?ae.increment:ae.decrement,n)}_assignment_statement(){let e=null;if(this._check(Ke.tokens.brace_right))return null;let n=this._match(Ke.tokens.underscore);if(n||(e=this._unary_expression()),!n&&null==e)return null;const t=this._consume(Ke.assignment_operators,"Expected assignment operator."),o=this._short_circuit_or_expression();return new de(le.parse(t.lexeme),e,o)}_func_call_statement(){if(!this._check(Ke.tokens.ident))return null;const e=this._current,n=this._consume(Ke.tokens.ident,"Expected function name."),t=this._argument_expression_list();return null===t?(this._current=e,null):new pe(n.lexeme,t)}_loop_statement(){if(!this._match(Ke.keywords.loop))return null;this._consume(Ke.tokens.brace_left,"Expected '{' for loop.");const e=[];let n=this._statement();for(;null!==n;){if(Array.isArray(n))for(let t of n)e.push(t);else e.push(n);n=this._statement()}let t=null;return this._match(Ke.keywords.continuing)&&(t=this._compound_statement()),this._consume(Ke.tokens.brace_right,"Expected '}' for loop."),new he(e,t)}_switch_statement(){if(!this._match(Ke.keywords.switch))return null;const e=this._optional_paren_expression();this._consume(Ke.tokens.brace_left,"Expected '{' for switch.");const n=this._switch_body();if(null==n||0==n.length)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(Ke.tokens.brace_right,"Expected '}' for switch."),new me(e,n)}_switch_body(){const e=[];if(this._match(Ke.keywords.case)){const n=this._case_selectors();this._match(Ke.tokens.colon),this._consume(Ke.tokens.brace_left,"Exected '{' for switch case.");const t=this._case_body();this._consume(Ke.tokens.brace_right,"Exected '}' for switch case."),e.push(new He(n,t))}if(this._match(Ke.keywords.default)){this._match(Ke.tokens.colon),this._consume(Ke.tokens.brace_left,"Exected '{' for switch default.");const n=this._case_body();this._consume(Ke.tokens.brace_right,"Exected '}' for switch default."),e.push(new Ve(n))}if(this._check([Ke.keywords.default,Ke.keywords.case])){const n=this._switch_body();e.push(n[0])}return e}_case_selectors(){var e,n,t,o;const r=[null!==(n=null===(e=this._shift_expression())||void 0===e?void 0:e.evaluate(this._context).toString())&&void 0!==n?n:""];for(;this._match(Ke.tokens.comma);)r.push(null!==(o=null===(t=this._shift_expression())||void 0===t?void 0:t.evaluate(this._context).toString())&&void 0!==o?o:"");return r}_case_body(){if(this._match(Ke.keywords.fallthrough))return this._consume(Ke.tokens.semicolon,"Expected ';'"),[];let e=this._statement();if(null==e)return[];e instanceof Array||(e=[e]);const n=this._case_body();return 0==n.length?e:[...e,n[0]]}_if_statement(){if(!this._match(Ke.keywords.if))return null;const e=this._optional_paren_expression(),n=this._compound_statement();let t=[];this._match_elseif()&&(t=this._elseif_statement(t));let o=null;return this._match(Ke.keywords.else)&&(o=this._compound_statement()),new ge(e,n,t,o)}_match_elseif(){return this._tokens[this._current].type===Ke.keywords.else&&this._tokens[this._current+1].type===Ke.keywords.if&&(this._advance(),this._advance(),!0)}_elseif_statement(e=[]){const n=this._optional_paren_expression(),t=this._compound_statement();return e.push(new Ge(n,t)),this._match_elseif()&&this._elseif_statement(e),e}_return_statement(){if(!this._match(Ke.keywords.return))return null;const e=this._short_circuit_or_expression();return new ve(e)}_short_circuit_or_expression(){let e=this._short_circuit_and_expr();for(;this._match(Ke.tokens.or_or);)e=new De(this._previous().toString(),e,this._short_circuit_and_expr());return e}_short_circuit_and_expr(){let e=this._inclusive_or_expression();for(;this._match(Ke.tokens.and_and);)e=new De(this._previous().toString(),e,this._inclusive_or_expression());return e}_inclusive_or_expression(){let e=this._exclusive_or_expression();for(;this._match(Ke.tokens.or);)e=new De(this._previous().toString(),e,this._exclusive_or_expression());return e}_exclusive_or_expression(){let e=this._and_expression();for(;this._match(Ke.tokens.xor);)e=new De(this._previous().toString(),e,this._and_expression());return e}_and_expression(){let e=this._equality_expression();for(;this._match(Ke.tokens.and);)e=new De(this._previous().toString(),e,this._equality_expression());return e}_equality_expression(){const e=this._relational_expression();return this._match([Ke.tokens.equal_equal,Ke.tokens.not_equal])?new De(this._previous().toString(),e,this._relational_expression()):e}_relational_expression(){let e=this._shift_expression();for(;this._match([Ke.tokens.less_than,Ke.tokens.greater_than,Ke.tokens.less_than_equal,Ke.tokens.greater_than_equal]);)e=new De(this._previous().toString(),e,this._shift_expression());return e}_shift_expression(){let e=this._additive_expression();for(;this._match([Ke.tokens.shift_left,Ke.tokens.shift_right]);)e=new De(this._previous().toString(),e,this._additive_expression());return e}_additive_expression(){let e=this._multiplicative_expression();for(;this._match([Ke.tokens.plus,Ke.tokens.minus]);)e=new De(this._previous().toString(),e,this._multiplicative_expression());return e}_multiplicative_expression(){let e=this._unary_expression();for(;this._match([Ke.tokens.star,Ke.tokens.forward_slash,Ke.tokens.modulo]);)e=new De(this._previous().toString(),e,this._unary_expression());return e}_unary_expression(){return this._match([Ke.tokens.minus,Ke.tokens.bang,Ke.tokens.tilde,Ke.tokens.star,Ke.tokens.and])?new Qe(this._previous().toString(),this._unary_expression()):this._singular_expression()}_singular_expression(){const e=this._primary_expression(),n=this._postfix_expression();return n&&(e.postfix=n),e}_postfix_expression(){if(this._match(Ke.tokens.bracket_left)){const e=this._short_circuit_or_expression();this._consume(Ke.tokens.bracket_right,"Expected ']'.");const n=this._postfix_expression();return n&&(e.postfix=n),e}if(this._match(Ke.tokens.period)){const e=this._consume(Ke.tokens.ident,"Expected member name."),n=this._postfix_expression(),t=new Se(e.lexeme);return n&&(t.postfix=n),t}return null}_getStruct(e){if(this._context.aliases.has(e)){return this._context.aliases.get(e).type}if(this._context.structs.has(e)){return this._context.structs.get(e)}return null}_primary_expression(){if(this._match(Ke.tokens.ident)){const e=this._previous().toString();if(this._check(Ke.tokens.paren_left)){const n=this._argument_expression_list(),t=this._getStruct(e);return null!=t?new Ee(t,n):new Ce(e,n)}if(this._context.constants.has(e)){const n=this._context.constants.get(e);return new Me(e,n.value)}return new Ue(e)}if(this._match(Ke.const_literal))return new Re(parseFloat(this._previous().toString()));if(this._check(Ke.tokens.paren_left))return this._paren_expression();if(this._match(Ke.keywords.bitcast)){this._consume(Ke.tokens.less_than,"Expected '<'.");const e=this._type_decl();this._consume(Ke.tokens.greater_than,"Expected '>'.");const n=this._paren_expression();return new Oe(e,n)}const e=this._type_decl(),n=this._argument_expression_list();return new Xe(e,n)}_argument_expression_list(){if(!this._match(Ke.tokens.paren_left))return null;const e=[];do{if(this._check(Ke.tokens.paren_right))break;const n=this._short_circuit_or_expression();e.push(n)}while(this._match(Ke.tokens.comma));return this._consume(Ke.tokens.paren_right,"Expected ')' for agument list"),e}_optional_paren_expression(){this._match(Ke.tokens.paren_left);const e=this._short_circuit_or_expression();return this._match(Ke.tokens.paren_right),new ze([e])}_paren_expression(){this._consume(Ke.tokens.paren_left,"Expected '('.");const e=this._short_circuit_or_expression();return this._consume(Ke.tokens.paren_right,"Expected ')'."),new ze([e])}_struct_decl(){if(!this._match(Ke.keywords.struct))return null;const e=this._consume(Ke.tokens.ident,"Expected name for struct.").toString();this._consume(Ke.tokens.brace_left,"Expected '{' for struct body.");const n=[];for(;!this._check(Ke.tokens.brace_right);){const e=this._attribute(),t=this._consume(Ke.tokens.ident,"Expected variable name.").toString();this._consume(Ke.tokens.colon,"Expected ':' for struct member type.");const o=this._attribute(),r=this._type_decl();null!=r&&(r.attributes=o),this._check(Ke.tokens.brace_right)?this._match(Ke.tokens.comma):this._consume(Ke.tokens.comma,"Expected ',' for struct member."),n.push(new qe(t,r,e))}this._consume(Ke.tokens.brace_right,"Expected '}' after struct body.");const t=new ke(e,n);return this._context.structs.set(e,t),t}_global_variable_decl(){const e=this._variable_decl();return e&&this._match(Ke.tokens.equal)&&(e.value=this._const_expression()),e}_override_variable_decl(){const e=this._override_decl();return e&&this._match(Ke.tokens.equal)&&(e.value=this._const_expression()),e}_global_const_decl(){if(!this._match(Ke.keywords.const))return null;const e=this._consume(Ke.tokens.ident,"Expected variable name");let n=null;if(this._match(Ke.tokens.colon)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}let t=null;if(this._match(Ke.tokens.equal)){const e=this._short_circuit_or_expression();if(e instanceof Ee)t=e;else if(e instanceof Me&&e.initializer instanceof Ee)t=e.initializer;else try{const n=e.evaluate(this._context);t=new Re(n)}catch(n){t=e}}const o=new se(e.toString(),n,"","",t);return this._context.constants.set(o.name,o),o}_global_let_decl(){if(!this._match(Ke.keywords.let))return null;const e=this._consume(Ke.tokens.ident,"Expected variable name");let n=null;if(this._match(Ke.tokens.colon)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}let t=null;return this._match(Ke.tokens.equal)&&(t=this._const_expression()),new ie(e.toString(),n,"","",t)}_const_expression(){if(this._match(Ke.const_literal))return new Se(this._previous().toString());const e=this._type_decl();this._consume(Ke.tokens.paren_left,"Expected '('.");let n=[];for(;!this._check(Ke.tokens.paren_right)&&(n.push(this._const_expression()),this._check(Ke.tokens.comma));)this._advance();return this._consume(Ke.tokens.paren_right,"Expected ')'."),new Ee(e,n)}_variable_decl(){if(!this._match(Ke.keywords.var))return null;let e="",n="";this._match(Ke.tokens.less_than)&&(e=this._consume(Ke.storage_class,"Expected storage_class.").toString(),this._match(Ke.tokens.comma)&&(n=this._consume(Ke.access_mode,"Expected access_mode.").toString()),this._consume(Ke.tokens.greater_than,"Expected '>'."));const t=this._consume(Ke.tokens.ident,"Expected variable name");let o=null;if(this._match(Ke.tokens.colon)){const e=this._attribute();o=this._type_decl(),null!=o&&(o.attributes=e)}return new oe(t.toString(),o,e,n,null)}_override_decl(){if(!this._match(Ke.keywords.override))return null;const e=this._consume(Ke.tokens.ident,"Expected variable name");let n=null;if(this._match(Ke.tokens.colon)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}return new re(e.toString(),n,null)}_enable_directive(){const e=this._consume(Ke.tokens.ident,"identity expected.");return new xe(e.toString())}_type_alias(){const e=this._consume(Ke.tokens.ident,"identity expected.");this._consume(Ke.tokens.equal,"Expected '=' for type alias.");let n=this._type_decl();if(null===n)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(n.name)&&(n=this._context.aliases.get(n.name).type);const t=new be(e.toString(),n);return this._context.aliases.set(t.name,t),t}_type_decl(){if(this._check([Ke.tokens.ident,...Ke.texel_format,Ke.keywords.bool,Ke.keywords.f32,Ke.keywords.i32,Ke.keywords.u32])){const e=this._advance(),n=e.toString();return this._context.structs.has(n)?this._context.structs.get(n):this._context.aliases.has(n)?this._context.aliases.get(n).type:new we(e.toString())}let e=this._texture_sampler_types();if(e)return e;if(this._check(Ke.template_types)){let e=this._advance().toString(),n=null,t=null;return this._match(Ke.tokens.less_than)&&(n=this._type_decl(),t=null,this._match(Ke.tokens.comma)&&(t=this._consume(Ke.access_mode,"Expected access_mode for pointer").toString()),this._consume(Ke.tokens.greater_than,"Expected '>' for type.")),new Le(e,n,t)}if(this._match(Ke.keywords.ptr)){let e=this._previous().toString();this._consume(Ke.tokens.less_than,"Expected '<' for pointer.");const n=this._consume(Ke.storage_class,"Expected storage_class for pointer");this._consume(Ke.tokens.comma,"Expected ',' for pointer.");const t=this._type_decl();let o=null;return this._match(Ke.tokens.comma)&&(o=this._consume(Ke.access_mode,"Expected access_mode for pointer").toString()),this._consume(Ke.tokens.greater_than,"Expected '>' for pointer."),new Fe(e,n.toString(),t,o)}const n=this._attribute();if(this._match(Ke.keywords.array)){let e=null,t=-1;const o=this._previous();if(this._match(Ke.tokens.less_than)){e=this._type_decl(),this._context.aliases.has(e.name)&&(e=this._context.aliases.get(e.name).type);let n="";if(this._match(Ke.tokens.comma)){n=this._shift_expression().evaluate(this._context).toString()}this._consume(Ke.tokens.greater_than,"Expected '>' for array."),t=n?parseInt(n):0}return new Ie(o.toString(),n,e,t)}return null}_texture_sampler_types(){if(this._match(Ke.sampler_type))return new Ne(this._previous().toString(),null,null);if(this._match(Ke.depth_texture_type))return new Ne(this._previous().toString(),null,null);if(this._match(Ke.sampled_texture_type)||this._match(Ke.multisampled_texture_type)){const e=this._previous();this._consume(Ke.tokens.less_than,"Expected '<' for sampler type.");const n=this._type_decl();return this._consume(Ke.tokens.greater_than,"Expected '>' for sampler type."),new Ne(e.toString(),n,null)}if(this._match(Ke.storage_texture_type)){const e=this._previous();this._consume(Ke.tokens.less_than,"Expected '<' for sampler type.");const n=this._consume(Ke.texel_format,"Invalid texel format.").toString();this._consume(Ke.tokens.comma,"Expected ',' after texel format.");const t=this._consume(Ke.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(Ke.tokens.greater_than,"Expected '>' for sampler type."),new Ne(e.toString(),n,t)}return null}_attribute(){let e=[];for(;this._match(Ke.tokens.attr);){const n=this._consume(Ke.attribute_name,"Expected attribute name"),t=new je(n.toString(),null);if(this._match(Ke.tokens.paren_left)){if(t.value=this._consume(Ke.literal_or_ident,"Expected attribute value").toString(),this._check(Ke.tokens.comma)){this._advance();do{const e=this._consume(Ke.literal_or_ident,"Expected attribute value").toString();t.value instanceof Array||(t.value=[t.value]),t.value.push(e)}while(this._match(Ke.tokens.comma))}this._consume(Ke.tokens.paren_right,"Expected ')'")}e.push(t)}for(;this._match(Ke.tokens.attr_left);){if(!this._check(Ke.tokens.attr_right))do{const n=this._consume(Ke.attribute_name,"Expected attribute name"),t=new je(n.toString(),null);if(this._match(Ke.tokens.paren_left)){if(t.value=[this._consume(Ke.literal_or_ident,"Expected attribute value").toString()],this._check(Ke.tokens.comma)){this._advance();do{const e=this._consume(Ke.literal_or_ident,"Expected attribute value").toString();t.value.push(e)}while(this._match(Ke.tokens.comma))}this._consume(Ke.tokens.paren_right,"Expected ')'")}e.push(t)}while(this._match(Ke.tokens.comma));this._consume(Ke.tokens.attr_right,"Expected ']]' after attribute declarations")}return 0==e.length?null:e}}class nn{constructor(e,n){this.name=e,this.attributes=n,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}}class tn{constructor(e,n,t){this.name=e,this.type=n,this.attributes=t,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class on extends nn{constructor(e,n){super(e,n),this.members=[],this.align=0}get isStruct(){return!0}}class rn extends nn{constructor(e,n){super(e,n),this.count=0,this.stride=0}get isArray(){return!0}}class sn extends nn{constructor(e,n,t,o){super(e,t),this.format=n,this.access=o}get isTemplate(){return!0}}!function(e){e[e.Uniform=0]="Uniform",e[e.Storage=1]="Storage",e[e.Texture=2]="Texture",e[e.Sampler=3]="Sampler",e[e.StorageTexture=4]="StorageTexture"}(_e||(_e={}));class an{constructor(e,n,t,o,r,i,s){this.name=e,this.type=n,this.group=t,this.binding=o,this.attributes=r,this.resourceType=i,this.access=s}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class ln{constructor(e,n){this.name=e,this.type=n}}class cn{constructor(e,n){this.align=e,this.size=n}}class un{constructor(e,n,t,o){this.name=e,this.type=n,this.locationType=t,this.location=o,this.interpolation=null}}class _n{constructor(e,n,t,o){this.name=e,this.type=n,this.locationType=t,this.location=o}}class fn{constructor(e,n=null){this.stage=null,this.inputs=[],this.outputs=[],this.name=e,this.stage=n}}class dn{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}}class pn{constructor(e,n,t,o){this.name=e,this.type=n,this.attributes=t,this.id=o}}class hn{constructor(e){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new dn,this._types=new Map,e&&this.update(e)}_isStorageTexture(e){return"texture_storage_1d"==e.name||"texture_storage_2d"==e.name||"texture_storage_2d_array"==e.name||"texture_storage_3d"==e.name}update(e){const n=(new en).parse(e);for(const e of n)if(e instanceof ke){const n=this._getTypeInfo(e,null);n instanceof on&&this.structs.push(n)}else if(e instanceof be)this.aliases.push(this._getAliasInfo(e));else if(e instanceof re){const n=e,t=this._getAttributeNum(n.attributes,"id",0),o=null!=n.type?this._getTypeInfo(n.type,n.attributes):null;this.overrides.push(new pn(n.name,o,n.attributes,t))}else if(this._isUniformVar(e)){const n=e,t=this._getAttributeNum(n.attributes,"group",0),o=this._getAttributeNum(n.attributes,"binding",0),r=this._getTypeInfo(n.type,n.attributes),i=new an(n.name,r,t,o,n.attributes,_e.Uniform,n.access);this.uniforms.push(i)}else if(this._isStorageVar(e)){const n=e,t=this._getAttributeNum(n.attributes,"group",0),o=this._getAttributeNum(n.attributes,"binding",0),r=this._getTypeInfo(n.type,n.attributes),i=this._isStorageTexture(r),s=new an(n.name,r,t,o,n.attributes,i?_e.StorageTexture:_e.Storage,n.access);this.storage.push(s)}else if(this._isTextureVar(e)){const n=e,t=this._getAttributeNum(n.attributes,"group",0),o=this._getAttributeNum(n.attributes,"binding",0),r=this._getTypeInfo(n.type,n.attributes),i=this._isStorageTexture(r),s=new an(n.name,r,t,o,n.attributes,i?_e.StorageTexture:_e.Texture,n.access);i?this.storage.push(s):this.textures.push(s)}else if(this._isSamplerVar(e)){const n=e,t=this._getAttributeNum(n.attributes,"group",0),o=this._getAttributeNum(n.attributes,"binding",0),r=this._getTypeInfo(n.type,n.attributes),i=new an(n.name,r,t,o,n.attributes,_e.Sampler,n.access);this.samplers.push(i)}else if(e instanceof Z){const n=this._getAttribute(e,"vertex"),t=this._getAttribute(e,"fragment"),o=this._getAttribute(e,"compute"),r=n||t||o;if(r){const n=new fn(e.name,r.name);n.inputs=this._getInputs(e.args),n.outputs=this._getOutputs(e.returnType),this.entry[r.name].push(n)}}else;}getBindGroups(){const e=[];function n(n,t){n>=e.length&&(e.length=n+1),void 0===e[n]&&(e[n]=[]),t>=e[n].length&&(e[n].length=t+1)}for(const t of this.uniforms){n(t.group,t.binding);e[t.group][t.binding]=t}for(const t of this.storage){n(t.group,t.binding);e[t.group][t.binding]=t}for(const t of this.textures){n(t.group,t.binding);e[t.group][t.binding]=t}for(const t of this.samplers){n(t.group,t.binding);e[t.group][t.binding]=t}return e}_getOutputs(e,n=void 0){if(void 0===n&&(n=[]),e instanceof ke)this._getStructOutputs(e,n);else{const t=this._getOutputInfo(e);null!==t&&n.push(t)}return n}_getStructOutputs(e,n){for(const t of e.members)if(t.type instanceof ke)this._getStructOutputs(t.type,n);else{const e=this._getAttribute(t,"location")||this._getAttribute(t,"builtin");if(null!==e){const o=this._getTypeInfo(t.type,t.type.attributes),r=this._parseInt(e.value),i=new _n(t.name,o,e.name,r);n.push(i)}}}_getOutputInfo(e){const n=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==n){const t=this._getTypeInfo(e,e.attributes),o=this._parseInt(n.value);return new _n("",t,n.name,o)}return null}_getInputs(e,n=void 0){void 0===n&&(n=[]);for(const t of e)if(t.type instanceof ke)this._getStructInputs(t.type,n);else{const e=this._getInputInfo(t);null!==e&&n.push(e)}return n}_getStructInputs(e,n){for(const t of e.members)if(t.type instanceof ke)this._getStructInputs(t.type,n);else{const e=this._getInputInfo(t);null!==e&&n.push(e)}}_getInputInfo(e){const n=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==n){const t=this._getAttribute(e,"interpolation"),o=this._getTypeInfo(e.type,e.attributes),r=this._parseInt(n.value),i=new un(e.name,o,n.name,r);return null!==t&&(i.interpolation=this._parseString(t.value)),i}return null}_parseString(e){return e instanceof Array&&(e=e[0]),e}_parseInt(e){e instanceof Array&&(e=e[0]);const n=parseInt(e);return isNaN(n)?e:n}_getAlias(e){for(const n of this.aliases)if(n.name==e)return n.type;return null}_getAliasInfo(e){return new ln(e.name,this._getTypeInfo(e.type,null))}_getTypeInfo(e,n){if(this._types.has(e))return this._types.get(e);if(e instanceof Ie){const t=e,o=this._getTypeInfo(t.format,t.attributes),r=new rn(t.name,n);return r.format=o,r.count=t.count,this._types.set(e,r),this._updateTypeInfo(r),r}if(e instanceof ke){const t=e,o=new on(t.name,n);for(const e of t.members){const n=this._getTypeInfo(e.type,e.attributes);o.members.push(new tn(e.name,n,e.attributes))}return this._types.set(e,o),this._updateTypeInfo(o),o}if(e instanceof Ne){const t=e,o=t.format instanceof we,r=t.format?o?this._getTypeInfo(t.format,null):new nn(t.format,null):null,i=new sn(t.name,r,n,t.access);return this._types.set(e,i),this._updateTypeInfo(i),i}if(e instanceof Le){const t=e,o=t.format?this._getTypeInfo(t.format,null):null,r=new sn(t.name,o,n,t.access);return this._types.set(e,r),this._updateTypeInfo(r),r}const t=new nn(e.name,n);return this._types.set(e,t),this._updateTypeInfo(t),t}_updateTypeInfo(e){var n,t;const o=this._getTypeSize(e);if(e.size=null!==(n=null==o?void 0:o.size)&&void 0!==n?n:0,e instanceof rn){const n=this._getTypeSize(e.format);e.stride=null!==(t=null==n?void 0:n.size)&&void 0!==t?t:0,this._updateTypeInfo(e.format)}e instanceof on&&this._updateStructInfo(e)}_updateStructInfo(e){var n;let t=0,o=0,r=0,i=0;for(let s=0,a=e.members.length;s<a;++s){const a=e.members[s],l=this._getTypeSize(a);if(!l)continue;null!==(n=this._getAlias(a.type.name))&&void 0!==n||a.type;const c=l.align,u=l.size;t=this._roundUp(c,t+o),o=u,r=t,i=Math.max(i,c),a.offset=t,a.size=u,this._updateTypeInfo(a.type)}e.size=this._roundUp(i,r+o),e.align=i}_getTypeSize(e){var n;if(null==e)return null;const t=this._getAttributeNum(e.attributes,"size",0),o=this._getAttributeNum(e.attributes,"align",0);if(e instanceof tn&&(e=e.type),e instanceof nn){const n=this._getAlias(e.name);null!==n&&(e=n)}{const n=hn._typeInfo[e.name];if(void 0!==n){const r="f16"===e.format?2:1;return new cn(Math.max(o,n.align/r),Math.max(t,n.size/r))}}{const n=hn._typeInfo[e.name.substring(0,e.name.length-1)];if(n){const r="h"===e.name[e.name.length-1]?2:1;return new cn(Math.max(o,n.align/r),Math.max(t,n.size/r))}}if(e instanceof rn){let r=e,i=8,s=8;const a=this._getTypeSize(r.format);null!==a&&(s=a.size,i=a.align);return s=r.count*this._getAttributeNum(null!==(n=null==e?void 0:e.attributes)&&void 0!==n?n:null,"stride",this._roundUp(i,s)),t&&(s=t),new cn(Math.max(o,i),Math.max(t,s))}if(e instanceof on){let n=0,r=0,i=0,s=0,a=0;for(const t of e.members){const e=this._getTypeSize(t.type);null!==e&&(n=Math.max(e.align,n),i=this._roundUp(e.align,i+s),s=e.size,a=i)}return r=this._roundUp(n,a+s),new cn(Math.max(o,n),Math.max(t,r))}return null}_isUniformVar(e){return e instanceof oe&&"uniform"==e.storage}_isStorageVar(e){return e instanceof oe&&"storage"==e.storage}_isTextureVar(e){return e instanceof oe&&null!==e.type&&-1!=hn._textureTypes.indexOf(e.type.name)}_isSamplerVar(e){return e instanceof oe&&null!==e.type&&-1!=hn._samplerTypes.indexOf(e.type.name)}_getAttribute(e,n){const t=e;if(!t||!t.attributes)return null;const o=t.attributes;for(let e of o)if(e.name==n)return e;return null}_getAttributeNum(e,n,t){if(null===e)return t;for(let o of e)if(o.name==n){let e=null!==o&&null!==o.value?o.value:t;return e instanceof Array&&(e=e[0]),"number"==typeof e?e:"string"==typeof e?parseInt(e):t}return t}_roundUp(e,n){return Math.ceil(n/e)*e}}function mn(n){const t={attributes:[],bindings:[]};let o;try{o=function(e){try{return new hn(e)}catch(e){if(e instanceof Error)throw e;let n="WGSL parse error";throw"object"==typeof e&&e?.message&&(n+=`: ${e.message} `),"object"==typeof e&&e?.token&&(n+=e.token.line||""),new Error(n,{cause:e})}}(n)}catch(n){return e.error(n.message)(),t}for(const e of o.uniforms){const n=[];for(const t of e.type.members)n.push({name:t.name,type:gn(t.type)});t.bindings.push({type:"uniform",name:e.name,location:e.binding,group:e.group,members:n})}const r=o.entry.vertex[0],i=r?.inputs.length||0;for(let e=0;e<i;e++){const n=r.inputs[e];if("location"===n.locationType){const e=gn(n.type);t.attributes.push({name:n.name,location:n.location,type:e})}}return t}function gn(e){return e.format?`${e.name}<${e.format.name}>`:e.name}hn._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}},hn._textureTypes=Ke.any_texture_type.map((e=>e.name)),hn._samplerTypes=Ke.sampler_type.map((e=>e.name));const vn={name:"random",fs:"float random(vec3 scale, float seed) {\nreturn fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n"},xn={name:"fp32",vs:"#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\nfloat sin_taylor_fp32(float a) {\nfloat r, s, t, x;\nif (a == 0.0) {\nreturn 0.0;\n}\nx = -a * a;\ns = a;\nr = a;\nr = r * x;\nt = r * INVERSE_FACTORIAL_3;\ns = s + t;\nr = r * x;\nt = r * INVERSE_FACTORIAL_5;\ns = s + t;\nr = r * x;\nt = r * INVERSE_FACTORIAL_7;\ns = s + t;\nr = r * x;\nt = r * INVERSE_FACTORIAL_9;\ns = s + t;\nreturn s;\n}\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\nif (a == 0.0) {\nsin_t = 0.0;\ncos_t = 1.0;\n}\nsin_t = sin_taylor_fp32(a);\ncos_t = sqrt(1.0 - sin_t * sin_t);\n}\nfloat tan_taylor_fp32(float a) {\nfloat sin_a;\nfloat cos_a;\nif (a == 0.0) {\nreturn 0.0;\n}\nfloat z = floor(a / TWO_PI);\nfloat r = a - TWO_PI * z;\nfloat t;\nfloat q = floor(r / PI_2 + 0.5);\nint j = int(q);\nif (j < -2 || j > 2) {\nreturn 1.0 / 0.0;\n}\nt = r - PI_2 * q;\nq = floor(t / PI_16 + 0.5);\nint k = int(q);\nint abs_k = int(abs(float(k)));\nif (abs_k > 4) {\nreturn 1.0 / 0.0;\n} else {\nt = t - PI_16 * q;\n}\nfloat u = 0.0;\nfloat v = 0.0;\nfloat sin_t, cos_t;\nfloat s, c;\nsincos_taylor_fp32(t, sin_t, cos_t);\nif (k == 0) {\ns = sin_t;\nc = cos_t;\n} else {\nif (abs(float(abs_k) - 1.0) < 0.5) {\nu = COS_TABLE_0;\nv = SIN_TABLE_0;\n} else if (abs(float(abs_k) - 2.0) < 0.5) {\nu = COS_TABLE_1;\nv = SIN_TABLE_1;\n} else if (abs(float(abs_k) - 3.0) < 0.5) {\nu = COS_TABLE_2;\nv = SIN_TABLE_2;\n} else if (abs(float(abs_k) - 4.0) < 0.5) {\nu = COS_TABLE_3;\nv = SIN_TABLE_3;\n}\nif (k > 0) {\ns = u * sin_t + v * cos_t;\nc = u * cos_t - v * sin_t;\n} else {\ns = u * sin_t - v * cos_t;\nc = u * cos_t + v * sin_t;\n}\n}\nif (j == 0) {\nsin_a = s;\ncos_a = c;\n} else if (j == 1) {\nsin_a = c;\ncos_a = -s;\n} else if (j == -1) {\nsin_a = -c;\ncos_a = s;\n} else {\nsin_a = -s;\ncos_a = -c;\n}\nreturn sin_a / cos_a;\n}\n#endif\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nreturn tan_taylor_fp32(a);\n#else\nreturn tan(a);\n#endif\n}\n"},bn=new Float32Array([0,1,1,1]),An={name:"picking",vs:"uniform pickingUniforms {\nfloat isActive;\nfloat isAttribute;\nfloat isHighlightActive;\nfloat useFloatColors;\nvec3 highlightedObjectColor;\nvec4 highlightColor;\n} picking;\nout vec4 picking_vRGBcolor_Avalid;\nvec3 picking_normalizeColor(vec3 color) {\nreturn picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\nvec4 picking_normalizeColor(vec4 color) {\nreturn picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\nbool picking_isColorZero(vec3 color) {\nreturn dot(color, vec3(1.0)) < 0.00001;\n}\nbool picking_isColorValid(vec3 color) {\nreturn dot(color, vec3(1.0)) > 0.00001;\n}\nbool isVertexHighlighted(vec3 vertexColor) {\nvec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\nreturn\nbool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\nvoid picking_setPickingColor(vec3 pickingColor) {\npickingColor = picking_normalizeColor(pickingColor);\nif (bool(picking.isActive)) {\npicking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\nif (!bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.rgb = pickingColor;\n}\n} else {\npicking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n}\n}\nvoid picking_setPickingAttribute(float value) {\nif (bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.r = value;\n}\n}\nvoid picking_setPickingAttribute(vec2 value) {\nif (bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.rg = value;\n}\n}\nvoid picking_setPickingAttribute(vec3 value) {\nif (bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.rgb = value;\n}\n}\n",fs:"uniform pickingUniforms {\nfloat isActive;\nfloat isAttribute;\nfloat isHighlightActive;\nfloat useFloatColors;\nvec3 highlightedObjectColor;\nvec4 highlightColor;\n} picking;\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\nif (picking.isActive > 0.5) {\nreturn color;\n}\nbool selected = bool(picking_vRGBcolor_Avalid.a);\nif (selected) {\nfloat highLightAlpha = picking.highlightColor.a;\nfloat blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\nfloat highLightRatio = highLightAlpha / blendedAlpha;\nvec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\nreturn vec4(blendedRGB, blendedAlpha);\n} else {\nreturn color;\n}\n}\nvec4 picking_filterPickingColor(vec4 color) {\nif (bool(picking.isActive)) {\nif (picking_vRGBcolor_Avalid.a == 0.0) {\ndiscard;\n}\nreturn picking_vRGBcolor_Avalid;\n}\nreturn color;\n}\nvec4 picking_filterColor(vec4 color) {\nvec4 highlightColor = picking_filterHighlightColor(color);\nreturn picking_filterPickingColor(highlightColor);\n}\n",uniformTypes:{isActive:"f32",isAttribute:"f32",isHighlightActive:"f32",useFloatColors:"f32",highlightedObjectColor:"vec3<f32>",highlightColor:"vec4<f32>"},defaultUniforms:{isActive:!1,isAttribute:!1,isHighlightActive:!1,useFloatColors:!0,highlightedObjectColor:new Float32Array([0,0,0]),highlightColor:bn},getUniforms:function(e={},n){const t={};if(void 0===e.highlightedObjectColor);else if(null===e.highlightedObjectColor)t.isHighlightActive=!1;else{t.isHighlightActive=!0;const n=e.highlightedObjectColor.slice(0,3);t.highlightedObjectColor=n}if(e.highlightColor){const n=Array.from(e.highlightColor,(e=>e/255));Number.isFinite(n[3])||(n[3]=1),t.highlightColor=n}void 0!==e.isActive&&(t.isActive=Boolean(e.isActive),t.isAttribute=Boolean(e.isAttribute));void 0!==e.useFloatColors&&(t.useFloatColors=Boolean(e.useFloatColors));return t}};const yn="precision highp int;\nstruct AmbientLight {\nvec3 color;\n};\nstruct PointLight {\nvec3 color;\nvec3 position;\nvec3 attenuation;\n};\nstruct DirectionalLight {\nvec3 color;\nvec3 direction;\n};\nuniform lightingUniforms {\nint enabled;\nint pointLightCount;\nint directionalLightCount;\nvec3 ambientColor;\nint lightType;\nvec3 lightColor;\nvec3 lightDirection;\nvec3 lightPosition;\nvec3 lightAttenuation;\n} lighting;\nPointLight lighting_getPointLight(int index) {\nreturn PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);\n}\nDirectionalLight lighting_getDirectionalLight(int index) {\nreturn DirectionalLight(lighting.lightColor, lighting.lightDirection);\n}\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\nreturn pointLight.attenuation.x\n+ pointLight.attenuation.y * distance\n+ pointLight.attenuation.z * distance * distance;\n}\n",Pn=255;var wn;!function(e){e[e.POINT=0]="POINT",e[e.DIRECTIONAL=1]="DIRECTIONAL"}(wn||(wn={}));const kn={name:"lighting",vs:yn,fs:yn,getUniforms:(e,n)=>function(e,n={}){if(e=e?{...e}:e,!e)return{...kn.defaultUniforms};e.lights&&(e={...e,...Fn(e.lights),lights:void 0});const{ambientLight:t,pointLights:o,directionalLights:r}=e||{};if(!(t||o&&o.length>0||r&&r.length>0))return{...kn.defaultUniforms,enabled:0};const i={...kn.defaultUniforms,...n,...Ln({ambientLight:t,pointLights:o,directionalLights:r})};void 0!==e.enabled&&(i.enabled=e.enabled?1:0);return i}(e),defines:{MAX_LIGHTS:5},uniformTypes:{enabled:"i32",ambientLightColor:"vec3<f32>",numberOfLights:"i32",lightType:"i32",lightColor:"vec3<f32>",lightPosition:"vec3<f32>",lightDirection:"vec3<f32>",lightAttenuation:"vec3<f32>"},defaultUniforms:{enabled:1,ambientLightColor:[.1,.1,.1],numberOfLights:0,lightType:wn.POINT,lightColor:[1,1,1],lightPosition:[1,1,2],lightDirection:[1,1,1],lightAttenuation:[1,1,1]}};function Ln({ambientLight:e,pointLights:n=[],directionalLights:t=[]}){const o={};o.ambientLightColor=In(e);let r=0;for(const e of n)o.lightType=wn.POINT,o.lightColor=In(e),o.lightPosition=e.position,o.lightAttenuation=[e.attenuation||1,0,0],r++;for(const e of t)o.lightType=wn.DIRECTIONAL,o.lightColor=In(e),o.lightPosition=e.position,o.lightDirection=e.direction,r++;return o.numberOfLights=r,o}function Fn(e){const n={pointLights:[],directionalLights:[]};for(const t of e||[])switch(t.type){case"ambient":n.ambientLight=t;break;case"directional":n.directionalLights?.push(t);break;case"point":n.pointLights?.push(t)}return n}function In(e={}){const{color:n=[0,0,0],intensity:t=1}=e;return n.map((e=>e*t/Pn))}const Nn={name:"dirlight",dependencies:[],vs:"out vec3 dirlight_vNormal;\nvoid dirlight_setNormal(vec3 normal) {\ndirlight_vNormal = normalize(normal);\n}\n",fs:"uniform dirlightUniforms {\nvec3 lightDirection;\n} dirlight;\nin vec3 dirlight_vNormal;\nvec4 dirlight_filterColor(vec4 color) {\nfloat d = abs(dot(dirlight_vNormal, normalize(dirlight.lightDirection)));\nreturn vec4(color.rgb * d, color.a);\n}\n",uniformTypes:{lightDirection:"vec3<f32>"},defaultUniforms:{lightDirection:new Float32Array([1,1,2])},getUniforms:function(e=Nn.defaultUniforms){const n={};e.lightDirection&&(n.dirlight_uLightDirection=e.lightDirection);return n}};const Tn={name:"gouraud-lighting",vs:"uniform materialUniforms {\nuniform float ambient;\nuniform float diffuse;\nuniform float shininess;\nuniform vec3  specularColor;\n} material;\n",fs:"uniform materialUniforms {\nuniform float ambient;\nuniform float diffuse;\nuniform float shininess;\nuniform vec3  specularColor;\n} material;\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\nvec3 halfway_direction = normalize(light_direction + view_direction);\nfloat lambertian = dot(light_direction, normal_worldspace);\nfloat specular = 0.0;\nif (lambertian > 0.0) {\nfloat specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\nspecular = pow(specular_angle, material.shininess);\n}\nlambertian = max(lambertian, 0.0);\nreturn (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;\n}\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\nvec3 lightColor = surfaceColor;\nif (lighting.enabled) {\nvec3 view_direction = normalize(cameraPosition - position_worldspace);\nlightColor = material.ambient * surfaceColor * lighting.ambientColor;\nif (lighting.lightType == 0) {\nPointLight pointLight = lighting_getPointLight(0);\nvec3 light_position_worldspace = pointLight.position;\nvec3 light_direction = normalize(light_position_worldspace - position_worldspace);\nlightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n} else if (lighting.lightType == 1) {\nDirectionalLight directionalLight = lighting_getDirectionalLight(0);\nlightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n}\n}\nreturn lightColor;\n}\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\nvec3 lightColor = vec3(0, 0, 0);\nvec3 surfaceColor = vec3(0, 0, 0);\nif (lighting.enabled) {\nvec3 view_direction = normalize(cameraPosition - position_worldspace);\nswitch (lighting.lightType) {\ncase 0:\nPointLight pointLight = lighting_getPointLight(0);\nvec3 light_position_worldspace = pointLight.position;\nvec3 light_direction = normalize(light_position_worldspace - position_worldspace);\nlightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\nbreak;\ncase 1:\nDirectionalLight directionalLight = lighting_getDirectionalLight(0);\nlightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\nbreak;\n}\n}\nreturn lightColor;\n}\n",defines:{LIGHTING_VERTEX:1},dependencies:[kn],uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms:e=>({...Tn.defaultUniforms,...e})},Sn={name:"phong-lighting",vs:"uniform phongMaterialUniforms {\nuniform float ambient;\nuniform float diffuse;\nuniform float shininess;\nuniform vec3  specularColor;\n} material;\n",fs:"uniform phongMaterialUniforms {\nuniform float ambient;\nuniform float diffuse;\nuniform float shininess;\nuniform vec3  specularColor;\n} material;\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\nvec3 halfway_direction = normalize(light_direction + view_direction);\nfloat lambertian = dot(light_direction, normal_worldspace);\nfloat specular = 0.0;\nif (lambertian > 0.0) {\nfloat specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\nspecular = pow(specular_angle, material.shininess);\n}\nlambertian = max(lambertian, 0.0);\nreturn (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;\n}\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\nvec3 lightColor = surfaceColor;\nif (lighting.enabled == 0) {\nreturn lightColor;\n}\nvec3 view_direction = normalize(cameraPosition - position_worldspace);\nlightColor = material.ambient * surfaceColor * lighting.ambientColor;\nif (lighting.lightType == 0) {\nPointLight pointLight = lighting_getPointLight(0);\nvec3 light_position_worldspace = pointLight.position;\nvec3 light_direction = normalize(light_position_worldspace - position_worldspace);\nlightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n} else if (lighting.lightType == 1) {\nDirectionalLight directionalLight = lighting_getDirectionalLight(0);\nlightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n}\nreturn lightColor;\n}\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\nvec3 lightColor = vec3(0, 0, 0);\nvec3 surfaceColor = vec3(0, 0, 0);\nif (lighting.enabled == 0) {\nvec3 view_direction = normalize(cameraPosition - position_worldspace);\nswitch (lighting.lightType) {\ncase 0:\nPointLight pointLight = lighting_getPointLight(0);\nvec3 light_position_worldspace = pointLight.position;\nvec3 light_direction = normalize(light_position_worldspace - position_worldspace);\nlightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\nbreak;\ncase 1:\nDirectionalLight directionalLight = lighting_getDirectionalLight(0);\nlightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\nbreak;\n}\n}\nreturn lightColor;\n}\n",defines:{LIGHTING_FRAGMENT:1},dependencies:[kn],uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms:e=>({...Sn.defaultUniforms,...e})},En={name:"pbr",vs:"uniform projection {\nmat4 u_MVPMatrix;\nmat4 u_ModelMatrix;\nmat4 u_NormalMatrix;\nvec3 u_Camera;\n}\nvarying vec3 pbr_vPosition;\nvarying vec2 pbr_vUV;\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n# else\nvarying vec3 pbr_vNormal;\n# endif\n#endif\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\nvec4 pos = u_ModelMatrix * position;\npbr_vPosition = vec3(pos.xyz) / pos.w;\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\nvec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\nvec3 bitangentW = cross(normalW, tangentW) * tangent.w;\npbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else\npbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n#ifdef HAS_UV\npbr_vUV = uv;\n#else\npbr_vUV = vec2(0.,0.);\n#endif\n}\n",fs:"precision highp float;\nuniform Projection {\nuniform vec3 u_Camera;\n};\nuniform pbrMaterial {\nbool unlit;\nbool baseColorMapEnabled;\nvec4 baseColorFactor;\nbool normalMapEnabled;\nfloat normalScale;\nbool emissiveMapEnabled;\nvec3 emissiveFactor;\nvec2 metallicRoughnessValues;\nbool metallicRoughnessMapEnabled;\nbool occlusionMapEnabled;\nfloat occlusionStrength;\nbool alphaCutoffEnabled;\nfloat alphaCutoff;\nbool IBLenabled;\nvec2 scaleIBLAmbient;\nvec4 scaleDiffBaseMR;\nvec4 scaleFGDSpec;\n} u_pbrMaterial;\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\n#endif\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\n#endif\nvarying vec3 pbr_vPosition;\nvarying vec2 pbr_vUV;\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n#else\nvarying vec3 pbr_vNormal;\n#endif\n#endif\nstruct PBRInfo {\nfloat NdotL;\nfloat NdotV;\nfloat NdotH;\nfloat LdotH;\nfloat VdotH;\nfloat perceptualRoughness;\nfloat metalness;\nvec3 reflectance0;\nvec3 reflectance90;\nfloat alphaRoughness;\nvec3 diffuseColor;\nvec3 specularColor;\nvec3 n;\nvec3 v;\n};\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\nvec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else\nvec3 bLess = step(vec3(0.04045),srgbIn.xyz);\nvec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif\nreturn vec4(linOut,srgbIn.w);;\n#else\nreturn srgbIn;\n#endif\n}\nvec3 getNormal()\n{\n#ifndef HAS_TANGENTS\nvec3 pos_dx = dFdx(pbr_vPosition);\nvec3 pos_dy = dFdy(pbr_vPosition);\nvec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\nvec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\nvec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n#ifdef HAS_NORMALS\nvec3 ng = normalize(pbr_vNormal);\n#else\nvec3 ng = cross(pos_dx, pos_dy);\n#endif\nt = normalize(t - ng * dot(ng, t));\nvec3 b = normalize(cross(ng, t));\nmat3 tbn = mat3(t, b, ng);\n#else\nmat3 tbn = pbr_vTBN;\n#endif\n#ifdef HAS_NORMALMAP\nvec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;\nn = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_pbrMaterial.normalScale, u_pbrMaterial.normalScale, 1.0)));\n#else\nvec3 n = normalize(tbn[2].xyz);\n#endif\nreturn n;\n}\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection)\n{\nfloat mipCount = 9.0;\nfloat lod = (pbrInfo.perceptualRoughness * mipCount);\nvec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,\nvec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;\nvec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n#ifdef USE_TEX_LOD\nvec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\nvec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\nvec3 diffuse = diffuseLight * pbrInfo.diffuseColor;\nvec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);\ndiffuse *= u_pbrMaterial.scaleIBLAmbient.x;\nspecular *= u_pbrMaterial.scaleIBLAmbient.y;\nreturn diffuse + specular;\n}\n#endif\nvec3 diffuse(PBRInfo pbrInfo)\n{\nreturn pbrInfo.diffuseColor / M_PI;\n}\nvec3 specularReflection(PBRInfo pbrInfo)\n{\nreturn pbrInfo.reflectance0 +\n(pbrInfo.reflectance90 - pbrInfo.reflectance0) *\npow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);\n}\nfloat geometricOcclusion(PBRInfo pbrInfo)\n{\nfloat NdotL = pbrInfo.NdotL;\nfloat NdotV = pbrInfo.NdotV;\nfloat r = pbrInfo.alphaRoughness;\nfloat attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\nfloat attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\nreturn attenuationL * attenuationV;\n}\nfloat microfacetDistribution(PBRInfo pbrInfo)\n{\nfloat roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;\nfloat f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;\nreturn roughnessSq / (M_PI * f * f);\n}\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInfo) {\npbrInfo.NdotL = 1.0;\npbrInfo.NdotH = 0.0;\npbrInfo.LdotH = 0.0;\npbrInfo.VdotH = 1.0;\n}\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInfo, vec3 lightDirection) {\nvec3 n = pbrInfo.n;\nvec3 v = pbrInfo.v;\nvec3 l = normalize(lightDirection);\nvec3 h = normalize(l+v);\npbrInfo.NdotL = clamp(dot(n, l), 0.001, 1.0);\npbrInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);\npbrInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);\npbrInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInfo, PointLight pointLight) {\nvec3 light_direction = normalize(pointLight.position - pbr_vPosition);\nPBRInfo_setDirectionalLight(pbrInfo, light_direction);\n}\nvec3 calculateFinalColor(PBRInfo pbrInfo, vec3 lightColor) {\nvec3 F = specularReflection(pbrInfo);\nfloat G = geometricOcclusion(pbrInfo);\nfloat D = microfacetDistribution(pbrInfo);\nvec3 diffuseContrib = (1.0 - F) * diffuse(pbrInfo);\nvec3 specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);\nreturn pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);\n}\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n#ifdef HAS_BASECOLORMAP\nvec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_pbrMaterial.baseColorFactor;\n#else\nvec4 baseColor = u_pbrMaterial.baseColorFactor;\n#endif\n#ifdef ALPHA_CUTOFF\nif (baseColor.a < u_pbrMaterial.alphaCutoff) {\ndiscard;\n}\n#endif\nvec3 color = vec3(0, 0, 0);\nif(u_pbrMaterial.unlit){\ncolor.rgb = baseColor.rgb;\n}\nelse{\nfloat perceptualRoughness = u_pbrMaterial.metallicRoughnessValues.y;\nfloat metallic = u_pbrMaterial.metallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\nvec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);\nperceptualRoughness = mrSample.g * perceptualRoughness;\nmetallic = mrSample.b * metallic;\n#endif\nperceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\nmetallic = clamp(metallic, 0.0, 1.0);\nfloat alphaRoughness = perceptualRoughness * perceptualRoughness;\nvec3 f0 = vec3(0.04);\nvec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\ndiffuseColor *= 1.0 - metallic;\nvec3 specularColor = mix(f0, baseColor.rgb, metallic);\nfloat reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\nfloat reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\nvec3 specularEnvironmentR0 = specularColor.rgb;\nvec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\nvec3 n = getNormal();\nvec3 v = normalize(u_Camera - pbr_vPosition);\nfloat NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\nvec3 reflection = -normalize(reflect(v, n));\nPBRInfo pbrInfo = PBRInfo(\n0.0,\nNdotV,\n0.0,\n0.0,\n0.0,\nperceptualRoughness,\nmetallic,\nspecularEnvironmentR0,\nspecularEnvironmentR90,\nalphaRoughness,\ndiffuseColor,\nspecularColor,\nn,\nv\n);\n#ifdef USE_LIGHTS\nPBRInfo_setAmbientLight(pbrInfo);\ncolor += calculateFinalColor(pbrInfo, lighting_uAmbientLight.color);\nfor(int i = 0; i < lighting_uDirectionalLightCount; i++) {\nif (i < lighting_uDirectionalLightCount) {\nPBRInfo_setDirectionalLight(pbrInfo, lighting_uDirectionalLight[i].direction);\ncolor += calculateFinalColor(pbrInfo, lighting_uDirectionalLight[i].color);\n}\n}\nfor(int i = 0; i < lighting_uPointLightCount; i++) {\nif (i < lighting_uPointLightCount) {\nPBRInfo_setPointLight(pbrInfo, lighting_uPointLight[i]);\nfloat attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\ncolor += calculateFinalColor(pbrInfo, lighting_uPointLight[i].color / attenuation);\n}\n}\n#endif\n#ifdef USE_IBL\nif (u_pbrMateral.IBLEnabled) {\ncolor += getIBLContribution(pbrInfo, n, reflection);\n}\n#endif\n#ifdef HAS_OCCLUSIONMAP\nif (u_pbrMaterial.occlusionMapEnabled) {\nfloat ao = texture2D(u_OcclusionSampler, pbr_vUV).r;\ncolor = mix(color, color * ao, u_pbrMaterial.occlusionStrength);\n}\n#endif\n#ifdef HAS_EMISSIVEMAP\nif (u_pbrMaterial.emmissiveMapEnabled) {\nvec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_pbrMaterial.emissiveFactor;\ncolor += emissive;\n}\n#endif\n#ifdef PBR_DEBUG\ncolor = mix(color, baseColor.rgb, u_pbrMaterial.scaleDiffBaseMR.y);\ncolor = mix(color, vec3(metallic), u_pbrMaterial.scaleDiffBaseMR.z);\ncolor = mix(color, vec3(perceptualRoughness), u_pbrMaterial.scaleDiffBaseMR.w);\n#endif\n}\nreturn vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n",defines:{LIGHTING_FRAGMENT:1,HAS_NORMALMAP:0,HAS_EMISSIVEMAP:0,HAS_OCCLUSIONMAP:0,HAS_BASECOLORMAP:0,HAS_METALROUGHNESSMAP:0,ALPHA_CUTOFF:0,USE_IBL:0,PBR_DEBUG:0},uniformTypes:{unlit:"i32",baseColorMapEnabled:"i32",baseColorFactor:"vec4<f32>",normalMapEnabled:"i32",normalScale:"f32",emissiveMapEnabled:"i32",emissiveFactor:"vec3<f32>",metallicRoughnessValues:"vec2<f32>",metallicRoughnessMapEnabled:"i32",occlusionMapEnabled:"i32",occlusionStrength:"f32",alphaCutoffEnabled:"i32",alphaCutoff:"f32",IBLenabled:"i32",scaleIBLAmbient:"vec2<f32>",scaleDiffBaseMR:"vec4<f32>",scaleFGDSpec:"vec4<f32>"},bindings:{baseColorSampler:{type:"texture",location:8},normalSampler:{type:"texture",location:9},emissiveSampler:{type:"texture",location:10},metallicRoughnessSampler:{type:"texture",location:11},occlusionSampler:{type:"texture",location:12},diffuseEnvSampler:{type:"texture",location:13},specularEnvSampler:{type:"texture",location:14},brdfLUT:{type:"texture",location:15}},dependencies:[kn]},Cn={name:"brightnessContrast",uniformTypes:{brightness:"f32",contrast:"f32"},uniformPropTypes:{brightness:{format:"f32",value:0,min:-1,max:1},contrast:{format:"f32",value:0,min:-1,max:1}},fs:"uniform brightnessContrastUniforms {\nfloat brightness;\nfloat contrast;\n} brightnessContrast;\nvec4 brightnessContrast_filterColor(vec4 color) {\ncolor.rgb += brightnessContrast.brightness;\nif (brightnessContrast.contrast > 0.0) {\ncolor.rgb = (color.rgb - 0.5) / (1.0 - brightnessContrast.contrast) + 0.5;\n} else {\ncolor.rgb = (color.rgb - 0.5) * (1.0 + brightnessContrast.contrast) + 0.5;\n}\nreturn color;\n}\nvec4 brightnessContrast_filterColor(vec4 color, vec2 texSize, vec2 texCoords) {\nreturn brightnessContrast_filterColor(color);\n}\n",passes:[{filter:!0}]},Un={name:"denoise",uniformTypes:{strength:"f32"},uniformPropTypes:{strength:{format:"f32",value:.5,min:0,max:1}},fs:"uniform denoiseUniforms {\nfloat strength;\n} noise;\nvec4 denoise_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\nfloat adjustedExponent = 3. + 200. * pow(1. - noise.strength, 4.);\nvec4 center = texture(source, texCoord);\nvec4 color = vec4(0.0);\nfloat total = 0.0;\nfor (float x = -4.0; x <= 4.0; x += 1.0) {\nfor (float y = -4.0; y <= 4.0; y += 1.0) {\nvec4 offsetColor = texture(source, texCoord + vec2(x, y) / texSize);\nfloat weight = 1.0 - abs(dot(offsetColor.rgb - center.rgb, vec3(0.25)));\nweight = pow(weight, adjustedExponent);\ncolor += offsetColor * weight;\ntotal += weight;\n}\n}\nreturn color / total;\n}\n",passes:[{sampler:!0},{sampler:!0}]},Mn={name:"hueSaturation",uniformTypes:{hue:"f32",saturation:"f32"},uniformPropTypes:{hue:{value:0,min:-1,max:1},saturation:{value:0,min:-1,max:1}},fs:"uniform hueSaturationUniforms {\nfloat hue;\nfloat saturation;\n} hueSaturation;\nvec4 hueSaturation_filterColor(vec4 color) {\nfloat angle = hueSaturation.hue * 3.14159265;\nfloat s = sin(angle), c = cos(angle);\nvec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\nfloat len = length(color.rgb);\ncolor.rgb = vec3(\ndot(color.rgb, weights.xyz),\ndot(color.rgb, weights.zxy),\ndot(color.rgb, weights.yzx)\n);\nfloat average = (color.r + color.g + color.b) / 3.0;\nif (hueSaturation.saturation > 0.0) {\ncolor.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - hueSaturation.saturation));\n} else {\ncolor.rgb += (average - color.rgb) * (-hueSaturation.saturation);\n}\nreturn color;\n}\nvec4 hueSaturation_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\nreturn hueSaturation_filterColor(color);\n}\n",passes:[{filter:!0}]},Rn={name:"noise",uniformTypes:{amount:"f32"},uniformPropTypes:{amount:{value:.5,min:0,max:1}},fs:"uniform noiseUniforms {\nfloat amount;\n} noise;\nfloat rand(vec2 co) {\nreturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec4 noise_filterColor(vec4 color, vec2 texCoord) {\nfloat diff = (rand(texCoord) - 0.5) * noise.amount;\ncolor.r += diff;\ncolor.g += diff;\ncolor.b += diff;\nreturn color;\n}\nvec4 noise_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\nreturn noise_filterColor(color, texCoord);\n}\n",passes:[{filter:!0}]},On={name:"sepia",uniformTypes:{amount:"f32"},uniformPropTypes:{amount:{value:.5,min:0,max:1}},fs:"uniform sepiaUniforms {\nfloat amount;\n} sepia;\nvec4 sepia_filterColor(vec4 color) {\nfloat r = color.r;\nfloat g = color.g;\nfloat b = color.b;\ncolor.r =\nmin(1.0, (r * (1.0 - (0.607 * sepia.amount))) + (g * (0.769 * sepia.amount)) + (b * (0.189 * sepia.amount)));\ncolor.g = min(1.0, (r * 0.349 * sepia.amount) + (g * (1.0 - (0.314 * sepia.amount))) + (b * 0.168 * sepia.amount));\ncolor.b = min(1.0, (r * 0.272 * sepia.amount) + (g * 0.534 * sepia.amount) + (b * (1.0 - (0.869 * sepia.amount))));\nreturn color;\n}\nvec4 sepia_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\nreturn sepia_filterColor(color);\n}\n",passes:[{filter:!0}]},Xn={name:"vibrance",uniformPropTypes:{amount:{value:0,min:-1,max:1}},fs:"uniform vibranceUniforms {\nfloat amount;\n} vibrance;\nvec4 vibrance_filterColor(vec4 color) {\nfloat average = (color.r + color.g + color.b) / 3.0;\nfloat mx = max(color.r, max(color.g, color.b));\nfloat amt = (mx - average) * (-vibrance.amount * 3.0);\ncolor.rgb = mix(color.rgb, vec3(mx), amt);\nreturn color;\n}\nvec4 vibrance_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\nreturn vibrance_filterColor(color);\n}\n",passes:[{filter:!0}]},zn={name:"vignette",fs:"uniform vignetteUniforms {\nfloat radius;\nfloat amount;\n} vignette;\nvec4 vignette_filterColor(vec4 color, vec2 texCoord) {\nfloat dist = distance(texCoord, vec2(0.5, 0.5));\nfloat ratio = smoothstep(0.8, vignette.radius * 0.799, dist * (vignette.amount + vignette.radius));\nreturn color.rgba * ratio + (1.0 - ratio)*vec4(0.0, 0.0, 0.0, 1.0);\n}\nvec4 vignette_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\nreturn vignette_filterColor(color, texCoord);\n}\n",uniformTypes:{radius:"f32",amount:"f32"},uniformPropTypes:{radius:{value:.5,min:0,max:1},amount:{value:.5,min:0,max:1}},passes:[{filter:!0}]},Bn={name:"tiltShift",uniformTypes:{blurRadius:"f32",gradientRadius:"f32",start:"vec2<f32>",end:"vec2<f32>",invert:"i32"},uniformPropTypes:{blurRadius:{value:15,min:0,max:50},gradientRadius:{value:200,min:0,max:400},start:{value:[0,0]},end:{value:[1,1]},invert:{value:!1,private:!0}},passes:[{sampler:!0,uniforms:{invert:!1}},{sampler:!0,uniforms:{invert:!0}}],dependencies:[vn],fs:"uniform tiltShiftUniforms {\nfloat blurRadius;\nfloat gradientRadius;\nvec2 start;\nvec2 end;\nbool invert;\n} tiltShift;\nvec2 tiltShift_getDelta(vec2 texSize) {\nvec2 vector = normalize((tiltShift.end - tiltShift.start) * texSize);\nreturn tiltShift.invert ? vec2(-vector.y, vector.x) : vector;\n}\nvec4 tiltShift_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\nvec4 color = vec4(0.0);\nfloat total = 0.0;\nfloat offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\nvec2 normal = normalize(vec2((tiltShift.start.y - tiltShift.end.y) * texSize.y, (tiltShift.end.x - tiltShift.start.x) * texSize.x));\nfloat radius = smoothstep(0.0, 1.0,\nabs(dot(texCoord * texSize - tiltShift.start * texSize, normal)) / tiltShift.gradientRadius) * tiltShift.blurRadius;\nfor (float t = -30.0; t <= 30.0; t++) {\nfloat percent = (t + offset - 0.5) / 30.0;\nfloat weight = 1.0 - abs(percent);\nvec4 offsetColor = texture(source, texCoord + tiltShift_getDelta(texSize) / texSize * percent * radius);\noffsetColor.rgb *= offsetColor.a;\ncolor += offsetColor * weight;\ntotal += weight;\n}\ncolor = color / total;\ncolor.rgb /= color.a + 0.00001;\nreturn color;\n}\n"},Qn={name:"triangleBlur",uniformTypes:{radius:"f32",delta:"vec2<f32>"},uniformPropTypes:{radius:{value:20,min:0,softMax:100},delta:{value:[1,0],private:!0}},fs:"uniform triangleBlurUniforms {\nfloat radius;\nvec2 delta;\n} triangleBlur;\nvec4 triangleBlur_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\nvec2 adjustedDelta = triangleBlur.delta * triangleBlur.radius / texSize;\nvec4 color = vec4(0.0);\nfloat total = 0.0;\nfloat offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\nfor (float t = -30.0; t <= 30.0; t++) {\nfloat percent = (t + offset - 0.5) / 30.0;\nfloat weight = 1.0 - abs(percent);\nvec4 offsetColor = texture(source, texCoord + adjustedDelta * percent);\noffsetColor.rgb *= offsetColor.a;\ncolor += offsetColor * weight;\ntotal += weight;\n}\ncolor = color / total;\ncolor.rgb /= color.a + 0.00001;\nreturn color;\n}\n",dependencies:[vn],passes:[{sampler:!0,uniforms:{delta:[1,0]}},{sampler:!0,uniforms:{delta:[0,1]}}]},Dn={name:"zoomBlur",uniformTypes:{center:"vec2<f32>",strength:"f32"},uniformPropTypes:{center:{value:[.5,.5]},strength:{value:.3,min:0,softMax:1}},fs:"\nuniform zoomBlurUniforms {\n  vec2 center;\n  float strength;\n} zoomBlur;\n\nvec4 zoomBlur_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  vec2 toCenter = zoomBlur.center * texSize - texCoord * texSize;\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = 0.0; t <= 40.0; t++) {\n    float percent = (t + offset) / 40.0;\n    float weight = 4.0 * (percent - percent * percent);\n    vec4 offsetColor = texture(source, texCoord + toCenter * percent * zoomBlur.strength / texSize);\n\n    /* switch to pre-multiplied alpha to correctly blur transparent images */\n    offsetColor.rgb *= offsetColor.a;\n\n    color += offsetColor * weight;\n    total += weight;\n  }\n\n  color = color / total;\n\n  /* switch back from pre-multiplied alpha */\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n",dependencies:[vn],passes:[{sampler:!0}]},Yn={name:"colorHalftone",uniformTypes:{center:"vec2<f32>",angle:"f32",size:"f32"},uniformPropTypes:{center:{value:[.5,.5]},angle:{value:1.1,softMin:0,softMax:Math.PI/2},size:{value:4,min:1,softMin:3,softMax:20}},fs:"uniform colorHalftoneUniforms {\nvec2 center;\nfloat angle;\nfloat size;\n} colorHalftone;\nfloat pattern(float angle, float scale, vec2 texSize, vec2 texCoord) {\nfloat s = sin(angle), c = cos(angle);\nvec2 tex = texCoord * texSize - colorHalftone.center * texSize;\nvec2 point = vec2(\nc * tex.x - s * tex.y,\ns * tex.x + c * tex.y\n) * scale;\nreturn (sin(point.x) * sin(point.y)) * 4.0;\n}\nvec4 colorHalftone_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\nfloat scale = 3.1514 / colorHalftone.size;\nvec3 cmy = 1.0 - color.rgb;\nfloat k = min(cmy.x, min(cmy.y, cmy.z));\ncmy = (cmy - k) / (1.0 - k);\ncmy = clamp(\ncmy * 10.0 - 3.0 + vec3(\npattern(colorHalftone.angle + 0.26179, scale, texSize, texCoord),\npattern(colorHalftone.angle + 1.30899, scale, texSize, texCoord),\npattern(colorHalftone.angle, scale, texSize, texCoord)\n),\n0.0,\n1.0\n);\nk = clamp(k * 10.0 - 5.0 + pattern(colorHalftone.angle + 0.78539, scale, texSize, texCoord), 0.0, 1.0);\nreturn vec4(1.0 - cmy - k, color.a);\n}\n",passes:[{filter:!0}]},Hn={name:"dotScreen",uniformTypes:{center:"vec2<f32>",angle:"f32",size:"f32"},uniformPropTypes:{center:{value:[.5,.5]},angle:{value:1.1,softMin:0,softMax:Math.PI/2},size:{value:3,min:1,softMin:3,softMax:20}},fs:"uniform dotScreenUniforms {\nvec2 center;\nfloat angle;\nfloat size;\n} dotScreen;\nfloat pattern(vec2 texSize, vec2 texCoord) {\nfloat scale = 3.1415 / dotScreen.size;\nfloat s = sin(dotScreen.angle), c = cos(dotScreen.angle);\nvec2 tex = texCoord * texSize - dotScreen.center * texSize;\nvec2 point = vec2(\nc * tex.x - s * tex.y,\ns * tex.x + c * tex.y\n) * scale;\nreturn (sin(point.x) * sin(point.y)) * 4.0;\n}\nvec4 dotScreen_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\nfloat average = (color.r + color.g + color.b) / 3.0;\nreturn vec4(vec3(average * 10.0 - 5.0 + pattern(texSize, texCoord)), color.a);\n}\n",passes:[{filter:!0}]},Vn={name:"edgeWork",uniformPropTypes:{radius:{value:2,min:1,softMax:50},delta:{value:[1,0],private:!0}},fs:"uniform edgeWorkUniforms {\nfloat radius;\nvec2 delta;\n} edgeWork;\nvec4 edgeWork_sampleColor1(sampler2D source, vec2 texSize, vec2 texCoord) {\nvec2 relativeDelta = edgeWork.radius * edgeWork.delta / texSize;\nvec2 color = vec2(0.0);\nvec2 total = vec2(0.0);\nfloat offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\nfor (float t = -30.0; t <= 30.0; t++) {\nfloat percent = (t + offset - 0.5) / 30.0;\nfloat weight = 1.0 - abs(percent);\nvec3 sampleColor = texture(source, texCoord + relativeDelta * percent).rgb;\nfloat average = (sampleColor.r + sampleColor.g + sampleColor.b) / 3.0;\ncolor.x += average * weight;\ntotal.x += weight;\nif (abs(t) < 15.0) {\nweight = weight * 2.0 - 1.0;\ncolor.y += average * weight;\ntotal.y += weight;\n}\n}\nreturn vec4(color / total, 0.0, 1.0);\n}\nvec4 edgeWork_sampleColor2(sampler2D source, vec2 texSize, vec2 texCoord) {\nvec2 relativeDelta = edgeWork.radius * edgeWork.delta / texSize;\nvec2 color = vec2(0.0);\nvec2 total = vec2(0.0);\nfloat offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\nfor (float t = -30.0; t <= 30.0; t++) {\nfloat percent = (t + offset - 0.5) / 30.0;\nfloat weight = 1.0 - abs(percent);\nvec2 sampleColor = texture(source, texCoord + relativeDelta * percent).xy;\ncolor.x += sampleColor.x * weight;\ntotal.x += weight;\nif (abs(t) < 15.0) {\nweight = weight * 2.0 - 1.0;\ncolor.y += sampleColor.y * weight;\ntotal.y += weight;\n}\n}\nfloat c = clamp(10000.0 * (color.y / total.y - color.x / total.x) + 0.5, 0.0, 1.0);\nreturn vec4(c, c, c, 1.0);\n}\n",dependencies:[vn],passes:[{sampler:"edgeWork_sampleColor1",uniformPropTypes:{delta:[1,0]}},{sampler:"edgeWork_sampleColor2",uniformPropTypes:{delta:[0,1]}}]},Wn={name:"hexagonalPixelate",uniformTypes:{center:"vec2<f32>",scale:"f32"},uniformPropTypes:{center:{value:[.5,.5],hint:"screenspace"},scale:{value:10,min:1,softMin:5,softMax:50}},fs:"uniform hexagonalPixelateUniforms {\nvec2 center;\nfloat scale;\n} hexagonalPixelate;\nvec4 hexagonalPixelate_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\nvec2 tex = (texCoord * texSize - hexagonalPixelate.center * texSize) / hexagonalPixelate.scale;\ntex.y /= 0.866025404;\ntex.x -= tex.y * 0.5;\nvec2 a;\nif (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {\na = vec2(floor(tex.x), floor(tex.y));\n}\nelse a = vec2(ceil(tex.x), ceil(tex.y));\nvec2 b = vec2(ceil(tex.x), floor(tex.y));\nvec2 c = vec2(floor(tex.x), ceil(tex.y));\nvec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\nvec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);\nvec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);\nvec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);\nfloat alen = length(TEX - A);\nfloat blen = length(TEX - B);\nfloat clen = length(TEX - C);\nvec2 choice;\nif (alen < blen) {\nif (alen < clen) choice = a;\nelse choice = c;\n} else {\nif (blen < clen) choice = b;\nelse choice = c;\n}\nchoice.x += choice.y * 0.5;\nchoice.y *= 0.866025404;\nchoice *= hexagonalPixelate.scale / texSize;\nreturn texture(source, choice + hexagonalPixelate.center);\n}\n",passes:[{sampler:!0}]},Gn={name:"ink",uniformTypes:{strength:"f32"},uniformPropTypes:{strength:{value:.25,min:0,softMax:1}},fs:"uniform inkUniforms {\nfloat strength;\n} ink;\nvec4 ink_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\nvec2 dx = vec2(1.0 / texSize.x, 0.0);\nvec2 dy = vec2(0.0, 1.0 / texSize.y);\nvec4 color = texture(source, texCoord);\nfloat bigTotal = 0.0;\nfloat smallTotal = 0.0;\nvec3 bigAverage = vec3(0.0);\nvec3 smallAverage = vec3(0.0);\nfor (float x = -2.0; x <= 2.0; x += 1.0) {\nfor (float y = -2.0; y <= 2.0; y += 1.0) {\nvec3 offsetColor = texture(source, texCoord + dx * x + dy * y).rgb;\nbigAverage += offsetColor;\nbigTotal += 1.0;\nif (abs(x) + abs(y) < 2.0) {\nsmallAverage += offsetColor;\nsmallTotal += 1.0;\n}\n}\n}\nvec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);\nfloat power = ink.strength * ink.strength * ink.strength * ink.strength * ink.strength;\nreturn vec4(color.rgb - dot(edge, edge) * power * 100000.0, color.a);\n}\n",passes:[{sampler:!0}]},qn={name:"magnify",uniformTypes:{screenXY:"vec2<f32>",radiusPixels:"f32",zoom:"f32",borderWidthPixels:"f32",borderColor:"vec4<f32>"},uniformPropTypes:{screenXY:{value:[0,0]},radiusPixels:200,zoom:2,borderWidthPixels:0,borderColor:{value:[255,255,255,255]}},fs:"uniform magnifyUniforms {\nvec2 screenXY;\nfloat radiusPixels;\nfloat zoom;\nfloat borderWidthPixels;\nvec4 borderColor;\n} magnify;\nvec4 magnify_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\nvec2 pos = vec2(magnify.screenXY.x, 1.0 - magnify.screenXY.y);\nfloat dist = distance(texCoord * texSize, pos * texSize);\nif (dist < magnify.radiusPixels) {\nreturn texture(source, (texCoord - pos) / magnify.zoom + pos);\n}\nif (dist <= magnify.radiusPixels + magnify.borderWidthPixels) {\nreturn magnify.borderColor;\n}\nreturn texture(source, texCoord);\n}\n",passes:[{sampler:!0}]},jn={name:"warp",passes:[],fs:"vec4 warp_sampleColor(sampler2D source, vec2 texSize, vec2 coord) {\nvec4 color = texture(source, coord / texSize);\nvec2 clampedCoord = clamp(coord, vec2(0.0), texSize);\nif (coord != clampedCoord) {\ncolor.a *= max(0.0, 1.0 - length(coord - clampedCoord));\n}\nreturn color;\n}\n"},$n={name:"bulgePinch",fs:"uniform bulgePinchUniforms {\nfloat radius;\nfloat strength;\nvec2 center;\n} bulgePinch;\nvec2 bulgePinch_warp(vec2 coord, vec2 texCenter) {\ncoord -= texCenter;\nfloat distance = length(coord);\nif (distance < bulgePinch.radius) {\nfloat percent = distance / bulgePinch.radius;\nif (bulgePinch.strength > 0.0) {\ncoord *= mix(1.0, smoothstep(0.0, bulgePinch.radius / distance, percent), bulgePinch.strength * 0.75);\n} else {\ncoord *= mix(1.0, pow(percent, 1.0 + bulgePinch.strength * 0.75) * bulgePinch.radius / distance, 1.0 - percent);\n}\n}\ncoord += texCenter;\nreturn coord;\n}\nvec4 bulgePinch_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\nvec2 coord = texCoord * texSize;\ncoord = bulgePinch_warp(coord, bulgePinch.center * texSize);\nreturn warp_sampleColor(source, texSize, coord);\n}\n",uniformTypes:{center:"vec2<f32>",radius:"f32",strength:"f32"},uniformPropTypes:{center:{value:[.5,.5]},radius:{value:200,min:1,softMax:600},strength:{value:.5,min:-1,max:1}},dependencies:[jn],passes:[{sampler:!0}]},Kn={name:"swirl",fs:"uniform swirlUniforms {\nfloat radius;\nfloat angle;\nvec2 center;\n} swirl;\nvec2 swirl_warp(vec2 coord, vec2 texCenter) {\ncoord -= texCenter;\nfloat distance = length(coord);\nif (distance < swirl.radius) {\nfloat percent = (swirl.radius - distance) / swirl.radius;\nfloat theta = percent * percent * swirl.angle;\nfloat s = sin(theta);\nfloat c = cos(theta);\ncoord = vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}\ncoord += texCenter;\nreturn coord;\n}\nvec4 swirl_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\nvec2 coord = texCoord * texSize;\ncoord = swirl_warp(coord, swirl.center * texSize);\nreturn warp_sampleColor(source, texSize, coord);\n}\n",uniformTypes:{center:"vec2<f32>",radius:"f32",angle:"f32"},uniformPropTypes:{center:{value:[.5,.5]},radius:{value:200,min:1,softMax:600},angle:{value:3,softMin:-25,softMax:25}},dependencies:[jn],passes:[{sampler:!0}]},Zn={name:"fxaa",uniformPropTypes:{},fs:"\n#define FXAA_QUALITY_PRESET 29\n\n#if (FXAA_QUALITY_PRESET == 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n#define FxaaBool bool\n#define FxaaFloat float\n#define FxaaFloat2 vec2\n#define FxaaFloat3 vec3\n#define FxaaFloat4 vec4\n#define FxaaHalf float\n#define FxaaHalf2 vec2\n#define FxaaHalf3 vec3\n#define FxaaHalf4 vec4\n#define FxaaInt2 vec2\n#define FxaaTex sampler2D\n\n#define FxaaSat(x) clamp(x, 0.0, 1.0)\n#define FxaaTexTop(t, p) texture(t, p)\n#define FxaaTexOff(t, p, o, r) texture(t, p + (o * r))\n\nFxaaFloat FxaaLuma_(FxaaFloat4 rgba) { return dot(rgba.rgb, vec3(0.2126, 0.7152, 0.0722)); }\n\nFxaaFloat4 FxaaPixelShader_(\n    //\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} = center of pixel\n    FxaaFloat2 pos,\n    //\n    // Input color texture.\n    // {rgb_} = color in linear or perceptual color space\n    // if (FXAA_GREEN_AS_LUMA == 0)\n    //     {___a} = luma in perceptual color space (not linear)\n    FxaaTex tex,\n    //\n    // Only used on FXAA Quality.\n    // This must be from a constant/uniform.\n    // {x_} = 1.0/screenWidthInPixels\n    // {_y} = 1.0/screenHeightInPixels\n    FxaaFloat2 fxaaQualityRcpFrame,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // It is here now to allow easier tuning.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    FxaaFloat fxaaQualitySubpix,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    FxaaFloat fxaaQualityEdgeThreshold,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaQualityEdgeThresholdMin\n) {\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n    #define lumaM rgbyM.y\n    FxaaFloat lumaS = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaN = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n/*--------------------------------------------------------------------------*/\n    FxaaFloat maxSM = max(lumaS, lumaM);\n    FxaaFloat minSM = min(lumaS, lumaM);\n    FxaaFloat maxESM = max(lumaE, maxSM);\n    FxaaFloat minESM = min(lumaE, minSM);\n    FxaaFloat maxWN = max(lumaN, lumaW);\n    FxaaFloat minWN = min(lumaN, lumaW);\n    FxaaFloat rangeMax = max(maxWN, maxESM);\n    FxaaFloat rangeMin = min(minWN, minESM);\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range = rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit = range < rangeMaxClamped;\n/*--------------------------------------------------------------------------*/\n    if(earlyExit)\n        return rgbyM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaSE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaNE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaSW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNS = lumaN + lumaS;\n    FxaaFloat lumaWE = lumaW + lumaE;\n    FxaaFloat subpixRcpRange = 1.0/range;\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n/*--------------------------------------------------------------------------*/\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat gradientN = lumaN - lumaM;\n    FxaaFloat gradientS = lumaS - lumaM;\n    FxaaFloat lumaNN = lumaN + lumaM;\n    FxaaFloat lumaSS = lumaS + lumaM;\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posB;\n    posB.x = posM.x;\n    posB.y = posM.y;\n    FxaaFloat2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posN;\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE = subpixC * subpixC;\n    FxaaFloat lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP));\n/*--------------------------------------------------------------------------*/\n    if(!pairN) lumaNN = lumaSS;\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF = subpixD * subpixE;\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\n/*--------------------------------------------------------------------------*/\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n/*--------------------------------------------------------------------------*/\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n/*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PS > 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n    #endif\n/*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n/*--------------------------------------------------------------------------*/\n    FxaaFloat dstN = posM.x - posN.x;\n    FxaaFloat dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n/*--------------------------------------------------------------------------*/\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    FxaaFloat spanLength = (dstP + dstN);\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\n/*--------------------------------------------------------------------------*/\n    FxaaBool directionN = dstN < dstP;\n    FxaaFloat dst = min(dstN, dstP);\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG = subpixF * subpixF;\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n    return FxaaTexTop(tex, posM);\n}\n\nvec4 fxaa_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n    const float fxaa_QualitySubpix = 0.5;\n    const float fxaa_QualityEdgeThreshold = 0.125;\n    const float fxaa_QualityEdgeThresholdMin = 0.0833;\n\n    return FxaaPixelShader_(\n        texCoord,\n        source,\n        vec2(1.0) / texSize,\n        fxaa_QualitySubpix,\n        fxaa_QualityEdgeThreshold,\n        fxaa_QualityEdgeThresholdMin\n    );\n}\n",passes:[{sampler:!0}]};function Jn(e,n=[],t=0){const o=Math.fround(e),r=e-o;return n[t]=o,n[t+1]=r,n}function et(e){return e-Math.fround(e)}function nt(e){const n=new Float32Array(32);for(let t=0;t<4;++t)for(let o=0;o<4;++o){const r=4*t+o;Jn(e[4*o+t],n,2*r)}return n}const tt={ONE:1};const ot={name:"fp64-arithmetic",vs:"uniform float ONE;\nvec2 split(float a) {\nconst float SPLIT = 4097.0;\nfloat t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\nfloat a_hi = t * ONE - (t - a);\nfloat a_lo = a * ONE - a_hi;\n#else\nfloat a_hi = t - (t - a);\nfloat a_lo = a - a_hi;\n#endif\nreturn vec2(a_hi, a_lo);\n}\nvec2 split2(vec2 a) {\nvec2 b = split(a.x);\nb.y += a.y;\nreturn b;\n}\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\nfloat sum = (a + b) * ONE;\nfloat err = b - (sum - a) * ONE;\n#else\nfloat sum = a + b;\nfloat err = b - (sum - a);\n#endif\nreturn vec2(sum, err);\n}\nvec2 twoSum(float a, float b) {\nfloat s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\nfloat v = (s * ONE - a) * ONE;\nfloat err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n#else\nfloat v = s - a;\nfloat err = (a - (s - v)) + (b - v);\n#endif\nreturn vec2(s, err);\n}\nvec2 twoSub(float a, float b) {\nfloat s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\nfloat v = (s * ONE - a) * ONE;\nfloat err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n#else\nfloat v = s - a;\nfloat err = (a - (s - v)) - (b + v);\n#endif\nreturn vec2(s, err);\n}\nvec2 twoSqr(float a) {\nfloat prod = a * a;\nvec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\nfloat err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\na_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n#else\nfloat err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\nreturn vec2(prod, err);\n}\nvec2 twoProd(float a, float b) {\nfloat prod = a * b;\nvec2 a_fp64 = split(a);\nvec2 b_fp64 = split(b);\nfloat err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\na_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\nreturn vec2(prod, err);\n}\nvec2 sum_fp64(vec2 a, vec2 b) {\nvec2 s, t;\ns = twoSum(a.x, b.x);\nt = twoSum(a.y, b.y);\ns.y += t.x;\ns = quickTwoSum(s.x, s.y);\ns.y += t.y;\ns = quickTwoSum(s.x, s.y);\nreturn s;\n}\nvec2 sub_fp64(vec2 a, vec2 b) {\nvec2 s, t;\ns = twoSub(a.x, b.x);\nt = twoSub(a.y, b.y);\ns.y += t.x;\ns = quickTwoSum(s.x, s.y);\ns.y += t.y;\ns = quickTwoSum(s.x, s.y);\nreturn s;\n}\nvec2 mul_fp64(vec2 a, vec2 b) {\nvec2 prod = twoProd(a.x, b.x);\nprod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\nprod = split2(prod);\n#endif\nprod = quickTwoSum(prod.x, prod.y);\nprod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\nprod = split2(prod);\n#endif\nprod = quickTwoSum(prod.x, prod.y);\nreturn prod;\n}\nvec2 div_fp64(vec2 a, vec2 b) {\nfloat xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\nvec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\nvec2 yn = a * xn;\n#endif\nfloat diff = (sub_fp64(a, mul_fp64(b, yn))).x;\nvec2 prod = twoProd(xn, diff);\nreturn sum_fp64(yn, prod);\n}\nvec2 sqrt_fp64(vec2 a) {\nif (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\nif (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\nfloat x = 1.0 / sqrt(a.x);\nfloat yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\nvec2 yn_sqr = twoSqr(yn) * ONE;\n#else\nvec2 yn_sqr = twoSqr(yn);\n#endif\nfloat diff = sub_fp64(a, yn_sqr).x;\nvec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\nreturn sum_fp64(split(yn), prod);\n#else\nreturn sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n",getUniforms:function(){return tt},fp64ify:Jn,fp64LowPart:et,fp64ifyMatrix4:nt},rt={name:"fp64",vs:"const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);\nfloat nint(float d) {\nif (d == floor(d)) return d;\nreturn floor(d + 0.5);\n}\nvec2 nint_fp64(vec2 a) {\nfloat hi = nint(a.x);\nfloat lo;\nvec2 tmp;\nif (hi == a.x) {\nlo = nint(a.y);\ntmp = quickTwoSum(hi, lo);\n} else {\nlo = 0.0;\nif (abs(hi - a.x) == 0.5 && a.y < 0.0) {\nhi -= 1.0;\n}\ntmp = vec2(hi, lo);\n}\nreturn tmp;\n}\nvec2 exp_fp64(vec2 a) {\nconst int k_power = 4;\nconst float k = 16.0;\nconst float inv_k = 1.0 / k;\nif (a.x <= -88.0) return vec2(0.0, 0.0);\nif (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\nif (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\nif (a.x == 1.0 && a.y == 0.0) return E_FP64;\nfloat m = floor(a.x / LOG2_FP64.x + 0.5);\nvec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\nvec2 s, t, p;\np = mul_fp64(r, r);\ns = sum_fp64(r, p * 0.5);\np = mul_fp64(p, r);\nt = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\ns = sum_fp64(s, t);\np = mul_fp64(p, r);\nt = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\ns = sum_fp64(s, t);\np = mul_fp64(p, r);\nt = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\ns = sum_fp64(s, t);\nfor (int i = 0; i < k_power; i++) {\ns = sum_fp64(s * 2.0, mul_fp64(s, s));\n}\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\ns = sum_fp64(s, vec2(ONE, 0.0));\n#else\ns = sum_fp64(s, vec2(1.0, 0.0));\n#endif\nreturn s * pow(2.0, m);\n}\nvec2 log_fp64(vec2 a)\n{\nif (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\nif (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\nvec2 x = vec2(log(a.x), 0.0);\nvec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\ns = vec2(ONE, 0.0);\n#else\ns = vec2(1.0, 0.0);\n#endif\nx = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\nreturn x;\n}\nvec2 sin_taylor_fp64(vec2 a) {\nvec2 r, s, t, x;\nif (a.x == 0.0 && a.y == 0.0) {\nreturn vec2(0.0, 0.0);\n}\nx = -mul_fp64(a, a);\ns = a;\nr = a;\nr = mul_fp64(r, x);\nt = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\ns = sum_fp64(s, t);\nr = mul_fp64(r, x);\nt = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\ns = sum_fp64(s, t);\nreturn s;\n}\nvec2 cos_taylor_fp64(vec2 a) {\nvec2 r, s, t, x;\nif (a.x == 0.0 && a.y == 0.0) {\nreturn vec2(1.0, 0.0);\n}\nx = -mul_fp64(a, a);\nr = x;\ns = sum_fp64(vec2(1.0, 0.0), r * 0.5);\nr = mul_fp64(r, x);\nt = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\ns = sum_fp64(s, t);\nr = mul_fp64(r, x);\nt = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\ns = sum_fp64(s, t);\nreturn s;\n}\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\nif (a.x == 0.0 && a.y == 0.0) {\nsin_t = vec2(0.0, 0.0);\ncos_t = vec2(1.0, 0.0);\n}\nsin_t = sin_taylor_fp64(a);\ncos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\nvec2 sin_fp64(vec2 a) {\nif (a.x == 0.0 && a.y == 0.0) {\nreturn vec2(0.0, 0.0);\n}\nvec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\nvec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\nvec2 t;\nfloat q = floor(r.x / PI_2_FP64.x + 0.5);\nint j = int(q);\nif (j < -2 || j > 2) {\nreturn vec2(0.0 / 0.0, 0.0 / 0.0);\n}\nt = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\nq = floor(t.x / PI_16_FP64.x + 0.5);\nint k = int(q);\nif (k == 0) {\nif (j == 0) {\nreturn sin_taylor_fp64(t);\n} else if (j == 1) {\nreturn cos_taylor_fp64(t);\n} else if (j == -1) {\nreturn -cos_taylor_fp64(t);\n} else {\nreturn -sin_taylor_fp64(t);\n}\n}\nint abs_k = int(abs(float(k)));\nif (abs_k > 4) {\nreturn vec2(0.0 / 0.0, 0.0 / 0.0);\n} else {\nt = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n}\nvec2 u = vec2(0.0, 0.0);\nvec2 v = vec2(0.0, 0.0);\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\nif (abs(float(abs_k) - 1.0) < 0.5) {\nu = COS_TABLE_0_FP64;\nv = SIN_TABLE_0_FP64;\n} else if (abs(float(abs_k) - 2.0) < 0.5) {\nu = COS_TABLE_1_FP64;\nv = SIN_TABLE_1_FP64;\n} else if (abs(float(abs_k) - 3.0) < 0.5) {\nu = COS_TABLE_2_FP64;\nv = SIN_TABLE_2_FP64;\n} else if (abs(float(abs_k) - 4.0) < 0.5) {\nu = COS_TABLE_3_FP64;\nv = SIN_TABLE_3_FP64;\n}\n#else\nif (abs_k == 1) {\nu = COS_TABLE_0_FP64;\nv = SIN_TABLE_0_FP64;\n} else if (abs_k == 2) {\nu = COS_TABLE_1_FP64;\nv = SIN_TABLE_1_FP64;\n} else if (abs_k == 3) {\nu = COS_TABLE_2_FP64;\nv = SIN_TABLE_2_FP64;\n} else if (abs_k == 4) {\nu = COS_TABLE_3_FP64;\nv = SIN_TABLE_3_FP64;\n}\n#endif\nvec2 sin_t, cos_t;\nsincos_taylor_fp64(t, sin_t, cos_t);\nvec2 result = vec2(0.0, 0.0);\nif (j == 0) {\nif (k > 0) {\nresult = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n} else {\nresult = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n}\n} else if (j == 1) {\nif (k > 0) {\nresult = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n} else {\nresult = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n}\n} else if (j == -1) {\nif (k > 0) {\nresult = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n} else {\nresult = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n}\n} else {\nif (k > 0) {\nresult = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n} else {\nresult = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n}\n}\nreturn result;\n}\nvec2 cos_fp64(vec2 a) {\nif (a.x == 0.0 && a.y == 0.0) {\nreturn vec2(1.0, 0.0);\n}\nvec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\nvec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\nvec2 t;\nfloat q = floor(r.x / PI_2_FP64.x + 0.5);\nint j = int(q);\nif (j < -2 || j > 2) {\nreturn vec2(0.0 / 0.0, 0.0 / 0.0);\n}\nt = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\nq = floor(t.x / PI_16_FP64.x + 0.5);\nint k = int(q);\nif (k == 0) {\nif (j == 0) {\nreturn cos_taylor_fp64(t);\n} else if (j == 1) {\nreturn -sin_taylor_fp64(t);\n} else if (j == -1) {\nreturn sin_taylor_fp64(t);\n} else {\nreturn -cos_taylor_fp64(t);\n}\n}\nint abs_k = int(abs(float(k)));\nif (abs_k > 4) {\nreturn vec2(0.0 / 0.0, 0.0 / 0.0);\n} else {\nt = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n}\nvec2 u = vec2(0.0, 0.0);\nvec2 v = vec2(0.0, 0.0);\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\nif (abs(float(abs_k) - 1.0) < 0.5) {\nu = COS_TABLE_0_FP64;\nv = SIN_TABLE_0_FP64;\n} else if (abs(float(abs_k) - 2.0) < 0.5) {\nu = COS_TABLE_1_FP64;\nv = SIN_TABLE_1_FP64;\n} else if (abs(float(abs_k) - 3.0) < 0.5) {\nu = COS_TABLE_2_FP64;\nv = SIN_TABLE_2_FP64;\n} else if (abs(float(abs_k) - 4.0) < 0.5) {\nu = COS_TABLE_3_FP64;\nv = SIN_TABLE_3_FP64;\n}\n#else\nif (abs_k == 1) {\nu = COS_TABLE_0_FP64;\nv = SIN_TABLE_0_FP64;\n} else if (abs_k == 2) {\nu = COS_TABLE_1_FP64;\nv = SIN_TABLE_1_FP64;\n} else if (abs_k == 3) {\nu = COS_TABLE_2_FP64;\nv = SIN_TABLE_2_FP64;\n} else if (abs_k == 4) {\nu = COS_TABLE_3_FP64;\nv = SIN_TABLE_3_FP64;\n}\n#endif\nvec2 sin_t, cos_t;\nsincos_taylor_fp64(t, sin_t, cos_t);\nvec2 result = vec2(0.0, 0.0);\nif (j == 0) {\nif (k > 0) {\nresult = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n} else {\nresult = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n}\n} else if (j == 1) {\nif (k > 0) {\nresult = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n} else {\nresult = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n}\n} else if (j == -1) {\nif (k > 0) {\nresult = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n} else {\nresult = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n}\n} else {\nif (k > 0) {\nresult = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n} else {\nresult = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n}\n}\nreturn result;\n}\nvec2 tan_fp64(vec2 a) {\nvec2 sin_a;\nvec2 cos_a;\nif (a.x == 0.0 && a.y == 0.0) {\nreturn vec2(0.0, 0.0);\n}\nvec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\nvec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\nvec2 t;\nfloat q = floor(r.x / PI_2_FP64.x + 0.5);\nint j = int(q);\nif (j < -2 || j > 2) {\nreturn vec2(0.0 / 0.0, 0.0 / 0.0);\n}\nt = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\nq = floor(t.x / PI_16_FP64.x + 0.5);\nint k = int(q);\nint abs_k = int(abs(float(k)));\nif (abs_k > 4) {\nreturn vec2(0.0 / 0.0, 0.0 / 0.0);\n} else {\nt = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n}\nvec2 u = vec2(0.0, 0.0);\nvec2 v = vec2(0.0, 0.0);\nvec2 sin_t, cos_t;\nvec2 s, c;\nsincos_taylor_fp64(t, sin_t, cos_t);\nif (k == 0) {\ns = sin_t;\nc = cos_t;\n} else {\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\nif (abs(float(abs_k) - 1.0) < 0.5) {\nu = COS_TABLE_0_FP64;\nv = SIN_TABLE_0_FP64;\n} else if (abs(float(abs_k) - 2.0) < 0.5) {\nu = COS_TABLE_1_FP64;\nv = SIN_TABLE_1_FP64;\n} else if (abs(float(abs_k) - 3.0) < 0.5) {\nu = COS_TABLE_2_FP64;\nv = SIN_TABLE_2_FP64;\n} else if (abs(float(abs_k) - 4.0) < 0.5) {\nu = COS_TABLE_3_FP64;\nv = SIN_TABLE_3_FP64;\n}\n#else\nif (abs_k == 1) {\nu = COS_TABLE_0_FP64;\nv = SIN_TABLE_0_FP64;\n} else if (abs_k == 2) {\nu = COS_TABLE_1_FP64;\nv = SIN_TABLE_1_FP64;\n} else if (abs_k == 3) {\nu = COS_TABLE_2_FP64;\nv = SIN_TABLE_2_FP64;\n} else if (abs_k == 4) {\nu = COS_TABLE_3_FP64;\nv = SIN_TABLE_3_FP64;\n}\n#endif\nif (k > 0) {\ns = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\nc = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n} else {\ns = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\nc = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n}\n}\nif (j == 0) {\nsin_a = s;\ncos_a = c;\n} else if (j == 1) {\nsin_a = c;\ncos_a = -s;\n} else if (j == -1) {\nsin_a = -c;\ncos_a = s;\n} else {\nsin_a = -s;\ncos_a = -c;\n}\nreturn div_fp64(sin_a, cos_a);\n}\nvec2 radians_fp64(vec2 degree) {\nreturn mul_fp64(degree, PI_180_FP64);\n}\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\nvec2 range = sub_fp64(b, a);\nreturn sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\nout_val[0] = sum_fp64(a[0], b[0]);\nout_val[1] = sum_fp64(a[1], b[1]);\n}\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\nout_val[0] = sub_fp64(a[0], b[0]);\nout_val[1] = sub_fp64(a[1], b[1]);\n}\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\nout_val[0] = mul_fp64(a[0], b[0]);\nout_val[1] = mul_fp64(a[1], b[1]);\n}\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\nout_val[0] = div_fp64(a[0], b[0]);\nout_val[1] = div_fp64(a[1], b[1]);\n}\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\nvec2 range[2];\nvec2_sub_fp64(y, x, range);\nvec2 portion[2];\nportion[0] = range[0] * a;\nportion[1] = range[1] * a;\nvec2_sum_fp64(x, portion, out_val);\n}\nvec2 vec2_length_fp64(vec2 x[2]) {\nreturn sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\nvec2 length = vec2_length_fp64(x);\nvec2 length_vec2[2];\nlength_vec2[0] = length;\nlength_vec2[1] = length;\nvec2_div_fp64(x, length_vec2, out_val);\n}\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\nvec2 diff[2];\nvec2_sub_fp64(x, y, diff);\nreturn vec2_length_fp64(diff);\n}\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\nvec2 v[2];\nv[0] = mul_fp64(a[0], b[0]);\nv[1] = mul_fp64(a[1], b[1]);\nreturn sum_fp64(v[0], v[1]);\n}\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\nfor (int i = 0; i < 3; i++) {\nout_val[i] = sum_fp64(a[i], b[i]);\n}\n}\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\nfor (int i = 0; i < 3; i++) {\nout_val[i] = sum_fp64(a[i], b[i]);\n}\n}\nvec2 vec3_length_fp64(vec2 x[3]) {\nreturn sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\nmul_fp64(x[2], x[2])));\n}\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\nvec2 diff[3];\nvec3_sub_fp64(x, y, diff);\nreturn vec3_length_fp64(diff);\n}\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\nout_val[0].x = a[0];\nout_val[0].y = 0.0;\nout_val[1].x = a[1];\nout_val[1].y = 0.0;\nout_val[2].x = a[2];\nout_val[2].y = 0.0;\nout_val[3].x = a[3];\nout_val[3].y = 0.0;\n}\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\nout_val[0] = mul_fp64(a[0], b);\nout_val[1] = mul_fp64(a[1], b);\nout_val[2] = mul_fp64(a[2], b);\nout_val[3] = mul_fp64(a[3], b);\n}\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\nfor (int i = 0; i < 4; i++) {\nout_val[i] = sum_fp64(a[i], b[i]);\n}\n}\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\nvec2 v[4];\nv[0] = mul_fp64(a[0], b[0]);\nv[1] = mul_fp64(a[1], b[1]);\nv[2] = mul_fp64(a[2], b[2]);\nv[3] = mul_fp64(a[3], b[3]);\nout_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\nvec2 tmp[4];\nfor (int i = 0; i < 4; i++)\n{\nfor (int j = 0; j < 4; j++)\n{\ntmp[j] = b[j + i * 4];\n}\nvec4_dot_fp64(a, tmp, out_val[i]);\n}\n}\n",dependencies:[ot],fp64ify:Jn,fp64LowPart:et,fp64ifyMatrix4:nt},it={name:"geometry",vs:"varying vec4 geometry_vPosition;\nvarying vec3 geometry_vNormal;\nvoid geometry_setNormal(vec3 normal) {\ngeometry_vNormal = normal;\n}\nvoid geometry_setPosition(vec4 position) {\ngeometry_vPosition = position;\n}\nvoid geometry_setPosition(vec3 position) {\ngeometry_vPosition = vec4(position, 1.);\n}\n",fs:"varying vec4 geometry_vPosition;\nvarying vec3 geometry_vNormal;\nvec4 geometry_getPosition() {\nreturn geometry_vPosition;\n}\nvec3 geometry_getNormal() {\nreturn geometry_vNormal;\n}\n"},st=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],at={modelMatrix:st,viewMatrix:st,projectionMatrix:st,cameraPositionWorld:[0,0,0]};const lt="varying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\nvec4 project_getPosition_World() {\nreturn project_vPositionWorld;\n}\nvec3 project_getNormal_World() {\nreturn project_vNormalWorld;\n}\n",ct={name:"project",getUniforms:function(e=at,t={}){const o={};return void 0!==e.modelMatrix&&(o.modelMatrix=e.modelMatrix),void 0!==e.viewMatrix&&(o.viewMatrix=e.viewMatrix),void 0!==e.projectionMatrix&&(o.projectionMatrix=e.projectionMatrix),void 0!==e.cameraPositionWorld&&(o.cameraPositionWorld=e.cameraPositionWorld),void 0===e.projectionMatrix&&void 0===e.viewMatrix||(o.viewProjectionMatrix=new n(e.projectionMatrix).multiplyRight(e.viewMatrix)),o},vs:`${lt}\n\n// Unprefixed uniforms\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n`,fs:`\n${lt}`},ut="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\nvec3 color;\n};\nstruct PointLight {\nvec3 color;\nvec3 position;\nvec3 attenuation;\n};\nstruct DirectionalLight {\nvec3 color;\nvec3 direction;\n};\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\nuniform bool lighting_uEnabled;\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\nreturn pointLight.attenuation.x\n+ pointLight.attenuation.y * distance\n+ pointLight.attenuation.z * distance * distance;\n}\n#endif\n",_t={lightSources:{}};function ft(e={}){const{color:n=[0,0,0],intensity:t=1}=e;return n.map((e=>e*t/255))}const dt={name:"lights",vs:ut,fs:ut,getUniforms:function e(n=_t){if("lightSources"in n){const{ambientLight:e,pointLights:t,directionalLights:o}=n.lightSources||{};return e||t&&t.length>0||o&&o.length>0?Object.assign({},function({ambientLight:e,pointLights:n=[],directionalLights:t=[]}){const o={};return o["lighting_uAmbientLight.color"]=e?ft(e):[0,0,0],n.forEach(((e,n)=>{o[`lighting_uPointLight[${n}].color`]=ft(e),o[`lighting_uPointLight[${n}].position`]=e.position,o[`lighting_uPointLight[${n}].attenuation`]=e.attenuation||[1,0,0]})),o.lighting_uPointLightCount=n.length,t.forEach(((e,n)=>{o[`lighting_uDirectionalLight[${n}].color`]=ft(e),o[`lighting_uDirectionalLight[${n}].direction`]=e.direction})),o.lighting_uDirectionalLightCount=t.length,o}({ambientLight:e,pointLights:t,directionalLights:o}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in n){const t={pointLights:[],directionalLights:[]};for(const e of n.lights||[])switch(e.type){case"ambient":t.ambientLight=e;break;case"directional":t.directionalLights?.push(e);break;case"point":t.pointLights?.push(e)}return e({lightSources:t})}return{}},defines:{MAX_LIGHTS:3}},pt={lightDirection:new Float32Array([1,1,2])};const ht={name:"dirlight",fs:"uniform vec3 dirlight_uLightDirection;\nvec4 dirlight_filterColor(vec4 color) {\nvec3 normal = project_getNormal_World();\nfloat d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\nreturn vec4(color.rgb * d, color.a);\n}\n",getUniforms:function(e=pt){const n={};return e.lightDirection&&(n.dirlight_uLightDirection=e.lightDirection),n},dependencies:[ct]},mt="uniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\nvec3 halfway_direction = normalize(light_direction + view_direction);\nfloat lambertian = dot(light_direction, normal_worldspace);\nfloat specular = 0.0;\nif (lambertian > 0.0) {\nfloat specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\nspecular = pow(specular_angle, lighting_uShininess);\n}\nlambertian = max(lambertian, 0.0);\nreturn (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\nvec3 lightColor = surfaceColor;\nif (lighting_uEnabled) {\nvec3 view_direction = normalize(cameraPosition - position_worldspace);\nlightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uPointLightCount) {\nbreak;\n}\nPointLight pointLight = lighting_uPointLight[i];\nvec3 light_position_worldspace = pointLight.position;\nvec3 light_direction = normalize(light_position_worldspace - position_worldspace);\nlightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n}\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uDirectionalLightCount) {\nbreak;\n}\nDirectionalLight directionalLight = lighting_uDirectionalLight[i];\nlightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n}\n}\nreturn lightColor;\n}\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\nvec3 lightColor = vec3(0, 0, 0);\nvec3 surfaceColor = vec3(0, 0, 0);\nif (lighting_uEnabled) {\nvec3 view_direction = normalize(cameraPosition - position_worldspace);\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uPointLightCount) {\nbreak;\n}\nPointLight pointLight = lighting_uPointLight[i];\nvec3 light_position_worldspace = pointLight.position;\nvec3 light_direction = normalize(light_position_worldspace - position_worldspace);\nlightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n}\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uDirectionalLightCount) {\nbreak;\n}\nDirectionalLight directionalLight = lighting_uDirectionalLight[i];\nlightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n}\n}\nreturn lightColor;\n}\n",gt={};function vt(e=gt){if(!("material"in e))return{};const{material:n}=e;return n?function(e){const{ambient:n=.35,diffuse:t=.6,shininess:o=32,specularColor:r=[30,30,30]}=e;return{lighting_uAmbient:n,lighting_uDiffuse:t,lighting_uShininess:o,lighting_uSpecularColor:r.map((e=>e/255))}}(n):{lighting_uEnabled:!1}}const xt={name:"gouraud-lighting",dependencies:[dt],vs:mt,defines:{LIGHTING_VERTEX:1},getUniforms:vt},bt={name:"phong-lighting",dependencies:[dt],fs:mt,defines:{LIGHTING_FRAGMENT:1},getUniforms:vt},At={name:"pbr",vs:"uniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\nout vec3 pbr_vPosition;\nout vec2 pbr_vUV;\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nout mat3 pbr_vTBN;\n# else\nout vec3 pbr_vNormal;\n# endif\n#endif\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\nvec4 pos = u_ModelMatrix * position;\npbr_vPosition = vec3(pos.xyz) / pos.w;\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\nvec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\nvec3 bitangentW = cross(normalW, tangentW) * tangent.w;\npbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else\npbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n#ifdef HAS_UV\npbr_vUV = uv;\n#else\npbr_vUV = vec2(0.,0.);\n#endif\n}\n",fs:"precision highp float;\nuniform bool pbr_uUnlit;\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\nuniform vec3 u_Camera;\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\nin vec3 pbr_vPosition;\nin vec2 pbr_vUV;\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nin mat3 pbr_vTBN;\n#else\nin vec3 pbr_vNormal;\n#endif\n#endif\nstruct PBRInfo\n{\nfloat NdotL;\nfloat NdotV;\nfloat NdotH;\nfloat LdotH;\nfloat VdotH;\nfloat perceptualRoughness;\nfloat metalness;\nvec3 reflectance0;\nvec3 reflectance90;\nfloat alphaRoughness;\nvec3 diffuseColor;\nvec3 specularColor;\nvec3 n;\nvec3 v;\n};\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\nvec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else\nvec3 bLess = step(vec3(0.04045),srgbIn.xyz);\nvec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif\nreturn vec4(linOut,srgbIn.w);;\n#else\nreturn srgbIn;\n#endif\n}\nvec3 getNormal()\n{\n#ifndef HAS_TANGENTS\nvec3 pos_dx = dFdx(pbr_vPosition);\nvec3 pos_dy = dFdy(pbr_vPosition);\nvec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\nvec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\nvec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n#ifdef HAS_NORMALS\nvec3 ng = normalize(pbr_vNormal);\n#else\nvec3 ng = cross(pos_dx, pos_dy);\n#endif\nt = normalize(t - ng * dot(ng, t));\nvec3 b = normalize(cross(ng, t));\nmat3 tbn = mat3(t, b, ng);\n#else\nmat3 tbn = pbr_vTBN;\n#endif\n#ifdef HAS_NORMALMAP\nvec3 n = texture(u_NormalSampler, pbr_vUV).rgb;\nn = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\nvec3 n = normalize(tbn[2].xyz);\n#endif\nreturn n;\n}\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\nfloat mipCount = 9.0;\nfloat lod = (pbrInputs.perceptualRoughness * mipCount);\nvec3 brdf = SRGBtoLINEAR(texture(u_brdfLUT,\nvec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\nvec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n#ifdef USE_TEX_LOD\nvec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\nvec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\nvec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\nvec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\ndiffuse *= u_ScaleIBLAmbient.x;\nspecular *= u_ScaleIBLAmbient.y;\nreturn diffuse + specular;\n}\n#endif\nvec3 diffuse(PBRInfo pbrInputs)\n{\nreturn pbrInputs.diffuseColor / M_PI;\n}\nvec3 specularReflection(PBRInfo pbrInputs)\n{\nreturn pbrInputs.reflectance0 +\n(pbrInputs.reflectance90 - pbrInputs.reflectance0) *\npow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\nfloat NdotL = pbrInputs.NdotL;\nfloat NdotV = pbrInputs.NdotV;\nfloat r = pbrInputs.alphaRoughness;\nfloat attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\nfloat attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\nreturn attenuationL * attenuationV;\n}\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\nfloat roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\nfloat f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\nreturn roughnessSq / (M_PI * f * f);\n}\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\npbrInputs.NdotL = 1.0;\npbrInputs.NdotH = 0.0;\npbrInputs.LdotH = 0.0;\npbrInputs.VdotH = 1.0;\n}\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\nvec3 n = pbrInputs.n;\nvec3 v = pbrInputs.v;\nvec3 l = normalize(lightDirection);\nvec3 h = normalize(l+v);\npbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\npbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\npbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\npbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\nvec3 light_direction = normalize(pointLight.position - pbr_vPosition);\nPBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\nvec3 F = specularReflection(pbrInputs);\nfloat G = geometricOcclusion(pbrInputs);\nfloat D = microfacetDistribution(pbrInputs);\nvec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\nvec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\nreturn pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n#ifdef HAS_BASECOLORMAP\nvec4 baseColor = SRGBtoLINEAR(texture(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\nvec4 baseColor = u_BaseColorFactor;\n#endif\n#ifdef ALPHA_CUTOFF\nif (baseColor.a < u_AlphaCutoff) {\ndiscard;\n}\n#endif\nvec3 color = vec3(0, 0, 0);\nif(pbr_uUnlit){\ncolor.rgb = baseColor.rgb;\n}\nelse{\nfloat perceptualRoughness = u_MetallicRoughnessValues.y;\nfloat metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\nvec4 mrSample = texture(u_MetallicRoughnessSampler, pbr_vUV);\nperceptualRoughness = mrSample.g * perceptualRoughness;\nmetallic = mrSample.b * metallic;\n#endif\nperceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\nmetallic = clamp(metallic, 0.0, 1.0);\nfloat alphaRoughness = perceptualRoughness * perceptualRoughness;\nvec3 f0 = vec3(0.04);\nvec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\ndiffuseColor *= 1.0 - metallic;\nvec3 specularColor = mix(f0, baseColor.rgb, metallic);\nfloat reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\nfloat reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\nvec3 specularEnvironmentR0 = specularColor.rgb;\nvec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\nvec3 n = getNormal();\nvec3 v = normalize(u_Camera - pbr_vPosition);\nfloat NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\nvec3 reflection = -normalize(reflect(v, n));\nPBRInfo pbrInputs = PBRInfo(\n0.0,\nNdotV,\n0.0,\n0.0,\n0.0,\nperceptualRoughness,\nmetallic,\nspecularEnvironmentR0,\nspecularEnvironmentR90,\nalphaRoughness,\ndiffuseColor,\nspecularColor,\nn,\nv\n);\n#ifdef USE_LIGHTS\nPBRInfo_setAmbientLight(pbrInputs);\ncolor += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\nfor(int i = 0; i < lighting_uDirectionalLightCount; i++) {\nif (i < lighting_uDirectionalLightCount) {\nPBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\ncolor += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n}\n}\nfor(int i = 0; i < lighting_uPointLightCount; i++) {\nif (i < lighting_uPointLightCount) {\nPBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\nfloat attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\ncolor += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n}\n}\n#endif\n#ifdef USE_IBL\ncolor += getIBLContribution(pbrInputs, n, reflection);\n#endif\n#ifdef HAS_OCCLUSIONMAP\nfloat ao = texture(u_OcclusionSampler, pbr_vUV).r;\ncolor = mix(color, color * ao, u_OcclusionStrength);\n#endif\n#ifdef HAS_EMISSIVEMAP\nvec3 emissive = SRGBtoLINEAR(texture(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\ncolor += emissive;\n#endif\n#ifdef PBR_DEBUG\ncolor = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\ncolor = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\ncolor = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n}\nreturn vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n",defines:{LIGHTING_FRAGMENT:1},dependencies:[dt]};export{O as ShaderAssembler,m as ShaderModuleInstance,m as _ShaderModuleInstance,b as _getDependencyGraph,x as _resolveModules,jn as _warp,C as assembleShaderPairGLSL,Cn as brightnessContrast,$n as bulgePinch,H as capitalize,Yn as colorHalftone,p as combineInjects,Y as convertToVec4,Un as denoise,Nn as dirlight,ht as dirlight1,Hn as dotScreen,Vn as edgeWork,xn as fp32,rt as fp64,ot as fp64arithmetic,Zn as fxaa,q as generateShaderForModule,it as geometry1,B as getPassthroughFS,z as getQualifierDetails,I as getShaderInfo,mn as getShaderLayoutFromWGSL,t as glsl,xt as gouraudLighting,Tn as gouraudMaterial,Wn as hexagonalPixelate,Mn as hueSaturation,Gn as ink,kn as lighting,dt as lights1,qn as magnify,Rn as noise,X as normalizeShaderModule,At as pbr,En as pbrMaterial,bt as phongLighting,Sn as phongMaterial,An as picking,ct as project1,vn as random,On as sepia,Kn as swirl,Bn as tiltShift,Qn as triangleBlur,D as typeToChannelCount,Q as typeToChannelSuffix,Xn as vibrance,zn as vignette,Dn as zoomBlur};export default null;
