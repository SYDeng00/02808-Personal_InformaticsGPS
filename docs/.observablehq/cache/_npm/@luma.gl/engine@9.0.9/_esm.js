/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@luma.gl/engine@9.0.9/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{luma as e,requestAnimationFrame as t,cancelAnimationFrame as s,uid as i,assert as n,Buffer as r,getVertexFormatFromAttribute as a,log as o,RenderPipeline as h,ComputePipeline as d,Shader as u,isObjectEmpty as l,deepEqual as c,UniformStore as p,splitUniformsAndBindings as m,TextureView as f,Texture as g,Sampler as y,getAttributeInfosFromLayouts as b,getTypedArrayFromDataType as v,isNumberArray as _}from"../core@9.0.9/_esm.js";import{Stats as w}from"../../@probe.gl/stats@4.0.9/_esm.js";import{_resolveModules as x,ShaderAssembler as P,getShaderLayoutFromWGSL as C,getPassthroughFS as F}from"../shadertools@9.0.9/_esm.js";import{Matrix4 as A,Vector3 as T}from"../../@math.gl/core@4.0.1/_esm.js";let I=1,R=1;class O{time=0;channels=new Map;animations=new Map;playing=!1;lastEngineTime=-1;constructor(){}addChannel(e){const{delay:t=0,duration:s=Number.POSITIVE_INFINITY,rate:i=1,repeat:n=1}=e,r=I++,a={time:0,delay:t,duration:s,rate:i,repeat:n};return this._setChannelTime(a,this.time),this.channels.set(r,a),r}removeChannel(e){this.channels.delete(e);for(const[t,s]of this.animations)s.channel===e&&this.detachAnimation(t)}isFinished(e){const t=this.channels.get(e);return void 0!==t&&this.time>=t.delay+t.duration*t.repeat}getTime(e){if(void 0===e)return this.time;const t=this.channels.get(e);return void 0===t?-1:t.time}setTime(e){this.time=Math.max(0,e);const t=this.channels.values();for(const e of t)this._setChannelTime(e,this.time);const s=this.animations.values();for(const e of s){const{animation:t,channel:s}=e;t.setTime(this.getTime(s))}}play(){this.playing=!0}pause(){this.playing=!1,this.lastEngineTime=-1}reset(){this.setTime(0)}attachAnimation(e,t){const s=R++;return this.animations.set(s,{animation:e,channel:t}),e.setTime(this.getTime(t)),s}detachAnimation(e){this.animations.delete(e)}update(e){this.playing&&(-1===this.lastEngineTime&&(this.lastEngineTime=e),this.setTime(this.time+(e-this.lastEngineTime)),this.lastEngineTime=e)}_setChannelTime(e,t){const s=t-e.delay;s>=e.duration*e.repeat?e.time=e.duration*e.rate:(e.time=Math.max(0,s)%e.duration,e.time*=e.rate)}}class M{startIndex=-1;endIndex=-1;factor=0;times=[];values=[];_lastTime=-1;constructor(e){this.setKeyFrames(e),this.setTime(0)}setKeyFrames(e){const t=e.length;this.times.length=t,this.values.length=t;for(let s=0;s<t;++s)this.times[s]=e[s][0],this.values[s]=e[s][1];this._calculateKeys(this._lastTime)}setTime(e){(e=Math.max(0,e))!==this._lastTime&&(this._calculateKeys(e),this._lastTime=e)}getStartTime(){return this.times[this.startIndex]}getEndTime(){return this.times[this.endIndex]}getStartData(){return this.values[this.startIndex]}getEndData(){return this.values[this.endIndex]}_calculateKeys(e){let t=0;const s=this.times.length;for(t=0;t<s-2&&!(this.times[t+1]>e);++t);this.startIndex=t,this.endIndex=t+1;const i=this.times[this.startIndex],n=this.times[this.endIndex];this.factor=Math.min(Math.max(0,(e-i)/(n-i)),1)}}class D{constructor(e){}async onInitialize(e){return null}}let S=0;const z={device:null,onAddHTML:()=>"",onInitialize:async()=>null,onRender:()=>{},onFinalize:()=>{},onError:e=>console.error(e),stats:e.stats.get("animation-loop-"+S++),useDevicePixels:!0,autoResizeViewport:!1,autoResizeDrawingBuffer:!1};class N{device=null;canvas=null;props;animationProps=null;timeline=null;stats;cpuTime;gpuTime;frameRate;display;needsRedraw="initialized";_initialized=!1;_running=!1;_animationFrameId=null;_nextFramePromise=null;_resolveNextFrame=null;_cpuStartTime=0;constructor(e){if(this.props={...z,...e},!(e=this.props).device)throw new Error("No device provided");const{useDevicePixels:t=!0}=this.props;this.stats=e.stats||new w({id:"animation-loop-stats"}),this.cpuTime=this.stats.get("CPU Time"),this.gpuTime=this.stats.get("GPU Time"),this.frameRate=this.stats.get("Frame Rate"),this.setProps({autoResizeViewport:e.autoResizeViewport,autoResizeDrawingBuffer:e.autoResizeDrawingBuffer,useDevicePixels:t}),this.start=this.start.bind(this),this.stop=this.stop.bind(this),this._onMousemove=this._onMousemove.bind(this),this._onMouseleave=this._onMouseleave.bind(this)}destroy(){this.stop(),this._setDisplay(null)}delete(){this.destroy()}setNeedsRedraw(e){return this.needsRedraw=this.needsRedraw||e,this}setProps(e){return"autoResizeViewport"in e&&(this.props.autoResizeViewport=e.autoResizeViewport||!1),"autoResizeDrawingBuffer"in e&&(this.props.autoResizeDrawingBuffer=e.autoResizeDrawingBuffer||!1),"useDevicePixels"in e&&(this.props.useDevicePixels=e.useDevicePixels||!1),this}async start(){if(this._running)return this;this._running=!0;try{let e;return this._initialized||(this._initialized=!0,await this._initDevice(),this._initialize(),await this.props.onInitialize(this._getAnimationProps())),this._running?(!1!==e&&(this._cancelAnimationFrame(),this._requestAnimationFrame()),this):null}catch(e){const t=e instanceof Error?e:new Error("Unknown error");throw this.props.onError(t),t}}stop(){return this._running&&(this.animationProps&&this.props.onFinalize(this.animationProps),this._cancelAnimationFrame(),this._nextFramePromise=null,this._resolveNextFrame=null,this._running=!1),this}redraw(){return this.device?.isLost||(this._beginFrameTimers(),this._setupFrame(),this._updateAnimationProps(),this._renderFrame(this._getAnimationProps()),this._clearNeedsRedraw(),this._resolveNextFrame&&(this._resolveNextFrame(this),this._nextFramePromise=null,this._resolveNextFrame=null),this._endFrameTimers()),this}attachTimeline(e){return this.timeline=e,this.timeline}detachTimeline(){this.timeline=null}waitForRender(){return this.setNeedsRedraw("waitForRender"),this._nextFramePromise||(this._nextFramePromise=new Promise((e=>{this._resolveNextFrame=e}))),this._nextFramePromise}async toDataURL(){if(this.setNeedsRedraw("toDataURL"),await this.waitForRender(),this.canvas instanceof HTMLCanvasElement)return this.canvas.toDataURL();throw new Error("OffscreenCanvas")}_initialize(){this._startEventHandling(),this._initializeAnimationProps(),this._updateAnimationProps(),this._resizeCanvasDrawingBuffer(),this._resizeViewport()}_setDisplay(e){this.display&&(this.display.destroy(),this.display.animationLoop=null),e&&(e.animationLoop=this),this.display=e}_requestAnimationFrame(){this._running&&(this._animationFrameId=t(this._animationFrame.bind(this)))}_cancelAnimationFrame(){null!==this._animationFrameId&&(s(this._animationFrameId),this._animationFrameId=null)}_animationFrame(){this._running&&(this.redraw(),this._requestAnimationFrame())}_renderFrame(e){this.display?this.display._renderFrame(e):(this.props.onRender(this._getAnimationProps()),this.device.submit())}_clearNeedsRedraw(){this.needsRedraw=!1}_setupFrame(){this._resizeCanvasDrawingBuffer(),this._resizeViewport()}_initializeAnimationProps(){if(!this.device)throw new Error("loop");this.animationProps={animationLoop:this,device:this.device,canvas:this.device?.canvasContext?.canvas,timeline:this.timeline,useDevicePixels:this.props.useDevicePixels,needsRedraw:!1,width:1,height:1,aspect:1,time:0,startTime:Date.now(),engineTime:0,tick:0,tock:0,_mousePosition:null}}_getAnimationProps(){if(!this.animationProps)throw new Error("animationProps");return this.animationProps}_updateAnimationProps(){if(!this.animationProps)return;const{width:e,height:t,aspect:s}=this._getSizeAndAspect();e===this.animationProps.width&&t===this.animationProps.height||this.setNeedsRedraw("drawing buffer resized"),s!==this.animationProps.aspect&&this.setNeedsRedraw("drawing buffer aspect changed"),this.animationProps.width=e,this.animationProps.height=t,this.animationProps.aspect=s,this.animationProps.needsRedraw=this.needsRedraw,this.animationProps.engineTime=Date.now()-this.animationProps.startTime,this.timeline&&this.timeline.update(this.animationProps.engineTime),this.animationProps.tick=Math.floor(this.animationProps.time/1e3*60),this.animationProps.tock++,this.animationProps.time=this.timeline?this.timeline.getTime():this.animationProps.engineTime}async _initDevice(){if(this.device=await this.props.device,!this.device)throw new Error("No device provided");this.canvas=this.device.canvasContext?.canvas||null}_createInfoDiv(){if(this.canvas&&this.props.onAddHTML){const e=document.createElement("div");document.body.appendChild(e),e.style.position="relative";const t=document.createElement("div");t.style.position="absolute",t.style.left="10px",t.style.bottom="10px",t.style.width="300px",t.style.background="white",this.canvas instanceof HTMLCanvasElement&&e.appendChild(this.canvas),e.appendChild(t);const s=this.props.onAddHTML(t);s&&(t.innerHTML=s)}}_getSizeAndAspect(){if(!this.device)return{width:1,height:1,aspect:1};const[e,t]=this.device?.canvasContext?.getPixelSize()||[1,1];let s=1;const i=this.device?.canvasContext?.canvas;return i&&i.clientHeight?s=i.clientWidth/i.clientHeight:e>0&&t>0&&(s=e/t),{width:e,height:t,aspect:s}}_resizeViewport(){this.props.autoResizeViewport&&this.device.gl&&this.device.gl.viewport(0,0,this.device.gl.drawingBufferWidth,this.device.gl.drawingBufferHeight)}_resizeCanvasDrawingBuffer(){this.props.autoResizeDrawingBuffer&&this.device?.canvasContext?.resize({useDevicePixels:this.props.useDevicePixels})}_beginFrameTimers(){this.frameRate.timeEnd(),this.frameRate.timeStart(),this.cpuTime.timeStart()}_endFrameTimers(){this.cpuTime.timeEnd()}_startEventHandling(){this.canvas&&(this.canvas.addEventListener("mousemove",this._onMousemove.bind(this)),this.canvas.addEventListener("mouseleave",this._onMouseleave.bind(this)))}_onMousemove(e){e instanceof MouseEvent&&(this._getAnimationProps()._mousePosition=[e.offsetX,e.offsetY])}_onMouseleave(e){this._getAnimationProps()._mousePosition=null}}function L(t,s){let i=null;const n=s?.device||e.createDevice(),r=new N({...s,device:n,onInitialize:async e=>(i=new t(e),await(i?.onInitialize(e))),onRender:e=>i?.onRender(e),onFinalize:e=>i?.onFinalize(e)});return r.getInfo=()=>this.AnimationLoopTemplateCtor.info,r}class B{id;userData={};topology;bufferLayout=[];vertexCount;indices;attributes;constructor(e){this.id=e.id||i("geometry"),this.topology=e.topology,this.indices=e.indices||null,this.attributes=e.attributes,this.vertexCount=e.vertexCount,this.bufferLayout=e.bufferLayout||[],this.indices&&n(this.indices.usage===r.INDEX)}destroy(){this.indices?.destroy();for(const e of Object.values(this.attributes))e.destroy()}getVertexCount(){return this.vertexCount}getAttributes(){return this.attributes}getIndexes(){return this.indices}_calculateVertexCount(e){return e.byteLength/12}}function U(e,t){if(t instanceof B)return t;const s=function(e,t){if(!t.indices)return;const s=t.indices.value;return e.createBuffer({usage:r.INDEX,data:s})}(e,t),{attributes:i,bufferLayout:n}=function(e,t){const s=[],i={};for(const[n,r]of Object.entries(t.attributes)){let t=n;switch(n){case"POSITION":t="positions";break;case"NORMAL":t="normals";break;case"TEXCOORD_0":t="texCoords";break;case"COLOR_0":t="colors"}i[t]=e.createBuffer({data:r.value,id:`${n}-buffer`});const{value:o,size:h,normalized:d}=r;s.push({name:t,format:a(o,h,d)})}const n=t._calculateVertexCount(t.attributes,t.indices);return{attributes:i,bufferLayout:s,vertexCount:n}}(e,t);return new B({topology:t.topology||"triangle-list",bufferLayout:n,vertexCount:t.vertexCount,indices:s,attributes:i})}class E{modules;moduleUniforms;moduleBindings;moduleUniformsChanged;constructor(e){const t=x(Object.values(e));o.log(1,"Creating ShaderInputs with modules",t.map((e=>e.name)))(),this.modules=e,this.moduleUniforms={},this.moduleBindings={};for(const[t,s]of Object.entries(e)){const e=t;this.moduleUniforms[e]=s.defaultUniforms||{},this.moduleBindings[e]={}}}destroy(){}setProps(e){for(const t of Object.keys(e)){const s=t,i=e[s],n=this.modules[s];if(!n){o.warn(`Module ${t} not found`)();continue}const r=this.moduleUniforms[s],a=n.getUniforms?.(i,this.moduleUniforms[s])||i;this.moduleUniforms[s]={...r,...a}}}getModules(){return Object.values(this.modules)}getUniformValues(){return this.moduleUniforms}getBindings(){const e={};for(const t of Object.values(this.moduleBindings))Object.assign(e,t);return e}getDebugTable(){const e={};for(const[t,s]of Object.entries(this.moduleUniforms))for(const[i,n]of Object.entries(s))e[`${t}.${i}`]={type:this.modules[t].uniformTypes?.[i],value:String(n)};return e}}class ${static defaultProps={...h.defaultProps};device;_hashCounter=0;_hashes={};_renderPipelineCache={};_computePipelineCache={};static getDefaultPipelineFactory(e){return e._lumaData.defaultPipelineFactory=e._lumaData.defaultPipelineFactory||new $(e),e._lumaData.defaultPipelineFactory}constructor(e){this.device=e}createRenderPipeline(e){const t={...h.defaultProps,...e},s=this._hashRenderPipeline(t);if(!this._renderPipelineCache[s]){const e=this.device.createRenderPipeline({...t,id:t.id?`${t.id}-cached`:void 0});e.hash=s,this._renderPipelineCache[s]={pipeline:e,useCount:0}}return this._renderPipelineCache[s].useCount++,this._renderPipelineCache[s].pipeline}createComputePipeline(e){const t={...d.defaultProps,...e},s=this._hashComputePipeline(t);if(!this._computePipelineCache[s]){const e=this.device.createComputePipeline({...t,id:t.id?`${t.id}-cached`:void 0});e.hash=s,this._computePipelineCache[s]={pipeline:e,useCount:0}}return this._computePipelineCache[s].useCount++,this._computePipelineCache[s].pipeline}release(e){const t=e.hash,s=e instanceof d?this._computePipelineCache:this._renderPipelineCache;s[t].useCount--,0===s[t].useCount&&(s[t].pipeline.destroy(),delete s[t])}_hashComputePipeline(e){return`${this._getHash(e.shader.source)}`}_hashRenderPipeline(e){const t=this._getHash(e.vs.source),s=e.fs?this._getHash(e.fs.source):0,i=this._getHash(JSON.stringify(e.bufferLayout));if("webgl"===this.device.type)return`${t}/${s}V-BL${i}`;{const n=this._getHash(JSON.stringify(e.parameters));return`${t}/${s}V-T${e.topology}P${n}BL${i}`}}_getHash(e){return void 0===this._hashes[e]&&(this._hashes[e]=this._hashCounter++),this._hashes[e]}}class j{static defaultProps={...u.defaultProps};device;_cache={};static getDefaultShaderFactory(e){return e._lumaData.defaultShaderFactory||=new j(e),e._lumaData.defaultShaderFactory}constructor(e){this.device=e}createShader(e){const t=this._hashShader(e);let s=this._cache[t];if(!s){const i=this.device.createShader({...e,id:e.id?`${e.id}-cached`:void 0});this._cache[t]=s={shader:i,useCount:0}}return s.useCount++,s.shader}release(e){const t=this._hashShader(e),s=this._cache[t];s&&(s.useCount--,0===s.useCount&&(delete this._cache[t],s.shader.destroy()))}_hashShader(e){return`${e.stage}:${e.source}`}}let V=null,k=null;class G{static defaultProps={...h.defaultProps,source:null,vs:null,fs:null,id:"unnamed",handle:void 0,userData:{},defines:{},modules:[],moduleSettings:void 0,geometry:null,indexBuffer:null,attributes:{},constantAttributes:{},varyings:[],shaderInputs:void 0,pipelineFactory:void 0,shaderFactory:void 0,transformFeedback:void 0,shaderAssembler:P.getDefaultShaderAssembler(),debugShaders:void 0,disableWarnings:void 0};device;id;source;vs;fs;pipelineFactory;shaderFactory;userData={};parameters;topology;bufferLayout;vertexCount;instanceCount=0;indexBuffer=null;bufferAttributes={};constantAttributes={};bindings={};uniforms={};vertexArray;transformFeedback=null;pipeline;shaderInputs;_uniformStore;_attributeInfos={};_gpuGeometry=null;_getModuleUniforms;props;_pipelineNeedsUpdate="newly created";_needsRedraw="initializing";_destroyed=!1;_lastDrawTimestamp=-1;constructor(e,t){this.props={...G.defaultProps,...t},t=this.props,this.id=t.id||i("model"),this.device=e,Object.assign(this.userData,t.userData);const s=Object.fromEntries(this.props.modules?.map((e=>[e.name,e]))||[]);this.setShaderInputs(t.shaderInputs||new E(s));const n=function(e){return{type:e.type,shaderLanguage:e.info.shadingLanguage,shaderLanguageVersion:e.info.shadingLanguageVersion,gpu:e.info.gpu,features:e.features}}(e),r=(this.props.modules?.length>0?this.props.modules:this.shaderInputs?.getModules())||[];if("webgpu"===this.device.type&&this.props.source){this.props.shaderLayout||=C(this.props.source);const{source:e,getUniforms:t}=this.props.shaderAssembler.assembleShader({platformInfo:n,...this.props,modules:r});this.source=e,this._getModuleUniforms=t}else{const{vs:e,fs:t,getUniforms:s}=this.props.shaderAssembler.assembleShaderPair({platformInfo:n,...this.props,modules:r});this.vs=e,this.fs=t,this._getModuleUniforms=s}this.vertexCount=this.props.vertexCount,this.instanceCount=this.props.instanceCount,this.topology=this.props.topology,this.bufferLayout=this.props.bufferLayout,this.parameters=this.props.parameters,t.geometry&&this.setGeometry(t.geometry),this.pipelineFactory=t.pipelineFactory||$.getDefaultPipelineFactory(this.device),this.shaderFactory=t.shaderFactory||j.getDefaultShaderFactory(this.device),this.pipeline=this._updatePipeline(),this.vertexArray=e.createVertexArray({renderPipeline:this.pipeline}),this._gpuGeometry&&this._setGeometryAttributes(this._gpuGeometry),t.vertexCount&&this.setVertexCount(t.vertexCount),t.instanceCount&&this.setInstanceCount(t.instanceCount),t.indexBuffer&&this.setIndexBuffer(t.indexBuffer),t.attributes&&this.setAttributes(t.attributes),t.constantAttributes&&this.setConstantAttributes(t.constantAttributes),t.bindings&&this.setBindings(t.bindings),t.uniforms&&this.setUniforms(t.uniforms),t.moduleSettings&&this.updateModuleSettings(t.moduleSettings),t.transformFeedback&&(this.transformFeedback=t.transformFeedback),Object.seal(this)}destroy(){this._destroyed||(this.pipelineFactory.release(this.pipeline),this.shaderFactory.release(this.pipeline.vs),this.pipeline.fs&&this.shaderFactory.release(this.pipeline.fs),this._uniformStore.destroy(),this._gpuGeometry?.destroy(),this._destroyed=!0)}needsRedraw(){this._getBindingsUpdateTimestamp()>this._lastDrawTimestamp&&this.setNeedsRedraw("contents of bound textures or buffers updated");const e=this._needsRedraw;return this._needsRedraw=!1,e}setNeedsRedraw(e){this._needsRedraw||=e}predraw(){this.updateShaderInputs(),this.pipeline=this._updatePipeline()}draw(e){let t;this.predraw();try{this._logDrawCallStart(),this.pipeline=this._updatePipeline(),this.pipeline.setBindings(this.bindings,{disableWarnings:this.props.disableWarnings}),l(this.uniforms)||this.pipeline.setUniformsWebGL(this.uniforms);const{indexBuffer:s}=this.vertexArray,i=s?s.byteLength/("uint32"===s.indexType?4:2):void 0;t=this.pipeline.draw({renderPass:e,vertexArray:this.vertexArray,vertexCount:this.vertexCount,instanceCount:this.instanceCount,indexCount:i,transformFeedback:this.transformFeedback||void 0,parameters:this.parameters,topology:this.topology})}finally{this._logDrawCallEnd()}return this._logFramebuffer(e),t?(this._lastDrawTimestamp=this.device.timestamp,this._needsRedraw=!1):this._needsRedraw="waiting for resource initialization",t}setGeometry(e){this._gpuGeometry?.destroy();const t=e&&U(this.device,e);t&&(this.setTopology(t.topology||"triangle-list"),this.bufferLayout=W(t.bufferLayout,this.bufferLayout),this.vertexArray&&this._setGeometryAttributes(t)),this._gpuGeometry=t}setTopology(e){e!==this.topology&&(this.topology=e,this._setPipelineNeedsUpdate("topology"))}setBufferLayout(e){this.bufferLayout=this._gpuGeometry?W(e,this._gpuGeometry.bufferLayout):e,this._setPipelineNeedsUpdate("bufferLayout"),this.pipeline=this._updatePipeline(),this.vertexArray=this.device.createVertexArray({renderPipeline:this.pipeline}),this._gpuGeometry&&this._setGeometryAttributes(this._gpuGeometry)}setParameters(e){c(e,this.parameters,2)||(this.parameters=e,this._setPipelineNeedsUpdate("parameters"))}setVertexCount(e){this.vertexCount=e,this.setNeedsRedraw("vertexCount")}setInstanceCount(e){this.instanceCount=e,this.setNeedsRedraw("instanceCount")}setShaderInputs(e){this.shaderInputs=e,this._uniformStore=new p(this.shaderInputs.modules);for(const e of Object.keys(this.shaderInputs.modules)){const t=this._uniformStore.getManagedUniformBuffer(this.device,e);this.bindings[`${e}Uniforms`]=t}this.setNeedsRedraw("shaderInputs")}updateShaderInputs(){this._uniformStore.setUniforms(this.shaderInputs.getUniformValues()),this.setNeedsRedraw("shaderInputs")}setBindings(e){Object.assign(this.bindings,e),this.setNeedsRedraw("bindings")}setTransformFeedback(e){this.transformFeedback=e,this.setNeedsRedraw("transformFeedback")}setIndexBuffer(e){this.vertexArray.setIndexBuffer(e),this.setNeedsRedraw("indexBuffer")}setAttributes(e,t){e.indices&&o.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();for(const[s,i]of Object.entries(e)){const e=this.bufferLayout.find((e=>H(e).includes(s)));if(!e){o.warn(`Model(${this.id}): Missing layout for buffer "${s}".`)();continue}const n=H(e);let r=!1;for(const e of n){const t=this._attributeInfos[e];t&&(this.vertexArray.setBuffer(t.location,i),r=!0)}r||(t?.disableWarnings??this.props.disableWarnings)||o.warn(`Model(${this.id}): Ignoring buffer "${i.id}" for unknown attribute "${s}"`)()}this.setNeedsRedraw("attributes")}setConstantAttributes(e,t){for(const[s,i]of Object.entries(e)){const e=this._attributeInfos[s];e?this.vertexArray.setConstantWebGL(e.location,i):(t?.disableWarnings??this.props.disableWarnings)||o.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${s}"`)()}this.setNeedsRedraw("constants")}setUniforms(e){l(e)||(this.pipeline.setUniformsWebGL(e),Object.assign(this.uniforms,e)),this.setNeedsRedraw("uniforms")}updateModuleSettings(e){const{bindings:t,uniforms:s}=m(this._getModuleUniforms(e));Object.assign(this.bindings,t),Object.assign(this.uniforms,s),this.setNeedsRedraw("moduleSettings")}_getBindingsUpdateTimestamp(){let e=0;for(const t of Object.values(this.bindings))t instanceof f?e=Math.max(e,t.texture.updateTimestamp):t instanceof r||t instanceof g?e=Math.max(e,t.updateTimestamp):t instanceof y||(e=Math.max(e,t.buffer.updateTimestamp));return e}_setGeometryAttributes(e){const t={...e.attributes};for(const[e]of Object.entries(t))this.pipeline.shaderLayout.attributes.find((t=>t.name===e))||"positions"===e||delete t[e];this.vertexCount=e.vertexCount,this.setIndexBuffer(e.indices||null),this.setAttributes(e.attributes,{disableWarnings:!0}),this.setAttributes(t,{disableWarnings:this.props.disableWarnings}),this.setNeedsRedraw("geometry attributes")}_setPipelineNeedsUpdate(e){this._pipelineNeedsUpdate||=e,this.setNeedsRedraw(e)}_updatePipeline(){if(this._pipelineNeedsUpdate){let e=null,t=null;this.pipeline&&(o.log(1,`Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(),e=this.pipeline.vs,t=this.pipeline.fs),this._pipelineNeedsUpdate=!1;const s=this.shaderFactory.createShader({id:`${this.id}-vertex`,stage:"vertex",source:this.source||this.vs,debug:this.props.debugShaders});let i=null;this.source?i=s:this.fs&&(i=this.shaderFactory.createShader({id:`${this.id}-fragment`,stage:"fragment",source:this.source||this.fs,debug:this.props.debugShaders})),this.pipeline=this.pipelineFactory.createRenderPipeline({...this.props,bufferLayout:this.bufferLayout,topology:this.topology,parameters:this.parameters,vs:s,fs:i}),this._attributeInfos=b(this.pipeline.shaderLayout,this.bufferLayout),e&&this.shaderFactory.release(e),t&&this.shaderFactory.release(t)}return this.pipeline}_lastLogTime=0;_logOpen=!1;_logDrawCallStart(){const e=o.level>3?0:1e4;o.level<2||Date.now()-this._lastLogTime<e||(this._lastLogTime=Date.now(),this._logOpen=!0,o.group(2,`>>> DRAWING MODEL ${this.id}`,{collapsed:o.level<=2})())}_logDrawCallEnd(){if(this._logOpen){const e=function(e,t){const s={},i="Values";if(0===e.attributes.length&&!e.varyings?.length)return{"No attributes or varyings":{[i]:"N/A"}};for(const t of e.attributes)t&&(s[`in ${t.location} ${t.name}: ${t.type}`]={[i]:t.stepMode||"vertex"});for(const t of e.varyings||[])s[`out ${t.location} ${t.name}`]={[i]:JSON.stringify(t.accessor)};return s}(this.pipeline.shaderLayout,this.id);o.table(2,e)();const t=this.shaderInputs.getDebugTable();for(const[e,s]of Object.entries(this.uniforms))t[e]={value:s};o.table(2,t)();const s=this._getAttributeDebugTable();o.table(2,this._attributeInfos)(),o.table(2,s)(),o.groupEnd(2)(),this._logOpen=!1}}_drawCount=0;_logFramebuffer(e){const t=o.get("framebuffer");if(this._drawCount++,!t||this._drawCount++>3&&this._drawCount%60)return;const s=e.props.framebuffer;s&&function(e,{id:t,minimap:s,opaque:i,top:n="0",left:r="0",rgbaScale:a=1}){V||(V=document.createElement("canvas"),V.id=t,V.title=t,V.style.zIndex="100",V.style.position="absolute",V.style.top=n,V.style.left=r,V.style.border="blue 1px solid",V.style.transform="scaleY(-1)",document.body.appendChild(V),k=V.getContext("2d")),V.width===e.width&&V.height===e.height||(V.width=e.width/2,V.height=e.height/2,V.style.width="400px",V.style.height="400px");const o=e.device.readPixelsToArrayWebGL(e),h=k.createImageData(e.width,e.height);for(let e=0;e<o.length;e+=4)h.data[0+e+0]=o[e+0]*a,h.data[0+e+1]=o[e+1]*a,h.data[0+e+2]=o[e+2]*a,h.data[0+e+3]=i?255:o[e+3]*a;k.putImageData(h,0,0)}(s,{id:s.id,minimap:!0})}_getAttributeDebugTable(){const e={};for(const[t,s]of Object.entries(this._attributeInfos))e[s.location]={name:t,type:s.shaderType,values:this._getBufferOrConstantValues(this.vertexArray.attributes[s.location],s.bufferDataType)};if(this.vertexArray.indexBuffer){const{indexBuffer:t}=this.vertexArray,s="uint32"===t.indexType?new Uint32Array(t.debugData):new Uint16Array(t.debugData);e.indices={name:"indices",type:t.indexType,values:s.toString()}}return e}_getBufferOrConstantValues(e,t){const s=v(t);return(e instanceof r?new s(e.debugData):e).toString()}}function W(e,t){const s=[...e];for(const e of t){const t=s.findIndex((t=>t.name===e.name));t<0?s.push(e):s[t]=e}return s}function H(e){return e.attributes?e.attributes?.map((e=>e.attribute)):[e.name]}class X{device;model;transformFeedback;static isSupported(e){return"webgl"===e?.info?.type}constructor(e,t=G.defaultProps){n(X.isSupported(e),"BufferTransform not yet implemented on WebGPU"),this.device=e,this.model=new G(this.device,{id:t.id||"buffer-transform-model",fs:t.fs||F(),topology:t.topology||"point-list",...t}),this.transformFeedback=this.device.createTransformFeedback({layout:this.model.pipeline.shaderLayout,buffers:t.feedbackBuffers}),this.model.setTransformFeedback(this.transformFeedback),Object.seal(this)}destroy(){this.model&&this.model.destroy()}delete(){this.destroy()}run(e){const t=this.device.beginRenderPass(e);this.model.draw(t),t.end()}update(...e){console.warn("TextureTransform#update() not implemented")}getBuffer(e){return this.transformFeedback.getBuffer(e)}readAsync(e){const t=this.getBuffer(e);if(t instanceof r)return t.readAsync();const{buffer:s,byteOffset:i=0,byteLength:n=s.byteLength}=t;return s.readAsync(i,n)}}class q{device;model;sampler;currentIndex=0;samplerTextureMap=null;bindings=[];resources={};constructor(e,t){this.device=e,this.sampler=e.createSampler({addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",minFilter:"nearest",magFilter:"nearest",mipmapFilter:"nearest"}),this.model=new G(this.device,{id:t.id||"texture-transform-model",fs:t.fs||F({input:t.targetTextureVarying,inputChannels:t.targetTextureChannels,output:"transform_output"}),vertexCount:t.vertexCount,...t}),this._initialize(t),Object.seal(this)}destroy(){}delete(){this.destroy()}run(e){const{framebuffer:t}=this.bindings[this.currentIndex],s=this.device.beginRenderPass({framebuffer:t,...e});this.model.draw(s),s.end()}update(...e){console.warn("TextureTransform#update() not implemented")}getData({packed:e=!1}={}){throw new Error("getData() not implemented")}getTargetTexture(){const{targetTexture:e}=this.bindings[this.currentIndex];return e}getFramebuffer(){return this.bindings[this.currentIndex].framebuffer}_initialize(e){this._updateBindings(e)}_updateBindings(e){this.bindings[this.currentIndex]=this._updateBinding(this.bindings[this.currentIndex],e)}_updateBinding(e,{sourceBuffers:t,sourceTextures:s,targetTexture:i}){if(e||(e={sourceBuffers:{},sourceTextures:{},targetTexture:null}),Object.assign(e.sourceTextures,s),Object.assign(e.sourceBuffers,t),i){e.targetTexture=i;const{width:t,height:s}=i;e.framebuffer&&e.framebuffer.destroy(),e.framebuffer=this.device.createFramebuffer({id:"transform-framebuffer",width:t,height:s,colorAttachments:[i]}),e.framebuffer.resize({width:t,height:s})}return e}_setSourceTextureParameters(){const e=this.currentIndex,{sourceTextures:t}=this.bindings[e];for(const e in t)t[e].sampler=this.sampler}}class K{id;topology;vertexCount;indices;attributes;userData={};constructor(e){const{attributes:t={},indices:s=null,vertexCount:r=null}=e;this.id=e.id||i("geometry"),this.topology=e.topology,s&&(this.indices=ArrayBuffer.isView(s)?{value:s,size:1}:s),this.attributes={};for(const[e,s]of Object.entries(t)){const t=ArrayBuffer.isView(s)?{value:s}:s;n(ArrayBuffer.isView(t.value),`${this._print(e)}: must be typed array or object with value as typed array`),"POSITION"!==e&&"positions"!==e||t.size||(t.size=3),"indices"===e?(n(!this.indices),this.indices=t):this.attributes[e]=t}this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this.vertexCount=r||this._calculateVertexCount(this.attributes,this.indices)}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(e){return`Geometry ${this.id} attribute ${e}`}_setAttributes(e,t){return this}_calculateVertexCount(e,t){if(t)return t.value.length;let s=1/0;for(const t of Object.values(e)){const{value:e,size:i,constant:n}=t;!n&&e&&i>=1&&(s=Math.min(s,e.length/i))}return n(Number.isFinite(s)),s}}const Y=[-1,-1,1,-1,-1,1,1,1];class J extends G{constructor(e,t){const s=Y.map((e=>-1===e?0:e));super(e,{...t,vs:"#version 300 es\nin vec2 aClipSpacePosition;\nin vec2 aTexCoord;\nin vec2 aCoordinate;\nout vec2 position;\nout vec2 coordinate;\nout vec2 uv;\nvoid main(void) {\ngl_Position = vec4(aClipSpacePosition, 0., 1.);\nposition = aClipSpacePosition;\ncoordinate = aCoordinate;\nuv = aTexCoord;\n}\n",vertexCount:4,geometry:new K({topology:"triangle-strip",vertexCount:4,attributes:{aClipSpacePosition:{size:2,value:new Float32Array(Y)},aTexCoord:{size:2,value:new Float32Array(s)},aCoordinate:{size:2,value:new Float32Array(s)}}})})}}class Z{id;matrix=new A;display=!0;position=new T;rotation=new T;scale=new T(1,1,1);userData={};props={};constructor(e={}){const{id:t}=e;this.id=t||i(this.constructor.name),this._setScenegraphNodeProps(e)}getBounds(){return null}destroy(){}delete(){this.destroy()}setProps(e){return this._setScenegraphNodeProps(e),this}toString(){return`{type: ScenegraphNode, id: ${this.id})}`}setPosition(e){return n(3===e.length,"setPosition requires vector argument"),this.position=e,this}setRotation(e){return n(3===e.length,"setRotation requires vector argument"),this.rotation=e,this}setScale(e){return n(3===e.length,"setScale requires vector argument"),this.scale=e,this}setMatrix(e,t=!0){t?this.matrix.copy(e):this.matrix=e}setMatrixComponents(e){const{position:t,rotation:s,scale:i,update:n=!0}=e;return t&&this.setPosition(t),s&&this.setRotation(s),i&&this.setScale(i),n&&this.updateMatrix(),this}updateMatrix(){const e=this.position,t=this.rotation,s=this.scale;return this.matrix.identity(),this.matrix.translate(e),this.matrix.rotateXYZ(t),this.matrix.scale(s),this}update(e={}){const{position:t,rotation:s,scale:i}=e;return t&&this.setPosition(t),s&&this.setRotation(s),i&&this.setScale(i),this.updateMatrix(),this}getCoordinateUniforms(e,t){n(e),t=t||this.matrix;const s=new A(e).multiplyRight(t),i=s.invert(),r=i.transpose();return{viewMatrix:e,modelMatrix:t,objectMatrix:t,worldMatrix:s,worldInverseMatrix:i,worldInverseTransposeMatrix:r}}_setScenegraphNodeProps(e){"display"in e&&(this.display=e.display),"position"in e&&this.setPosition(e.position),"rotation"in e&&this.setRotation(e.rotation),"scale"in e&&this.setScale(e.scale),"matrix"in e&&this.setMatrix(e.matrix),Object.assign(this.props,e)}}class Q extends Z{children;constructor(e={}){e=Array.isArray(e)?{children:e}:e;const{children:t=[]}=e;o.assert(t.every((e=>e instanceof Z)),"every child must an instance of ScenegraphNode"),super(e),this.children=t}getBounds(){const e=[[1/0,1/0,1/0],[-1/0,-1/0,-1/0]];return this.traverse(((t,{worldMatrix:s})=>{const i=t.getBounds();if(!i)return;const[n,r]=i,a=new T(n).add(r).divide([2,2,2]);s.transformAsPoint(a,a);const o=new T(r).subtract(n).divide([2,2,2]);s.transformAsVector(o,o);for(let t=0;t<8;t++){const s=new T(1&t?-1:1,2&t?-1:1,4&t?-1:1).multiply(o).add(a);for(let t=0;t<3;t++)e[0][t]=Math.min(e[0][t],s[t]),e[1][t]=Math.max(e[1][t],s[t])}})),Number.isFinite(e[0][0])?e:null}destroy(){this.children.forEach((e=>e.destroy())),this.removeAll(),super.destroy()}add(...e){for(const t of e)Array.isArray(t)?this.add(...t):this.children.push(t);return this}remove(e){const t=this.children,s=t.indexOf(e);return s>-1&&t.splice(s,1),this}removeAll(){return this.children=[],this}traverse(e,{worldMatrix:t=new A}={}){const s=new A(t).multiplyRight(this.matrix);for(const t of this.children)t instanceof Q?t.traverse(e,{worldMatrix:s}):e(t,{worldMatrix:s})}}class ee extends Z{model;bounds=null;managedResources;constructor(e){super(e),this.model=e.model,this.managedResources=e.managedResources||[],this.bounds=e.bounds||null,this.setProps(e)}getBounds(){return this.bounds}destroy(){this.model&&(this.model.destroy(),this.model=null),this.managedResources.forEach((e=>e.destroy())),this.managedResources=[]}draw(e){return this.model.draw(e)}}const te={x:[2,0,1],y:[0,1,2],z:[1,2,0]};class se extends K{constructor(e={}){const{id:t=i("truncated-code-geometry")}=e,{indices:s,attributes:n}=function(e={}){const{bottomRadius:t=0,topRadius:s=0,height:i=1,nradial:n=10,nvertical:r=10,verticalAxis:a="y",topCap:o=!1,bottomCap:h=!1}=e,d=(o?2:0)+(h?2:0),u=(n+1)*(r+1+d),l=Math.atan2(t-s,i),c=Math.sin,p=Math.cos,m=Math.PI,f=p(l),g=c(l),y=o?-2:0,b=r+(h?2:0),v=n+1,_=new Uint16Array(n*(r+d)*6),w=te[a],x=new Float32Array(3*u),P=new Float32Array(3*u),C=new Float32Array(2*u);let F=0,A=0;for(let e=y;e<=b;e++){let a,o=e/r,h=i*o;e<0?(h=0,o=1,a=t):e>r?(h=i,o=1,a=s):a=t+e/r*(s-t),-2!==e&&e!==r+2||(a=0,o=0),h-=i/2;for(let t=0;t<v;t++){const s=c(t*m*2/n),i=p(t*m*2/n);x[F+w[0]]=s*a,x[F+w[1]]=h,x[F+w[2]]=i*a,P[F+w[0]]=e<0||e>r?0:s*f,P[F+w[1]]=e<0?-1:e>r?1:g,P[F+w[2]]=e<0||e>r?0:i*f,C[A+0]=t/n,C[A+1]=o,A+=2,F+=3}}for(let e=0;e<r+d;e++)for(let t=0;t<n;t++){const s=6*(e*n+t);_[s+0]=v*(e+0)+0+t,_[s+1]=v*(e+0)+1+t,_[s+2]=v*(e+1)+1+t,_[s+3]=v*(e+0)+0+t,_[s+4]=v*(e+1)+1+t,_[s+5]=v*(e+1)+0+t}return{indices:_,attributes:{POSITION:x,NORMAL:P,TEXCOORD_0:C}}}(e);super({...e,id:t,topology:"triangle-list",indices:s,attributes:{POSITION:{size:3,value:n.POSITION},NORMAL:{size:3,value:n.NORMAL},TEXCOORD_0:{size:2,value:n.TEXCOORD_0},...e.attributes}})}}class ie extends se{constructor(e={}){const{id:t=i("cone-geometry"),radius:s=1,cap:n=!0}=e;super({...e,id:t,topRadius:0,topCap:Boolean(n),bottomCap:Boolean(n),bottomRadius:s})}}class ne extends K{constructor(e={}){const{id:t=i("cube-geometry"),indices:s=!0}=e;super(s?{...e,id:t,topology:"triangle-list",indices:{size:1,value:re},attributes:{...ce,...e.attributes}}:{...e,id:t,topology:"triangle-list",indices:void 0,attributes:{...pe,...e.attributes}})}}const re=new Uint16Array([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]),ae=new Float32Array([-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1]),oe=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0]),he=new Float32Array([0,0,1,0,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,0,1,1,0,1,0,0,0,0,1,0,1,1,0,1]),de=new Float32Array([1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,-1,-1,1,1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1]),ue=new Float32Array([1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,0,0]),le=new Float32Array([1,0,1,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,1,0,0,1,0,1,0,1]),ce={POSITION:{size:3,value:ae},NORMAL:{size:3,value:oe},TEXCOORD_0:{size:2,value:he}},pe={POSITION:{size:3,value:de},TEXCOORD_0:{size:2,value:ue},COLOR_0:{size:3,value:le}};class me extends se{constructor(e={}){const{id:t=i("cylinder-geometry"),radius:s=1}=e;super({...e,id:t,bottomRadius:s,topRadius:s})}}const fe=[-1,0,0,0,1,0,0,0,-1,0,0,1,0,-1,0,1,0,0],ge=[3,4,5,3,5,1,3,1,0,3,0,4,4,0,2,4,2,5,2,0,1,5,2,1];class ye extends K{constructor(e={}){const{id:t=i("ico-sphere-geometry")}=e,{indices:s,attributes:n}=function(e){const{iterations:t=0}=e,s=Math.PI,i=2*s,n=[...fe];let r=[...ge];n.push(),r.push();const a=(()=>{const e={};return(t,s)=>{const i=`${(t*=3)<(s*=3)?t:s}|${t>s?t:s}`;if(i in e)return e[i];const r=n[t],a=n[t+1],o=n[t+2];let h=(r+n[s])/2,d=(a+n[s+1])/2,u=(o+n[s+2])/2;const l=Math.sqrt(h*h+d*d+u*u);return h/=l,d/=l,u/=l,n.push(h,d,u),e[i]=n.length/3-1}})();for(let e=0;e<t;e++){const e=[];for(let t=0;t<r.length;t+=3){const s=a(r[t+0],r[t+1]),i=a(r[t+1],r[t+2]),n=a(r[t+2],r[t+0]);e.push(n,r[t+0],s,s,r[t+1],i,i,r[t+2],n,s,i,n)}r=e}const o=new Array(n.length),h=new Array(n.length/3*2);for(let e=r.length-3;e>=0;e-=3){const t=r[e+0],a=r[e+1],d=r[e+2],u=3*t,l=3*a,c=3*d,p=2*t,m=2*a,f=2*d,g=n[u+0],y=n[u+1],b=n[u+2],v=Math.acos(b/Math.sqrt(g*g+y*y+b*b))/s,_=1-(Math.atan2(y,g)+s)/i,w=n[l+0],x=n[l+1],P=n[l+2],C=Math.acos(P/Math.sqrt(w*w+x*x+P*P))/s,F=1-(Math.atan2(x,w)+s)/i,A=n[c+0],I=n[c+1],R=n[c+2],O=Math.acos(R/Math.sqrt(A*A+I*I+R*R))/s,M=1-(Math.atan2(I,A)+s)/i,D=[g-w,y-x,b-P],S=new T([A-w,I-x,R-P]).cross(D).normalize();let z;(0===_||0===F||0===M)&&(0===_||_>.5)&&(0===F||F>.5)&&(0===M||M>.5)&&(n.push(n[u+0],n[u+1],n[u+2]),z=n.length/3-1,r.push(z),h[2*z+0]=1,h[2*z+1]=v,o[3*z+0]=S.x,o[3*z+1]=S.y,o[3*z+2]=S.z,n.push(n[l+0],n[l+1],n[l+2]),z=n.length/3-1,r.push(z),h[2*z+0]=1,h[2*z+1]=C,o[3*z+0]=S.x,o[3*z+1]=S.y,o[3*z+2]=S.z,n.push(n[c+0],n[c+1],n[c+2]),z=n.length/3-1,r.push(z),h[2*z+0]=1,h[2*z+1]=O,o[3*z+0]=S.x,o[3*z+1]=S.y,o[3*z+2]=S.z),o[u+0]=o[l+0]=o[c+0]=S.x,o[u+1]=o[l+1]=o[c+1]=S.y,o[u+2]=o[l+2]=o[c+2]=S.z,h[p+0]=_,h[p+1]=v,h[m+0]=F,h[m+1]=C,h[f+0]=M,h[f+1]=O}return{indices:{size:1,value:new Uint16Array(r)},attributes:{POSITION:{size:3,value:new Float32Array(n)},NORMAL:{size:3,value:new Float32Array(o)},TEXCOORD_0:{size:2,value:new Float32Array(h)}}}}(e);super({...e,id:t,topology:"triangle-list",indices:s,attributes:{...n,...e.attributes}})}}class be extends K{constructor(e={}){const{id:t=i("plane-geometry")}=e,{indices:s,attributes:n}=function(e){const{type:t="x,y",offset:s=0,flipCull:i=!1,unpack:n=!1}=e,r=t.split(",");let a=e[`${r[0]}len`]||1;const o=e[`${r[1]}len`]||1,h=e[`n${r[0]}`]||1,d=e[`n${r[1]}`]||1,u=(h+1)*(d+1),l=new Float32Array(3*u),c=new Float32Array(3*u),p=new Float32Array(2*u);i&&(a=-a);let m=0,f=0;for(let e=0;e<=d;e++)for(let n=0;n<=h;n++){const r=n/h,u=e/d;switch(p[m+0]=i?1-r:r,p[m+1]=u,t){case"x,y":l[f+0]=a*r-.5*a,l[f+1]=o*u-.5*o,l[f+2]=s,c[f+0]=0,c[f+1]=0,c[f+2]=i?1:-1;break;case"x,z":l[f+0]=a*r-.5*a,l[f+1]=s,l[f+2]=o*u-.5*o,c[f+0]=0,c[f+1]=i?1:-1,c[f+2]=0;break;case"y,z":l[f+0]=s,l[f+1]=a*r-.5*a,l[f+2]=o*u-.5*o,c[f+0]=i?1:-1,c[f+1]=0,c[f+2]=0;break;default:throw new Error("PlaneGeometry: unknown type")}m+=2,f+=3}const g=h+1,y=new Uint16Array(h*d*6);for(let e=0;e<d;e++)for(let t=0;t<h;t++){const s=6*(e*h+t);y[s+0]=(e+0)*g+t,y[s+1]=(e+1)*g+t,y[s+2]=(e+0)*g+t+1,y[s+3]=(e+1)*g+t,y[s+4]=(e+1)*g+t+1,y[s+5]=(e+0)*g+t+1}const b={indices:{size:1,value:y},attributes:{POSITION:{size:3,value:l},NORMAL:{size:3,value:c},TEXCOORD_0:{size:2,value:p}}};return n?function(e){const{indices:t,attributes:s}=e;if(!t)return e;const i=t.value.length,n={};for(const e in s){const r=s[e],{constant:a,value:o,size:h}=r;if(a||!h)continue;const d=new o.constructor(i*h);for(let e=0;e<i;++e){const s=t.value[e];for(let t=0;t<h;t++)d[e*h+t]=o[s*h+t]}n[e]={size:h,value:d}}return{attributes:Object.assign({},s,n)}}(b):b}(e);super({...e,id:t,topology:"triangle-list",indices:s,attributes:{...n,...e.attributes}})}}class ve extends K{constructor(e={}){const{id:t=i("sphere-geometry")}=e,{indices:s,attributes:n}=function(e){const{nlat:t=10,nlong:s=10}=e,i=0,n=Math.PI-i,r=0,a=2*Math.PI-r,o=(t+1)*(s+1),h=(t,s,i,n,r)=>e.radius||1,d=new Float32Array(3*o),u=new Float32Array(3*o),l=new Float32Array(2*o),c=new(o>65535?Uint32Array:Uint16Array)(t*s*6);for(let e=0;e<=t;e++)for(let i=0;i<=s;i++){const r=i/s,o=e/t,c=i+e*(s+1),p=2*c,m=3*c,f=a*r,g=n*o,y=Math.sin(f),b=Math.cos(f),v=Math.sin(g),_=b*v,w=Math.cos(g),x=y*v,P=h();d[m+0]=P*_,d[m+1]=P*w,d[m+2]=P*x,u[m+0]=_,u[m+1]=w,u[m+2]=x,l[p+0]=r,l[p+1]=1-o}const p=s+1;for(let e=0;e<s;e++)for(let s=0;s<t;s++){const i=6*(e*t+s);c[i+0]=s*p+e,c[i+1]=s*p+e+1,c[i+2]=(s+1)*p+e,c[i+3]=(s+1)*p+e,c[i+4]=s*p+e+1,c[i+5]=(s+1)*p+e+1}return{indices:{size:1,value:c},attributes:{POSITION:{size:3,value:d},NORMAL:{size:3,value:u},TEXCOORD_0:{size:2,value:l}}}}(e);super({...e,id:t,topology:"triangle-list",indices:s,attributes:{...n,...e.attributes}})}}class _e{static defaultProps={...d.defaultProps,id:"unnamed",handle:void 0,userData:{},source:"",modules:[],defines:{},bindings:void 0,shaderInputs:void 0,pipelineFactory:void 0,shaderFactory:void 0,shaderAssembler:P.getDefaultShaderAssembler(),debugShaders:void 0};device;id;pipelineFactory;shaderFactory;userData={};bindings={};pipeline;shader;source;shaderInputs;_uniformStore;_pipelineNeedsUpdate="newly created";_getModuleUniforms;props;_destroyed=!1;constructor(e,t){if("webgpu"!==e.type)throw new Error("Computation is only supported in WebGPU");this.props={..._e.defaultProps,...t},t=this.props,this.id=t.id||i("model"),this.device=e,Object.assign(this.userData,t.userData);const s=Object.fromEntries(this.props.modules?.map((e=>[e.name,e]))||[]);this.setShaderInputs(t.shaderInputs||new E(s)),this.props.shaderLayout||=C(this.props.source);const n=function(e){return{type:e.type,shaderLanguage:e.info.shadingLanguage,shaderLanguageVersion:e.info.shadingLanguageVersion,gpu:e.info.gpu,features:e.features}}(e),r=(this.props.modules?.length>0?this.props.modules:this.shaderInputs?.getModules())||[];this.pipelineFactory=t.pipelineFactory||$.getDefaultPipelineFactory(this.device),this.shaderFactory=t.shaderFactory||j.getDefaultShaderFactory(this.device);const{source:a,getUniforms:o}=this.props.shaderAssembler.assembleShader({platformInfo:n,...this.props,modules:r});this.source=a,this._getModuleUniforms=o,this.pipeline=this._updatePipeline(),t.bindings&&this.setBindings(t.bindings),Object.seal(this)}destroy(){this._destroyed||(this.pipelineFactory.release(this.pipeline),this.shaderFactory.release(this.shader),this._uniformStore.destroy(),this._destroyed=!0)}predraw(){this.updateShaderInputs()}dispatch(e,t,s,i){try{this._logDrawCallStart(),this.pipeline=this._updatePipeline(),this.pipeline.setBindings(this.bindings),e.setPipeline(this.pipeline),e.setBindings([]),e.dispatch(t,s,i)}finally{this._logDrawCallEnd()}}setVertexCount(e){}setInstanceCount(e){}setShaderInputs(e){this.shaderInputs=e,this._uniformStore=new p(this.shaderInputs.modules);for(const e of Object.keys(this.shaderInputs.modules)){const t=this._uniformStore.getManagedUniformBuffer(this.device,e);this.bindings[`${e}Uniforms`]=t}}setShaderModuleProps(e){const t=this._getModuleUniforms(e),s=Object.keys(t).filter((e=>{const s=t[e];return!_(s)&&"number"!=typeof s&&"boolean"!=typeof s}));for(const e of s)t[e],delete t[e]}updateShaderInputs(){this._uniformStore.setUniforms(this.shaderInputs.getUniformValues())}setBindings(e){Object.assign(this.bindings,e)}_setPipelineNeedsUpdate(e){this._pipelineNeedsUpdate=this._pipelineNeedsUpdate||e}_updatePipeline(){if(this._pipelineNeedsUpdate){let e=null;this.pipeline&&(o.log(1,`Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(),e=this.shader),this._pipelineNeedsUpdate=!1,this.shader=this.shaderFactory.createShader({id:`${this.id}-fragment`,stage:"compute",source:this.source,debug:this.props.debugShaders}),this.pipeline=this.pipelineFactory.createComputePipeline({...this.props,shader:this.shader}),e&&this.shaderFactory.release(e)}return this.pipeline}_lastLogTime=0;_logOpen=!1;_logDrawCallStart(){const e=o.level>3?0:1e4;o.level<2||Date.now()-this._lastLogTime<e||(this._lastLogTime=Date.now(),this._logOpen=!0,o.group(2,`>>> DRAWING MODEL ${this.id}`,{collapsed:o.level<=2})())}_logDrawCallEnd(){if(this._logOpen){const e=this.shaderInputs.getDebugTable();o.table(2,e)(),o.groupEnd(2)(),this._logOpen=!1}}_drawCount=0;_getBufferOrConstantValues(e,t){const s=v(t);return(e instanceof r?new s(e.debugData):e).toString()}}export{N as AnimationLoop,D as AnimationLoopTemplate,X as BufferTransform,J as ClipSpace,_e as Computation,ie as ConeGeometry,ne as CubeGeometry,me as CylinderGeometry,B as GPUGeometry,K as Geometry,Q as GroupNode,ye as IcoSphereGeometry,M as KeyFrames,G as Model,ee as ModelNode,$ as PipelineFactory,be as PlaneGeometry,Z as ScenegraphNode,j as ShaderFactory,ve as SphereGeometry,q as TextureTransform,O as Timeline,se as TruncatedConeGeometry,E as _ShaderInputs,L as makeAnimationLoop};export default null;
