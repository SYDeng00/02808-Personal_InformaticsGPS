/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@math.gl/geospatial@4.0.1/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Vector3 as e,config as t,toRadians as r,toDegrees as a,assert as o,equals as n,_MathUtils as i,vec3 as s,Matrix4 as c}from"../core@4.0.1/_esm.js";const u=6378137,h=6378137,d=6356752.314245179,l={radii:[u,h,d],radiiSquared:[40680631590769,40680631590769,40408299984661.445],oneOverRadii:[1/u,1/h,1/d],oneOverRadiiSquared:[1/40680631590769,1/40680631590769,1/40408299984661.445],maximumRadius:Math.max(u,h,d),centerToleranceSquared:.1};function w(e){return e}const m=new e;function f(e,a=[]){return function(e,t=[],r=w){return"longitude"in e?(t[0]=r(e.longitude),t[1]=r(e.latitude),t[2]=e.height):"x"in e?(t[0]=r(e.x),t[1]=r(e.y),t[2]=e.z):(t[0]=r(e[0]),t[1]=r(e[1]),t[2]=e[2]),t}(e,a,t._cartographicRadians?w:r)}function S(e,r){return function(e,t,r=w){return"longitude"in t?(t.longitude=r(e[0]),t.latitude=r(e[1]),t.height=e[2]):"x"in t?(t.x=r(e[0]),t.y=r(e[1]),t.z=e[2]):(t[0]=r(e[0]),t[1]=r(e[1]),t[2]=e[2]),t}(e,r,t._cartographicRadians?w:a)}function p(e){if(!e)return!1;m.from(e);const{oneOverRadiiSquared:t,centerToleranceSquared:r}=l,a=e[0]*e[0]*t[0],o=e[1]*e[1]*t[1],n=e[2]*e[2]*t[2];return Math.abs(a+o+n-1)<r}const x=new e,y={up:{south:"east",north:"west",west:"south",east:"north"},down:{south:"west",north:"east",west:"north",east:"south"},south:{up:"west",down:"east",west:"down",east:"up"},north:{up:"east",down:"west",west:"up",east:"down"},west:{up:"north",down:"south",north:"down",south:"up"},east:{up:"south",down:"north",north:"up",south:"down"}},g={north:[-1,0,0],east:[0,1,0],up:[0,0,1],south:[1,0,0],west:[0,-1,0],down:[0,0,-1]},q={east:new e,north:new e,up:new e,west:new e,south:new e,down:new e},z=new e,M=new e,O=new e;function R(e,t,r,a,i,s){const c=y[t]&&y[t][r];let u,h,d;o(c&&(!a||a===c));const l=x.copy(i);if(n(l.x,0,1e-14)&&n(l.y,0,1e-14)){const e=Math.sign(l.z);u=z.fromArray(g[t]),"east"!==t&&"west"!==t&&u.scale(e),h=M.fromArray(g[r]),"east"!==r&&"west"!==r&&h.scale(e),d=O.fromArray(g[a]),"east"!==a&&"west"!==a&&d.scale(e)}else{const{up:o,east:n,north:i}=q;n.set(-l.y,l.x,0).normalize(),e.geodeticSurfaceNormal(l,o),i.copy(o).cross(n);const{down:s,west:c,south:w}=q;s.copy(o).scale(-1),c.copy(n).scale(-1),w.copy(i).scale(-1),u=q[t],h=q[r],d=q[a]}return s[0]=u.x,s[1]=u.y,s[2]=u.z,s[3]=0,s[4]=h.x,s[5]=h.y,s[6]=h.z,s[7]=0,s[8]=d.x,s[9]=d.y,s[10]=d.z,s[11]=0,s[12]=l.x,s[13]=l.y,s[14]=l.z,s[15]=1,s}const T=new e,v=new e,N=new e;const F=new e,b=new e,P=new e,A=new e,C=new e,G=new e;class I{constructor(t=0,r=0,a=0){this.centerToleranceSquared=i.EPSILON1,o(t>=0),o(r>=0),o(a>=0),this.radii=new e(t,r,a),this.radiiSquared=new e(t*t,r*r,a*a),this.radiiToTheFourth=new e(t*t*t*t,r*r*r*r,a*a*a*a),this.oneOverRadii=new e(0===t?0:1/t,0===r?0:1/r,0===a?0:1/a),this.oneOverRadiiSquared=new e(0===t?0:1/(t*t),0===r?0:1/(r*r),0===a?0:1/(a*a)),this.minimumRadius=Math.min(t,r,a),this.maximumRadius=Math.max(t,r,a),0!==this.radiiSquared.z&&(this.squaredXOverSquaredZ=this.radiiSquared.x/this.radiiSquared.z),Object.freeze(this)}equals(e){return this===e||Boolean(e&&this.radii.equals(e.radii))}toString(){return this.radii.toString()}cartographicToCartesian(e,t=[0,0,0]){const r=b,a=P,[,,o]=e;this.geodeticSurfaceNormalCartographic(e,r),a.copy(this.radiiSquared).scale(r);const n=Math.sqrt(r.dot(a));return a.scale(1/n),r.scale(o),a.add(r),a.to(t)}cartesianToCartographic(e,t=[0,0,0]){G.from(e);const r=this.scaleToGeodeticSurface(G,A);if(!r)return;const a=this.geodeticSurfaceNormal(r,b),o=C;o.copy(G).subtract(r);return S([Math.atan2(a.y,a.x),Math.asin(a.z),Math.sign(s.dot(o,G))*s.length(o)],t)}eastNorthUpToFixedFrame(e,t=new c){return R(this,"east","north","up",e,t)}localFrameToFixedFrame(e,t,r,a,o=new c){return R(this,e,t,r,a,o)}geocentricSurfaceNormal(e,t=[0,0,0]){return F.from(e).normalize().to(t)}geodeticSurfaceNormalCartographic(e,t=[0,0,0]){const r=f(e),a=r[0],o=r[1],n=Math.cos(o);return F.set(n*Math.cos(a),n*Math.sin(a),Math.sin(o)).normalize(),F.to(t)}geodeticSurfaceNormal(e,t=[0,0,0]){return F.from(e).scale(this.oneOverRadiiSquared).normalize().to(t)}scaleToGeodeticSurface(e,t){return function(e,t,r=[]){const{oneOverRadii:a,oneOverRadiiSquared:o,centerToleranceSquared:n}=t;T.from(e);const s=T.x,c=T.y,u=T.z,h=a.x,d=a.y,l=a.z,w=s*s*h*h,m=c*c*d*d,f=u*u*l*l,S=w+m+f,p=Math.sqrt(1/S);if(!Number.isFinite(p))return;const x=v;if(x.copy(e).scale(p),S<n)return x.to(r);const y=o.x,g=o.y,q=o.z,z=N;z.set(x.x*y*2,x.y*g*2,x.z*q*2);let M,O,R,F,b=(1-p)*T.len()/(.5*z.len()),P=0;do{b-=P,M=1/(1+b*y),O=1/(1+b*g),R=1/(1+b*q);const e=M*M,t=O*O,r=R*R;F=w*e+m*t+f*r-1,P=F/(-2*(w*(e*M)*y+m*(t*O)*g+f*(r*R)*q))}while(Math.abs(F)>i.EPSILON12);return T.scale([M,O,R]).to(r)}(e,this,t)}scaleToGeocentricSurface(e,t=[0,0,0]){A.from(e);const r=A.x,a=A.y,o=A.z,n=this.oneOverRadiiSquared,i=1/Math.sqrt(r*r*n.x+a*a*n.y+o*o*n.z);return A.multiplyScalar(i).to(t)}transformPositionToScaledSpace(e,t=[0,0,0]){return A.from(e).scale(this.oneOverRadii).to(t)}transformPositionFromScaledSpace(e,t=[0,0,0]){return A.from(e).scale(this.radii).to(t)}getSurfaceNormalIntersectionWithZAxis(e,t=0,r=[0,0,0]){o(n(this.radii.x,this.radii.y,i.EPSILON15)),o(this.radii.z>0),A.from(e);const a=A.z*(1-this.squaredXOverSquaredZ);if(!(Math.abs(a)>=this.radii.z-t))return A.set(0,0,a).to(r)}}I.WGS84=new I(u,h,d);export{I as Ellipsoid,p as isWGS84};export default null;
