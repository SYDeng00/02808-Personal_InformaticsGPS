/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@math.gl/culling@4.0.1/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Vector3 as t,mat4 as e,Matrix3 as s,Quaternion as n,assert as i,equals as r,Matrix4 as a,Vector2 as o,_MathUtils as h}from"../core@4.0.1/_esm.js";const c={OUTSIDE:-1,INTERSECTING:0,INSIDE:1},u=new t,m=new t;class l{constructor(e=[0,0,0],s=[0,0,0],n){n=n||u.copy(e).add(s).scale(.5),this.center=new t(n),this.halfDiagonal=new t(s).subtract(this.center),this.minimum=new t(e),this.maximum=new t(s)}clone(){return new l(this.minimum,this.maximum,this.center)}equals(t){return this===t||Boolean(t)&&this.minimum.equals(t.minimum)&&this.maximum.equals(t.maximum)}transform(t){return this.center.transformAsPoint(t),this.halfDiagonal.transform(t),this.minimum.transform(t),this.maximum.transform(t),this}intersectPlane(t){const{halfDiagonal:e}=this,s=m.from(t.normal),n=e.x*Math.abs(s.x)+e.y*Math.abs(s.y)+e.z*Math.abs(s.z),i=this.center.dot(s)+t.distance;return i-n>0?c.INSIDE:i+n<0?c.OUTSIDE:c.INTERSECTING}distanceTo(t){return Math.sqrt(this.distanceSquaredTo(t))}distanceSquaredTo(t){const e=u.from(t).subtract(this.center),{halfDiagonal:s}=this;let n,i=0;return n=Math.abs(e.x)-s.x,n>0&&(i+=n*n),n=Math.abs(e.y)-s.y,n>0&&(i+=n*n),n=Math.abs(e.z)-s.z,n>0&&(i+=n*n),i}}const f=new t,d=new t;class p{constructor(e=[0,0,0],s=0){this.radius=-0,this.center=new t,this.fromCenterRadius(e,s)}fromCenterRadius(t,e){return this.center.from(t),this.radius=e,this}fromCornerPoints(e,s){return s=f.from(s),this.center=(new t).from(e).add(s).scale(.5),this.radius=this.center.distance(s),this}equals(t){return this===t||Boolean(t)&&this.center.equals(t.center)&&this.radius===t.radius}clone(){return new p(this.center,this.radius)}union(t){const e=this.center,s=this.radius,n=t.center,i=t.radius,r=f.copy(n).subtract(e),a=r.magnitude();if(s>=a+i)return this.clone();if(i>=a+s)return t.clone();const o=.5*(s+a+i);return d.copy(r).scale((-s+o)/a).add(e),this.center.copy(d),this.radius=o,this}expand(t){const e=f.from(t).subtract(this.center).magnitude();return e>this.radius&&(this.radius=e),this}transform(t){this.center.transform(t);const s=e.getScaling(f,t);return this.radius=Math.max(s[0],Math.max(s[1],s[2]))*this.radius,this}distanceSquaredTo(t){const e=this.distanceTo(t);return e*e}distanceTo(t){const e=f.from(t).subtract(this.center);return Math.max(0,e.len()-this.radius)}intersectPlane(t){const e=this.center,s=this.radius,n=t.normal.dot(e)+t.distance;return n<-s?c.OUTSIDE:n<s?c.INTERSECTING:c.INSIDE}}const y=new t,g=new t,x=new t,w=new t,b=new t,M=new t,_=new t,I=0,N=1,S=2,E=3,A=4,C=5,T=6,P=7,D=8;class q{constructor(e=[0,0,0],n=[0,0,0,0,0,0,0,0,0]){this.center=(new t).from(e),this.halfAxes=new s(n)}get halfSize(){const e=this.halfAxes.getColumn(0),s=this.halfAxes.getColumn(1),n=this.halfAxes.getColumn(2);return[new t(e).len(),new t(s).len(),new t(n).len()]}get quaternion(){const e=this.halfAxes.getColumn(0),i=this.halfAxes.getColumn(1),r=this.halfAxes.getColumn(2),a=new t(e).normalize(),o=new t(i).normalize(),h=new t(r).normalize();return(new n).fromMatrix3(new s([...a,...o,...h]))}fromCenterHalfSizeQuaternion(e,i,r){const a=new n(r),o=(new s).fromQuaternion(a);return o[0]=o[0]*i[0],o[1]=o[1]*i[0],o[2]=o[2]*i[0],o[3]=o[3]*i[1],o[4]=o[4]*i[1],o[5]=o[5]*i[1],o[6]=o[6]*i[2],o[7]=o[7]*i[2],o[8]=o[8]*i[2],this.center=(new t).from(e),this.halfAxes=o,this}clone(){return new q(this.center,this.halfAxes)}equals(t){return this===t||Boolean(t)&&this.center.equals(t.center)&&this.halfAxes.equals(t.halfAxes)}getBoundingSphere(t=new p){const e=this.halfAxes,s=e.getColumn(0,x),n=e.getColumn(1,w),i=e.getColumn(2,b),r=y.copy(s).add(n).add(i);return t.center.copy(this.center),t.radius=r.magnitude(),t}intersectPlane(t){const e=this.center,s=t.normal,n=this.halfAxes,i=s.x,r=s.y,a=s.z,o=Math.abs(i*n[I]+r*n[N]+a*n[S])+Math.abs(i*n[E]+r*n[A]+a*n[C])+Math.abs(i*n[T]+r*n[P]+a*n[D]),h=s.dot(e)+t.distance;return h<=-o?c.OUTSIDE:h>=o?c.INSIDE:c.INTERSECTING}distanceTo(t){return Math.sqrt(this.distanceSquaredTo(t))}distanceSquaredTo(t){const e=g.from(t).subtract(this.center),s=this.halfAxes,n=s.getColumn(0,x),i=s.getColumn(1,w),r=s.getColumn(2,b),a=n.magnitude(),o=i.magnitude(),h=r.magnitude();n.normalize(),i.normalize(),r.normalize();let c,u=0;return c=Math.abs(e.dot(n))-a,c>0&&(u+=c*c),c=Math.abs(e.dot(i))-o,c>0&&(u+=c*c),c=Math.abs(e.dot(r))-h,c>0&&(u+=c*c),u}computePlaneDistances(t,e,s=[-0,-0]){let n=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY;const r=this.center,a=this.halfAxes,o=a.getColumn(0,x),h=a.getColumn(1,w),c=a.getColumn(2,b),u=M.copy(o).add(h).add(c).add(r),m=_.copy(u).subtract(t);let l=e.dot(m);return n=Math.min(l,n),i=Math.max(l,i),u.copy(r).add(o).add(h).subtract(c),m.copy(u).subtract(t),l=e.dot(m),n=Math.min(l,n),i=Math.max(l,i),u.copy(r).add(o).subtract(h).add(c),m.copy(u).subtract(t),l=e.dot(m),n=Math.min(l,n),i=Math.max(l,i),u.copy(r).add(o).subtract(h).subtract(c),m.copy(u).subtract(t),l=e.dot(m),n=Math.min(l,n),i=Math.max(l,i),r.copy(u).subtract(o).add(h).add(c),m.copy(u).subtract(t),l=e.dot(m),n=Math.min(l,n),i=Math.max(l,i),r.copy(u).subtract(o).add(h).subtract(c),m.copy(u).subtract(t),l=e.dot(m),n=Math.min(l,n),i=Math.max(l,i),r.copy(u).subtract(o).subtract(h).add(c),m.copy(u).subtract(t),l=e.dot(m),n=Math.min(l,n),i=Math.max(l,i),r.copy(u).subtract(o).subtract(h).subtract(c),m.copy(u).subtract(t),l=e.dot(m),n=Math.min(l,n),i=Math.max(l,i),s[0]=n,s[1]=i,s}transform(t){this.center.transformAsPoint(t);const e=this.halfAxes.getColumn(0,x);e.transformAsPoint(t);const n=this.halfAxes.getColumn(1,w);n.transformAsPoint(t);const i=this.halfAxes.getColumn(2,b);return i.transformAsPoint(t),this.halfAxes=new s([...e,...n,...i]),this}getTransform(){throw new Error("not implemented")}}const z=new t,v=new t;class O{constructor(e=[0,0,1],s=0){this.normal=new t,this.distance=-0,this.fromNormalDistance(e,s)}fromNormalDistance(t,e){return i(Number.isFinite(e)),this.normal.from(t).normalize(),this.distance=e,this}fromPointNormal(t,e){t=z.from(t),this.normal.from(e).normalize();const s=-this.normal.dot(t);return this.distance=s,this}fromCoefficients(t,e,s,n){return this.normal.set(t,e,s),i(r(this.normal.len(),1)),this.distance=n,this}clone(){return new O(this.normal,this.distance)}equals(t){return r(this.distance,t.distance)&&r(this.normal,t.normal)}getPointDistance(t){return this.normal.dot(t)+this.distance}transform(t){const e=v.copy(this.normal).transformAsVector(t).normalize(),s=this.normal.scale(-this.distance).transform(t);return this.fromPointNormal(s,e)}projectPointOntoPlane(t,e=[0,0,0]){const s=z.from(t),n=this.getPointDistance(s),i=v.copy(this.normal).scale(n);return s.subtract(i).to(e)}}const R=[new t([1,0,0]),new t([0,1,0]),new t([0,0,1])],F=new t,B=new t;class V{constructor(t=[]){this.planes=t}fromBoundingSphere(t){this.planes.length=2*R.length;const e=t.center,s=t.radius;let n=0;for(const t of R){let i=this.planes[n],r=this.planes[n+1];i||(i=this.planes[n]=new O),r||(r=this.planes[n+1]=new O);const a=F.copy(t).scale(-s).add(e);i.fromPointNormal(a,t);const o=F.copy(t).scale(s).add(e),h=B.copy(t).negate();r.fromPointNormal(o,h),n+=2}return this}computeVisibility(t){let e=c.INSIDE;for(const s of this.planes){switch(t.intersectPlane(s)){case c.OUTSIDE:return c.OUTSIDE;case c.INTERSECTING:e=c.INTERSECTING}}return e}computeVisibilityWithPlaneMask(t,e){if(i(Number.isFinite(e),"parentPlaneMask is required."),e===V.MASK_OUTSIDE||e===V.MASK_INSIDE)return e;let s=V.MASK_INSIDE;const n=this.planes;for(let i=0;i<this.planes.length;++i){const r=i<31?1<<i:0;if(i<31&&0==(e&r))continue;const a=n[i],o=t.intersectPlane(a);if(o===c.OUTSIDE)return V.MASK_OUTSIDE;o===c.INTERSECTING&&(s|=r)}return s}}V.MASK_OUTSIDE=4294967295,V.MASK_INSIDE=0,V.MASK_INDETERMINATE=2147483647;const U=new t,L=new t,G=new t,j=new t,K=new t;class X{constructor(t={}){this._cullingVolume=new V([new O,new O,new O,new O,new O,new O]),this._perspectiveMatrix=new a,this._infinitePerspective=new a;const{near:e=1,far:s=5e8}=t;this.left=t.left,this._left=void 0,this.right=t.right,this._right=void 0,this.top=t.top,this._top=void 0,this.bottom=t.bottom,this._bottom=void 0,this.near=e,this._near=e,this.far=s,this._far=s}clone(){return new X({right:this.right,left:this.left,top:this.top,bottom:this.bottom,near:this.near,far:this.far})}equals(t){return t&&t instanceof X&&this.right===t.right&&this.left===t.left&&this.top===t.top&&this.bottom===t.bottom&&this.near===t.near&&this.far===t.far}get projectionMatrix(){return this._update(),this._perspectiveMatrix}get infiniteProjectionMatrix(){return this._update(),this._infinitePerspective}computeCullingVolume(e,s,n){i(e,"position is required."),i(s,"direction is required."),i(n,"up is required.");const r=this._cullingVolume.planes;n=U.copy(n).normalize();const a=L.copy(s).cross(n).normalize(),o=G.copy(s).multiplyByScalar(this.near).add(e),h=j.copy(s).multiplyByScalar(this.far).add(e);let c=K;return c.copy(a).multiplyByScalar(this.left).add(o).subtract(e).cross(n),r[0].fromPointNormal(e,c),c.copy(a).multiplyByScalar(this.right).add(o).subtract(e).cross(n).negate(),r[1].fromPointNormal(e,c),c.copy(n).multiplyByScalar(this.bottom).add(o).subtract(e).cross(a).negate(),r[2].fromPointNormal(e,c),c.copy(n).multiplyByScalar(this.top).add(o).subtract(e).cross(a),r[3].fromPointNormal(e,c),c=(new t).copy(s),r[4].fromPointNormal(o,c),c.negate(),r[5].fromPointNormal(h,c),this._cullingVolume}getPixelDimensions(t,e,s,n){this._update(),i(Number.isFinite(t)&&Number.isFinite(e)),i(t>0),i(e>0),i(s>0),i(n);const r=1/this.near;let a=this.top*r;const o=2*s*a/e;a=this.right*r;const h=2*s*a/t;return n.x=h,n.y=o,n}_update(){i(Number.isFinite(this.right)&&Number.isFinite(this.left)&&Number.isFinite(this.top)&&Number.isFinite(this.bottom)&&Number.isFinite(this.near)&&Number.isFinite(this.far));const{top:t,bottom:e,right:s,left:n,near:r,far:o}=this;t===this._top&&e===this._bottom&&n===this._left&&s===this._right&&r===this._near&&o===this._far||(i(this.near>0&&this.near<this.far,"near must be greater than zero and less than far."),this._left=n,this._right=s,this._top=t,this._bottom=e,this._near=r,this._far=o,this._perspectiveMatrix=(new a).frustum({left:n,right:s,bottom:e,top:t,near:r,far:o}),this._infinitePerspective=(new a).frustum({left:n,right:s,bottom:e,top:t,near:r,far:1/0}))}}class Y{constructor(t={}){this._offCenterFrustum=new X;const{fov:e,aspectRatio:s,near:n=1,far:i=5e8,xOffset:r=0,yOffset:a=0}=t;this.fov=e,this.aspectRatio=s,this.near=n,this.far=i,this.xOffset=r,this.yOffset=a}clone(){return new Y({aspectRatio:this.aspectRatio,fov:this.fov,near:this.near,far:this.far})}equals(t){return null!=t&&t instanceof Y&&(this._update(),t._update(),this.fov===t.fov&&this.aspectRatio===t.aspectRatio&&this.near===t.near&&this.far===t.far&&this._offCenterFrustum.equals(t._offCenterFrustum))}get projectionMatrix(){return this._update(),this._offCenterFrustum.projectionMatrix}get infiniteProjectionMatrix(){return this._update(),this._offCenterFrustum.infiniteProjectionMatrix}get fovy(){return this._update(),this._fovy}get sseDenominator(){return this._update(),this._sseDenominator}computeCullingVolume(t,e,s){return this._update(),this._offCenterFrustum.computeCullingVolume(t,e,s)}getPixelDimensions(t,e,s,n){return this._update(),this._offCenterFrustum.getPixelDimensions(t,e,s,n||new o)}_update(){i(Number.isFinite(this.fov)&&Number.isFinite(this.aspectRatio)&&Number.isFinite(this.near)&&Number.isFinite(this.far));const t=this._offCenterFrustum;this.fov===this._fov&&this.aspectRatio===this._aspectRatio&&this.near===this._near&&this.far===this._far&&this.xOffset===this._xOffset&&this.yOffset===this._yOffset||(i(this.fov>=0&&this.fov<Math.PI),i(this.aspectRatio>0),i(this.near>=0&&this.near<this.far),this._aspectRatio=this.aspectRatio,this._fov=this.fov,this._fovy=this.aspectRatio<=1?this.fov:2*Math.atan(Math.tan(.5*this.fov)/this.aspectRatio),this._near=this.near,this._far=this.far,this._sseDenominator=2*Math.tan(.5*this._fovy),this._xOffset=this.xOffset,this._yOffset=this.yOffset,t.top=this.near*Math.tan(.5*this._fovy),t.bottom=-t.top,t.right=this.aspectRatio*t.top,t.left=-t.right,t.near=this.near,t.far=this.far,t.right+=this.xOffset,t.left+=this.xOffset,t.top+=this.yOffset,t.bottom+=this.yOffset)}}const k=new t,Q=new t,H=new t,W=new t,J=new t,Z=new t,$=new t,tt=new t,et=new t,st=new t,nt=new t,it=new t;function rt(t,e=new p){if(!t||0===t.length)return e.fromCenterRadius([0,0,0],0);const s=$.copy(t[0]),n=k.copy(s),i=Q.copy(s),r=H.copy(s),a=W.copy(s),o=J.copy(s),h=Z.copy(s);for(const e of t){s.copy(e);const t=s.x,c=s.y,u=s.z;t<n.x&&n.copy(s),t>a.x&&a.copy(s),c<i.y&&i.copy(s),c>o.y&&o.copy(s),u<r.z&&r.copy(s),u>h.z&&h.copy(s)}const c=tt.copy(a).subtract(n).magnitudeSquared(),u=tt.copy(o).subtract(i).magnitudeSquared(),m=tt.copy(h).subtract(r).magnitudeSquared();let l=n,f=a,d=c;u>d&&(d=u,l=i,f=o),m>d&&(d=m,l=r,f=h);const y=et;y.x=.5*(l.x+f.x),y.y=.5*(l.y+f.y),y.z=.5*(l.z+f.z);let g=tt.copy(f).subtract(y).magnitudeSquared(),x=Math.sqrt(g);const w=st;w.x=n.x,w.y=i.y,w.z=r.z;const b=nt;b.x=a.x,b.y=o.y,b.z=h.z;const M=it.copy(w).add(b).multiplyByScalar(.5);let _=0;for(const e of t){s.copy(e);const t=tt.copy(s).subtract(M).magnitude();t>_&&(_=t);const n=tt.copy(s).subtract(y).magnitudeSquared();if(n>g){const t=Math.sqrt(n);x=.5*(x+t),g=x*x;const e=t-x;y.x=(x*y.x+e*s.x)/t,y.y=(x*y.y+e*s.y)/t,y.z=(x*y.z+e*s.z)/t}}return x<_?(y.to(e.center),e.radius=x):(M.to(e.center),e.radius=_),e}const at=new s,ot=new s,ht=new s,ct=new s,ut=new s;function mt(t,e={}){const s=h.EPSILON20;let n=0,i=0;const r=ot,a=ht;r.identity(),a.copy(t);const o=s*function(t){let e=0;for(let s=0;s<9;++s){const n=t[s];e+=n*n}return Math.sqrt(e)}(a);for(;i<10&&dt(a)>o;)pt(a,ct),ut.copy(ct).transpose(),a.multiplyRight(ct),a.multiplyLeft(ut),r.multiplyRight(ct),++n>2&&(++i,n=0);return e.unitary=r.toTarget(e.unitary),e.diagonal=a.toTarget(e.diagonal),e}const lt=[1,0,0],ft=[2,2,1];function dt(t){let e=0;for(let s=0;s<3;++s){const n=t[at.getElementIndex(ft[s],lt[s])];e+=2*n*n}return Math.sqrt(e)}function pt(t,e){const n=h.EPSILON15;let i=0,r=1;for(let e=0;e<3;++e){const s=Math.abs(t[at.getElementIndex(ft[e],lt[e])]);s>i&&(r=e,i=s)}const a=lt[r],o=ft[r];let c=1,u=0;if(Math.abs(t[at.getElementIndex(o,a)])>n){const e=(t[at.getElementIndex(o,o)]-t[at.getElementIndex(a,a)])/2/t[at.getElementIndex(o,a)];let s;s=e<0?-1/(-e+Math.sqrt(1+e*e)):1/(e+Math.sqrt(1+e*e)),c=1/Math.sqrt(1+s*s),u=s*c}return s.IDENTITY.to(e),e[at.getElementIndex(a,a)]=e[at.getElementIndex(o,o)]=c,e[at.getElementIndex(o,a)]=u,e[at.getElementIndex(a,o)]=-u,e}const yt=new t,gt=new t,xt=new t,wt=new t,bt=new t,Mt=new s,_t={diagonal:new s,unitary:new s};function It(e,n=new q){if(!e||0===e.length)return n.halfAxes=new s([0,0,0,0,0,0,0,0,0]),n.center=new t,n;const i=e.length,r=new t(0,0,0);for(const t of e)r.add(t);const a=1/i;r.multiplyByScalar(a);let o=0,h=0,c=0,u=0,m=0,l=0;for(const t of e){const e=yt.copy(t).subtract(r);o+=e.x*e.x,h+=e.x*e.y,c+=e.x*e.z,u+=e.y*e.y,m+=e.y*e.z,l+=e.z*e.z}o*=a,h*=a,c*=a,u*=a,m*=a,l*=a;const f=Mt;f[0]=o,f[1]=h,f[2]=c,f[3]=h,f[4]=u,f[5]=m,f[6]=c,f[7]=m,f[8]=l;const{unitary:d}=mt(f,_t),p=n.halfAxes.copy(d);let y=p.getColumn(0,xt),g=p.getColumn(1,wt),x=p.getColumn(2,bt),w=-Number.MAX_VALUE,b=-Number.MAX_VALUE,M=-Number.MAX_VALUE,_=Number.MAX_VALUE,I=Number.MAX_VALUE,N=Number.MAX_VALUE;for(const t of e)yt.copy(t),w=Math.max(yt.dot(y),w),b=Math.max(yt.dot(g),b),M=Math.max(yt.dot(x),M),_=Math.min(yt.dot(y),_),I=Math.min(yt.dot(g),I),N=Math.min(yt.dot(x),N);y=y.multiplyByScalar(.5*(_+w)),g=g.multiplyByScalar(.5*(I+b)),x=x.multiplyByScalar(.5*(N+M)),n.center.copy(y).add(g).add(x);const S=gt.set(w-_,b-I,M-N).multiplyByScalar(.5),E=new s([S[0],0,0,0,S[1],0,0,0,S[2]]);return n.halfAxes.multiplyRight(E),n}function Nt(t,e=new l){if(!t||0===t.length)return e.minimum.set(0,0,0),e.maximum.set(0,0,0),e.center.set(0,0,0),e.halfDiagonal.set(0,0,0),e;let s=t[0][0],n=t[0][1],i=t[0][2],r=t[0][0],a=t[0][1],o=t[0][2];for(const e of t){const t=e[0],h=e[1],c=e[2];s=Math.min(t,s),r=Math.max(t,r),n=Math.min(h,n),a=Math.max(h,a),i=Math.min(c,i),o=Math.max(c,o)}return e.minimum.set(s,n,i),e.maximum.set(r,a,o),e.center.copy(e.minimum).add(e.maximum).scale(.5),e.halfDiagonal.copy(e.maximum).subtract(e.center),e}export{l as AxisAlignedBoundingBox,p as BoundingSphere,V as CullingVolume,c as INTERSECTION,q as OrientedBoundingBox,O as Plane,Y as _PerspectiveFrustum,X as _PerspectiveOffCenterFrustum,mt as computeEigenDecomposition,Nt as makeAxisAlignedBoundingBoxFromPoints,rt as makeBoundingSphereFromPoints,It as makeOrientedBoundingBoxFromPoints};export default null;
