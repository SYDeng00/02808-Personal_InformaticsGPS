/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@deck.gl/mesh-layers@9.0.6/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{createIterable as e,COORDINATE_SYSTEM as t,Layer as n,project32 as o,phongLighting as s,picking as i,log as a}from"../core@9.0.6/_esm.js";import{Texture as r}from"../../@luma.gl/core@9.0.9/_esm.js";import{Model as l,Geometry as c,ScenegraphNode as m,GroupNode as p,ModelNode as d}from"../../@luma.gl/engine@9.0.9/_esm.js";import{getMeshBoundingBox as u}from"../../@loaders.gl/schema/_esm.js";import{pbr as g}from"../../@luma.gl/shadertools@9.0.9/_esm.js";import{createScenegraphsFromGLTF as f}from"../../@luma.gl/gltf@9.0.9/_esm.js";import{postProcessGLTF as h,GLTFLoader as v}from"../../@loaders.gl/gltf@4.2.0/_esm.js";const _=Math.PI/180,y=new Float32Array(16),M=new Float32Array(12);function x(e,t,n){const o=t[0]*_,s=t[1]*_,i=t[2]*_,a=Math.sin(i),r=Math.sin(o),l=Math.sin(s),c=Math.cos(i),m=Math.cos(o),p=Math.cos(s),d=n[0],u=n[1],g=n[2];e[0]=d*p*m,e[1]=d*l*m,e[2]=d*-r,e[3]=u*(-l*c+p*r*a),e[4]=u*(p*c+l*r*a),e[5]=u*m*a,e[6]=g*(l*a+p*r*c),e[7]=g*(-p*a+l*r*c),e[8]=g*m*c}function C(e){return e[0]=e[0],e[1]=e[1],e[2]=e[2],e[3]=e[4],e[4]=e[5],e[5]=e[6],e[6]=e[8],e[7]=e[9],e[8]=e[10],e[9]=e[12],e[10]=e[13],e[11]=e[14],e.subarray(0,12)}const S={size:12,accessor:["getOrientation","getScale","getTranslation","getTransformMatrix"],shaderAttributes:{instanceModelMatrixCol0:{size:3,elementOffset:0},instanceModelMatrixCol1:{size:3,elementOffset:3},instanceModelMatrixCol2:{size:3,elementOffset:6},instanceTranslation:{size:3,elementOffset:9}},update(t,{startRow:n,endRow:o}){const{data:s,getOrientation:i,getScale:a,getTranslation:r,getTransformMatrix:l}=this.props,c=Array.isArray(l),m=c&&16===l.length,p=Array.isArray(a),d=Array.isArray(i),u=Array.isArray(r),g=m||!c&&Boolean(l(s[0]));t.constant=g?m:d&&p&&u;const f=t.value;if(t.constant){let e;if(g)y.set(l),e=C(y);else{e=M;x(e,i,a),e.set(r,9)}t.value=new Float32Array(e)}else{let c=n*t.size;const{iterable:h,objectInfo:v}=e(s,n,o);for(const e of h){let t;if(v.index++,g)y.set(m?l:l(e,v)),t=C(y);else{t=M;x(t,d?i:i(e,v),p?a:a(e,v)),t.set(u?r:r(e,v),9)}f[c++]=t[0],f[c++]=t[1],f[c++]=t[2],f[c++]=t[3],f[c++]=t[4],f[c++]=t[5],f[c++]=t[6],f[c++]=t[7],f[c++]=t[8],f[c++]=t[9],f[c++]=t[10],f[c++]=t[11]}}}};function P(e,n){return n===t.CARTESIAN||n===t.METER_OFFSETS||n===t.DEFAULT&&!e.isGeospatial}function O(e){const t=e.positions||e.POSITION;a.assert(t,'no "postions" or "POSITION" attribute in mesh');const n=t.value.length/t.size;let o=e.COLOR_0||e.colors;o||(o={size:3,value:new Float32Array(3*n).fill(1)});let s=e.NORMAL||e.normals;s||(s={size:3,value:new Float32Array(3*n).fill(0)});let i=e.TEXCOORD_0||e.texCoords;return i||(i={size:2,value:new Float32Array(2*n).fill(0)}),{positions:t,colors:o,normals:s,texCoords:i}}function A(e){return e instanceof c?(e.attributes=O(e.attributes),e):e.attributes?new c({...e,topology:"triangle-list",attributes:O(e.attributes)}):new c({topology:"triangle-list",attributes:O(e)})}const E={mesh:{type:"object",value:null,async:!0},texture:{type:"image",value:null,async:!0},sizeScale:{type:"number",value:1,min:0},_instanced:!0,wireframe:!1,material:!0,getPosition:{type:"accessor",value:e=>e.position},getColor:{type:"accessor",value:[0,0,0,255]},getOrientation:{type:"accessor",value:[0,0,0]},getScale:{type:"accessor",value:[1,1,1]},getTranslation:{type:"accessor",value:[0,0,0]},getTransformMatrix:{type:"accessor",value:[]},textureParameters:{type:"object",ignore:!0,value:null}};class L extends n{static{this.defaultProps=E}static{this.layerName="SimpleMeshLayer"}getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\nuniform float sizeScale;\nuniform bool composeModelMatrix;\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec3 instanceModelMatrixCol0;\nin vec3 instanceModelMatrixCol1;\nin vec3 instanceModelMatrixCol2;\nin vec3 instanceTranslation;\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\ngeometry.uv = texCoords;\ngeometry.pickingColor = instancePickingColors;\nvTexCoord = texCoords;\ncameraPosition = project_uCameraPosition;\nvColor = vec4(colors * instanceColors.rgb, instanceColors.a);\nmat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);\nvec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;\nif (composeModelMatrix) {\nDECKGL_FILTER_SIZE(pos, geometry);\nnormals_commonspace = project_normal(instanceModelMatrix * normals);\ngeometry.worldPosition += pos;\ngl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);\ngeometry.position = position_commonspace;\n}\nelse {\npos = project_size(pos);\nDECKGL_FILTER_SIZE(pos, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);\ngeometry.position = position_commonspace;\nnormals_commonspace = project_normal(instanceModelMatrix * normals);\n}\ngeometry.normal = normals_commonspace;\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\nprecision highp float;\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = vTexCoord;\nvec3 normal;\nif (flatShading) {\nnormal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n} else {\nnormal = normals_commonspace;\n}\nvec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\nDECKGL_FILTER_COLOR(color, geometry);\nvec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\nfragColor = vec4(lightColor, color.a * opacity);\n}\n",modules:[o,s,i]})}getBounds(){if(this.props._instanced)return super.getBounds();let e=this.state.positionBounds;if(e)return e;const{mesh:t}=this.props;if(!t)return null;if(e=t.header?.boundingBox,!e){const{attributes:n}=A(t);n.POSITION=n.POSITION||n.positions,e=u(n)}return this.state.positionBounds=e,e}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{transition:!0,type:"float64",fp64:this.use64bitPositions(),size:3,accessor:"getPosition"},instanceColors:{type:"unorm8",transition:!0,size:this.props.colorFormat.length,accessor:"getColor",defaultValue:[0,0,0,255]},instanceModelMatrix:S}),this.setState({emptyTexture:this.context.device.createTexture({data:new Uint8Array(4),width:1,height:1})})}updateState(e){super.updateState(e);const{props:t,oldProps:n,changeFlags:o}=e;if(t.mesh!==n.mesh||o.extensionsChanged){if(this.state.positionBounds=null,this.state.model?.destroy(),t.mesh){this.state.model=this.getModel(t.mesh);const e=t.mesh.attributes||t.mesh;this.setState({hasNormals:Boolean(e.NORMAL||e.normals)})}this.getAttributeManager().invalidateAll()}t.texture!==n.texture&&t.texture instanceof r&&this.setTexture(t.texture),this.state.model&&this.state.model.setTopology(this.props.wireframe?"line-strip":"triangle-list")}finalizeState(e){super.finalizeState(e),this.state.emptyTexture.delete()}draw({uniforms:e}){const{model:t}=this.state;if(!t)return;const{viewport:n,renderPass:o}=this.context,{sizeScale:s,coordinateSystem:i,_instanced:a}=this.props;t.setUniforms(e),t.setUniforms({sizeScale:s,composeModelMatrix:!a||P(n,i),flatShading:!this.state.hasNormals}),t.draw(o)}get isLoaded(){return Boolean(this.state?.model&&super.isLoaded)}getModel(e){const t=new l(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:A(e),isInstanced:!0}),{texture:n}=this.props,{emptyTexture:o}=this.state;return t.setBindings({sampler:n||o}),t.setUniforms({hasTexture:Boolean(n)}),t}setTexture(e){const{emptyTexture:t,model:n}=this.state;n&&(n.setBindings({sampler:e||t}),n.setUniforms({hasTexture:Boolean(e)}))}}async function T(e){const t=[];return e.scenes.forEach((e=>{e.traverse((e=>{Object.values(e.model.uniforms).forEach((e=>{!1===e.loaded&&t.push(e)}))}))})),await async function(e){for(;e();)await new Promise((e=>requestAnimationFrame(e)))}((()=>t.some((e=>!e.loaded))))}const b=[255,255,255,255],z={scenegraph:{type:"object",value:null,async:!0},getScene:e=>e&&e.scenes?"object"==typeof e.scene?e.scene:e.scenes[e.scene||0]:e,getAnimator:e=>e&&e.animator,_animations:null,sizeScale:{type:"number",value:1,min:0},sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},getPosition:{type:"accessor",value:e=>e.position},getColor:{type:"accessor",value:b},_lighting:"flat",_imageBasedLightingEnvironment:void 0,getOrientation:{type:"accessor",value:[0,0,0]},getScale:{type:"accessor",value:[1,1,1]},getTranslation:{type:"accessor",value:[0,0,0]},getTransformMatrix:{type:"accessor",value:[]},loaders:[v]};class R extends n{static{this.defaultProps=z}static{this.layerName="ScenegraphLayer"}getShaders(){const e=[o,i];return"pbr"===this.props._lighting&&e.push(g),super.getShaders({vs:"#version 300 es\n#define SHADER_NAME scenegraph-layer-vertex-shader\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec3 instanceModelMatrixCol0;\nin vec3 instanceModelMatrixCol1;\nin vec3 instanceModelMatrixCol2;\nin vec3 instanceTranslation;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform mat4 sceneModelMatrix;\nuniform bool composeModelMatrix;\nin vec3 positions;\n#ifdef HAS_UV\nin vec2 texCoords;\n#endif\n#ifdef MODULE_PBR\n#ifdef HAS_NORMALS\nin vec3 normals;\n#endif\n#endif\nout vec4 vColor;\n#ifndef MODULE_PBR\n#ifdef HAS_UV\nout vec2 vTEXCOORD_0;\n#endif\n#endif\nvoid main(void) {\n#if defined(HAS_UV) && !defined(MODULE_PBR)\nvTEXCOORD_0 = texCoords;\ngeometry.uv = texCoords;\n#endif\ngeometry.worldPosition = instancePositions;\ngeometry.pickingColor = instancePickingColors;\nmat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);\nvec3 normal = vec3(0.0, 0.0, 1.0);\n#ifdef MODULE_PBR\n#ifdef HAS_NORMALS\nnormal = instanceModelMatrix * (sceneModelMatrix * vec4(normals, 0.0)).xyz;\n#endif\n#endif\nfloat originalSize = project_size_to_pixel(sizeScale);\nfloat clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);\nvec3 pos = (instanceModelMatrix * (sceneModelMatrix * vec4(positions, 1.0)).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;\nif(composeModelMatrix) {\nDECKGL_FILTER_SIZE(pos, geometry);\ngeometry.normal = project_normal(normal);\ngeometry.worldPosition += pos;\ngl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n}\nelse {\npos = project_size(pos);\nDECKGL_FILTER_SIZE(pos, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);\ngeometry.normal = project_normal(normal);\n}\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n#ifdef MODULE_PBR\npbr_vPosition = geometry.position.xyz;\n#ifdef HAS_NORMALS\npbr_vNormal = geometry.normal;\n#endif\n#ifdef HAS_UV\npbr_vUV = texCoords;\n#else\npbr_vUV = vec2(0., 0.);\n#endif\ngeometry.uv = pbr_vUV;\n#endif\nvColor = instanceColors;\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME scenegraph-layer-fragment-shader\nuniform float opacity;\nin vec4 vColor;\nout vec4 fragColor;\n#ifndef MODULE_PBR\n#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\nin vec2 vTEXCOORD_0;\nuniform sampler2D u_BaseColorSampler;\n#endif\n#endif\nvoid main(void) {\n#ifdef MODULE_PBR\nfragColor = vColor * pbr_filterColor(vec4(0));\ngeometry.uv = pbr_vUV;\n#else\n#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\nfragColor = vColor * texture(u_BaseColorSampler, vTEXCOORD_0);\ngeometry.uv = vTEXCOORD_0;\n#else\nfragColor = vColor;\n#endif\n#endif\nfragColor.a *= opacity;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:e})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),accessor:"getPosition",transition:!0},instanceColors:{type:"unorm8",size:this.props.colorFormat.length,accessor:"getColor",defaultValue:b,transition:!0},instanceModelMatrix:S})}updateState(e){super.updateState(e);const{props:t,oldProps:n}=e;t.scenegraph!==n.scenegraph?this._updateScenegraph():t._animations!==n._animations&&this._applyAnimationsProp(this.state.animator,t._animations)}finalizeState(e){super.finalizeState(e),this.state.scenegraph?.destroy()}get isLoaded(){return Boolean(this.state?.scenegraph&&super.isLoaded)}_updateScenegraph(){const e=this.props,{device:t}=this.context;let n=null;if(e.scenegraph instanceof m)n={scenes:[e.scenegraph]};else if(e.scenegraph&&"object"==typeof e.scenegraph){const o=e.scenegraph,s=o.json?h(o):o,i=f(t,s,this._getModelOptions());n={gltf:s,...i},T(i).then((()=>{this.setNeedsRedraw()})).catch((e=>{this.raiseError(e,"loading glTF")}))}const o={layer:this,device:this.context.device},s=e.getScene(n,o),i=e.getAnimator(n,o);if(s instanceof p){this.state.scenegraph?.destroy(),this._applyAnimationsProp(i,e._animations);const t=[];s.traverse((e=>{e instanceof d&&t.push(e.model)})),this.setState({scenegraph:s,animator:i,models:t}),this.getAttributeManager().invalidateAll()}else null!==s&&a.warn("invalid scenegraph:",s)()}_applyAnimationsProp(e,t){if(!e||!t)return;const n=e.getAnimations();Object.keys(t).sort().forEach((e=>{const o=t[e];if("*"===e)n.forEach((e=>{Object.assign(e,o)}));else if(Number.isFinite(Number(e))){const t=Number(e);t>=0&&t<n.length?Object.assign(n[t],o):a.warn(`animation ${e} not found`)()}else{const t=n.find((({name:t})=>t===e));t?Object.assign(t,o):a.warn(`animation ${e} not found`)()}}))}_getModelOptions(){const{_imageBasedLightingEnvironment:e}=this.props;let t;return e&&(t="function"==typeof e?e({gl:this.context.gl,layer:this}):e),{imageBasedLightingEnvironment:t,modelOptions:{id:this.props.id,isInstanced:!0,bufferLayout:this.getAttributeManager().getBufferLayouts(),...this.getShaders()},useTangents:!1}}draw({context:e}){if(!this.state.scenegraph)return;this.props._animations&&this.state.animator&&(this.state.animator.animate(e.timeline.getTime()),this.setNeedsRedraw());const{viewport:t,renderPass:n}=this.context,{sizeScale:o,sizeMinPixels:s,sizeMaxPixels:i,opacity:a,coordinateSystem:r}=this.props,l=this.getNumInstances();this.state.scenegraph.traverse(((e,{worldMatrix:c})=>{if(e instanceof d){const{model:m}=e;m.setInstanceCount(l),m.setUniforms({sizeScale:o,opacity:a,sizeMinPixels:s,sizeMaxPixels:i,composeModelMatrix:P(t,r),sceneModelMatrix:c,u_Camera:m.uniforms.project_uCameraPosition}),m.draw(n)}}))}}export{R as ScenegraphLayer,L as SimpleMeshLayer};export default null;
