/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@deck.gl/extensions@9.0.6/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{project as e,LayerExtension as t,_deepEqual as i,log as n,_memoize as s,COORDINATE_SYSTEM as r,_mergeShaders as o,fp64LowPart as a,_LayersPass as l,WebMercatorViewport as c,OrthographicViewport as d,_PickLayersPass as f}from"../core@9.0.6/_esm.js";import{Model as u}from"../../@luma.gl/engine@9.0.9/_esm.js";import"../../@luma.gl/constants@9.0.9/_esm.js";import{fp64 as p}from"../../@luma.gl/shadertools@9.0.9/_esm.js";import{vec3 as h,equals as m}from"../../@math.gl/core@4.0.1/_esm.js";const _={source:0,target:1,custom:2,source_target:3};var g={name:"brushing",dependencies:[e],vs:"\nuniform bool brushing_enabled;\nuniform int brushing_target;\nuniform vec2 brushing_mousePos;\nuniform float brushing_radius;\n#ifdef NON_INSTANCED_MODEL\nin vec2 brushingTargets;\n#else\nin vec2 instanceBrushingTargets;\n#endif\nout float brushing_isVisible;\nbool brushing_isPointInRange(vec2 position) {\nif (!brushing_enabled) {\nreturn true;\n}\nvec2 source_commonspace = project_position(position);\nvec2 target_commonspace = project_position(brushing_mousePos);\nfloat distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);\nreturn distance <= brushing_radius;\n}\nbool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\nreturn brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\n}\nvoid brushing_setVisible(bool visible) {\nbrushing_isVisible = float(visible);\n}\n",fs:"\nuniform bool brushing_enabled;\nin float brushing_isVisible;\n",inject:{"vs:DECKGL_FILTER_GL_POSITION":"\nvec2 brushingTarget;\nvec2 brushingSource;\nif (brushing_target == 3) {\nbrushingTarget = geometry.worldPositionAlt.xy;\nbrushingSource = geometry.worldPosition.xy;\n} else if (brushing_target == 0) {\nbrushingTarget = geometry.worldPosition.xy;\n} else if (brushing_target == 1) {\nbrushingTarget = geometry.worldPositionAlt.xy;\n} else {\n#ifdef NON_INSTANCED_MODEL\nbrushingTarget = brushingTargets;\n#else\nbrushingTarget = instanceBrushingTargets;\n#endif\n}\nbool visible;\nif (brushing_target == 3) {\nvisible = brushing_arePointsInRange(brushingSource, brushingTarget);\n} else {\nvisible = brushing_isPointInRange(brushingTarget);\n}\nbrushing_setVisible(visible);\n","fs:DECKGL_FILTER_COLOR":"\n    if (brushing_enabled && brushing_isVisible < 0.5) {\n      discard;\n    }\n  "},getUniforms:e=>{if(!e||!("viewport"in e))return{};const{brushingEnabled:t=!0,brushingRadius:i=1e4,brushingTarget:n="source",mousePosition:s,viewport:r}=e;return{brushing_enabled:Boolean(t&&s&&r.containsPixel(s)),brushing_radius:i,brushing_target:_[n]||0,brushing_mousePos:s?r.unproject([s.x-r.x,s.y-r.y]):[0,0]}}};const v={getBrushingTarget:{type:"accessor",value:[0,0]},brushingTarget:"source",brushingEnabled:!0,brushingRadius:1e4};class y extends t{static{this.defaultProps=v}static{this.extensionName="BrushingExtension"}getShaders(){return{modules:[g]}}initializeState(e,t){const i=this.getAttributeManager();i&&i.add({brushingTargets:{size:2,accessor:"getBrushingTarget",shaderAttributes:{brushingTargets:{divisor:0},instanceBrushingTargets:{divisor:1}}}});const n=()=>{this.getCurrentLayer()?.setNeedsRedraw()};this.state.onMouseMove=n,e.deck&&e.deck.eventManager.on({pointermove:n,pointerleave:n})}finalizeState(e,t){if(e.deck){const t=this.state.onMouseMove;e.deck.eventManager.off({pointermove:t,pointerleave:t})}}}const T="\nuniform DATAFILTER_TYPE filter_min;\nuniform DATAFILTER_TYPE filter_softMin;\nuniform DATAFILTER_TYPE filter_softMax;\nuniform DATAFILTER_TYPE filter_max;\nuniform bool filter_useSoftMargin;\nuniform bool filter_enabled;\nuniform bool filter_transformSize;\nuniform ivec4 filter_categoryBitMask;\n#ifdef NON_INSTANCED_MODEL\n#define DATAFILTER_ATTRIB filterValues\n#define DATAFILTER_ATTRIB_64LOW filterValues64Low\n#define DATACATEGORY_ATTRIB filterCategoryValues\n#else\n#define DATAFILTER_ATTRIB instanceFilterValues\n#define DATAFILTER_ATTRIB_64LOW instanceFilterValues64Low\n#define DATACATEGORY_ATTRIB instanceFilterCategoryValues\n#endif\nin DATAFILTER_TYPE DATAFILTER_ATTRIB;\n#ifdef DATAFILTER_DOUBLE\nin DATAFILTER_TYPE DATAFILTER_ATTRIB_64LOW;\nuniform DATAFILTER_TYPE filter_min64High;\nuniform DATAFILTER_TYPE filter_max64High;\n#endif\nin DATACATEGORY_TYPE DATACATEGORY_ATTRIB;\nout float dataFilter_value;\nfloat dataFilter_reduceValue(float value) {\nreturn value;\n}\nfloat dataFilter_reduceValue(vec2 value) {\nreturn min(value.x, value.y);\n}\nfloat dataFilter_reduceValue(vec3 value) {\nreturn min(min(value.x, value.y), value.z);\n}\nfloat dataFilter_reduceValue(vec4 value) {\nreturn min(min(value.x, value.y), min(value.z, value.w));\n}\nvoid dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax, DATACATEGORY_TYPE category) {\nif (filter_enabled) {\nif (filter_useSoftMargin) {\ndataFilter_value = dataFilter_reduceValue(\nsmoothstep(filter_min, filter_softMin, valueFromMin) *\n(1.0 - smoothstep(filter_softMax, filter_max, valueFromMax))\n);\n} else {\ndataFilter_value = dataFilter_reduceValue(\nstep(filter_min, valueFromMin) * step(valueFromMax, filter_max)\n);\n}\n#if DATACATEGORY_CHANNELS == 1\nint dataFilter_masks = filter_categoryBitMask[int(category / 32.0)];\n#elif DATACATEGORY_CHANNELS == 2\nivec2 dataFilter_masks = ivec2(\nfilter_categoryBitMask[int(category.x / 32.0)],\nfilter_categoryBitMask[int(category.y / 32.0) + 2]\n);\n#elif DATACATEGORY_CHANNELS == 3\nivec3 dataFilter_masks = filter_categoryBitMask.xyz;\n#else\nivec4 dataFilter_masks = filter_categoryBitMask;\n#endif\nDATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) / pow(DATACATEGORY_TYPE(2.0), mod(category, 32.0));\ndataFilter_bits = mod(floor(dataFilter_bits), 2.0);\n#if DATACATEGORY_CHANNELS == 1\nif(dataFilter_bits == 0.0) dataFilter_value = 0.0;\n#else\nif(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0.0)))) dataFilter_value = 0.0;\n#endif\n} else {\ndataFilter_value = 1.0;\n}\n}\n",b="\nuniform bool filter_transformColor;\nin float dataFilter_value;\n";function P(e){if(!e||!("extensions"in e))return{};const{filterRange:t=[-1,1],filterEnabled:i=!0,filterTransformSize:n=!0,filterTransformColor:s=!0}=e,r=e.filterSoftRange||t;return{...Number.isFinite(t[0])?{filter_min:t[0],filter_softMin:r[0],filter_softMax:r[1],filter_max:t[1]}:{filter_min:t.map((e=>e[0])),filter_softMin:r.map((e=>e[0])),filter_softMax:r.map((e=>e[1])),filter_max:t.map((e=>e[1]))},filter_enabled:i,filter_useSoftMargin:Boolean(e.filterSoftRange),filter_transformSize:i&&n,filter_transformColor:i&&s}}const x={"vs:#main-start":"\n#ifdef DATAFILTER_DOUBLE\ndataFilter_setValue(\nDATAFILTER_ATTRIB - filter_min64High + DATAFILTER_ATTRIB_64LOW,\nDATAFILTER_ATTRIB - filter_max64High + DATAFILTER_ATTRIB_64LOW,\nDATACATEGORY_ATTRIB\n);\n#else\ndataFilter_setValue(DATAFILTER_ATTRIB, DATAFILTER_ATTRIB, DATACATEGORY_ATTRIB);\n#endif\n","vs:#main-end":"\nif (dataFilter_value == 0.0) {\ngl_Position = vec4(0.);\n}\n","vs:DECKGL_FILTER_SIZE":"\nif (filter_transformSize) {\nsize = size * dataFilter_value;\n}\n","fs:DECKGL_FILTER_COLOR":"\nif (dataFilter_value == 0.0) discard;\nif (filter_transformColor) {\ncolor.a *= dataFilter_value;\n}\n"},A={name:"data-filter",vs:T,fs:b,inject:x,getUniforms:P},E={name:"data-filter-fp64",vs:T,fs:b,inject:x,getUniforms:function(e){if(!e||!("extensions"in e))return{};const t=P(e);if(Number.isFinite(t.filter_min)){const e=Math.fround(t.filter_min);t.filter_min-=e,t.filter_softMin-=e,t.filter_min64High=e;const i=Math.fround(t.filter_max);t.filter_max-=i,t.filter_softMax-=i,t.filter_max64High=i}else{const e=t.filter_min.map(Math.fround);t.filter_min=t.filter_min.map(((t,i)=>t-e[i])),t.filter_softMin=t.filter_softMin.map(((t,i)=>t-e[i])),t.filter_min64High=e;const i=t.filter_max.map(Math.fround);t.filter_max=t.filter_max.map(((e,t)=>e-i[t])),t.filter_softMax=t.filter_softMax.map(((e,t)=>e-i[t])),t.filter_max64High=i}return t}},C=["float32-renderable-webgl","texture-blend-float-webgl"];const M={blend:!0,blendFunc:[1,1,1,1],blendEquation:[32774,32774],depthTest:!1},F={getFilterValue:{type:"accessor",value:0},getFilterCategory:{type:"accessor",value:0},onFilteredItemsChange:{type:"function",value:null,optional:!0},filterEnabled:!0,filterRange:[-1,1],filterSoftRange:null,filterCategories:[0],filterTransformSize:!0,filterTransformColor:!0},L={categorySize:1,filterSize:1,fp64:!1,countItems:!1},w={1:"float",2:"vec2",3:"vec3",4:"vec4"};class k extends t{static{this.defaultProps=F}static{this.extensionName="DataFilterExtension"}constructor(e={}){super({...L,...e})}getShaders(e){const{categorySize:t,filterSize:i,fp64:n}=e.opts;return{modules:[n?E:A],defines:{DATACATEGORY_TYPE:w[t],DATACATEGORY_CHANNELS:t,DATAFILTER_TYPE:w[i],DATAFILTER_DOUBLE:Boolean(n)}}}initializeState(e,t){const i=this.getAttributeManager(),{categorySize:n,filterSize:s,fp64:r}=t.opts;i&&i.add({filterValues:{size:s,type:r?"float64":"float32",accessor:"getFilterValue",shaderAttributes:{filterValues:{divisor:0},instanceFilterValues:{divisor:1}}},filterCategoryValues:{size:n,accessor:"getFilterCategory",transform:1===n?e=>t._getCategoryKey.call(this,e,0):e=>e.map(((e,i)=>t._getCategoryKey.call(this,e,i))),shaderAttributes:{filterCategoryValues:{divisor:0},instanceFilterCategoryValues:{divisor:1}}}});const{device:o}=this.context;if(i&&t.opts.countItems){const e=function(e){return C.every((t=>e.features.has(t)))}(o);i.add({filterIndices:{size:e?1:2,vertexOffset:1,type:"unorm8",accessor:(t,{index:i})=>{const n=t&&t.__source?t.__source.index:i;return e?(n+1)%255:[(n+1)%255,Math.floor(n/255)%255]},shaderAttributes:{filterPrevIndices:{vertexOffset:0},filterIndices:{vertexOffset:1}}}});const n=function(e,t){return t?e.createFramebuffer({width:1,height:1,colorAttachments:[e.createTexture({format:"rgba32float",type:5126,mipmaps:!1})]}):e.createFramebuffer({width:256,height:64,colorAttachments:[e.createTexture({format:"rgba8unorm",type:5126,mipmaps:!1})]})}(o,e),s=function(e,t,i){return t.defines.NON_INSTANCED_MODEL=1,i&&(t.defines.FLOAT_TARGET=1),new u(e,{id:"data-filter-aggregation-model",vertexCount:1,isInstanced:!1,drawMode:0,vs:"#version 300 es\n#define SHADER_NAME data-filter-vertex-shader\n\n#ifdef FLOAT_TARGET\n  in float filterIndices;\n  in float filterPrevIndices;\n#else\n  in vec2 filterIndices;\n  in vec2 filterPrevIndices;\n#endif\n\nout vec4 vColor;\nconst float component = 1.0 / 255.0;\n\nvoid main() {\n  #ifdef FLOAT_TARGET\n    dataFilter_value *= float(filterIndices != filterPrevIndices);\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    vColor = vec4(0.0, 0.0, 0.0, 1.0);\n  #else\n    // Float texture is not supported: pack result into 4 channels x 256 px x 64px\n    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);\n    float col = filterIndices.x;\n    float row = filterIndices.y * 4.0;\n    float channel = floor(row);\n    row = fract(row);\n    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));\n    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);\n  #endif\n  gl_PointSize = 1.0;\n}\n",fs:"#version 300 es\n#define SHADER_NAME data-filter-fragment-shader\nprecision highp float;\n\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main() {\n  if (dataFilter_value < 0.5) {\n    discard;\n  }\n  fragColor = vColor;\n}\n",...t})}(o,t.getShaders.call(this,t),e);this.setState({filterFBO:n,filterModel:s})}}updateState({props:e,oldProps:t,changeFlags:n},s){const r=this.getAttributeManager(),{categorySize:o}=s.opts;if(this.state.filterModel){const i=r.attributes.filterValues.needsUpdate()||r.attributes.filterCategoryValues?.needsUpdate()||e.filterEnabled!==t.filterEnabled||e.filterRange!==t.filterRange||e.filterSoftRange!==t.filterSoftRange||e.filterCategories!==t.filterCategories;i&&this.setState({filterNeedsUpdate:i})}if(r?.attributes.filterCategoryValues){const s=r.attributes.filterCategoryValues.needsUpdate()||!i(e.filterCategories,t.filterCategories,2);s&&this.setState({categoryBitMaskNeedsUpdate:s});n.dataChanged&&(this.setState({categoryMap:Array(o).fill(0).map((()=>({})))}),r.attributes.filterCategoryValues.setNeedsUpdate("categoryMap"))}}draw(e,t){const i=this.state.filterFBO,n=this.state.filterModel,s=this.state.filterNeedsUpdate,r=this.state.categoryBitMaskNeedsUpdate,{onFilteredItemsChange:o}=this.props;if(r&&t._updateCategoryBitMask.call(this,e,t),s&&o&&n){const{attributes:{filterValues:t,filterCategoryValues:s,filterIndices:r}}=this.getAttributeManager();n.setVertexCount(this.getNumInstances()),this.context.device.clearWebGL({framebuffer:i,color:[0,0,0,0]}),n.updateModuleSettings(e.moduleParameters),n.setAttributes({...t.getValue(),...s?.getValue(),...r?.getValue()}),n.setUniforms(e.uniforms),n.device.withParametersWebGL({framebuffer:i,...M,viewport:[0,0,i.width,i.height]},(()=>{n.draw(this.context.renderPass)}));const a=n.device.readPixelsToArrayWebGL(i);let l=0;for(let e=0;e<a.length;e++)l+=a[e];o({id:this.id,count:l}),this.state.filterNeedsUpdate=!1}}finalizeState(){const e=this.state.filterFBO,t=this.state.filterModel;e?.destroy(),t?.destroy()}_updateCategoryBitMask(e,t){const{categorySize:i}=t.opts,{filterCategories:s}=this.props,r=new Uint32Array([0,0,0,0]),o=1===i?[s]:s,a=1===i?128:2===i?64:32;for(let e=0;e<o.length;e++){const i=o[e];for(const s of i){const i=t._getCategoryKey.call(this,s,e);if(i<a){r[e*(a/32)+Math.floor(i/32)]+=Math.pow(2,i%32)}else n.warn(`Exceeded maximum number of categories (${a})`)()}}e.uniforms.filter_categoryBitMask=r,this.state.categoryBitMaskNeedsUpdate=!1}_getCategoryKey(e,t){const i=this.state.categoryMap[t];return e in i||(i[e]=Object.keys(i).length),i[e]}}const{fp64ify:R,fp64ifyMatrix4:I}=p;var O={name:"project64",dependencies:[e,p],vs:"const vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\nuniform vec2 project_uViewProjectionMatrixFP64[16];\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {\n#if defined(NVIDIA_FP64_WORKAROUND)\nout_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\n#else\nout_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\n#endif\nout_val[1] = sum_fp64(PI_FP64,\nlog_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\nreturn;\n}\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\nvec2 pos_fp64[2];\nmercatorProject_fp64(position_fp64, pos_fp64);\nout_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);\nout_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);\nreturn;\n}\nvoid project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {\nvec4 position64xy = vec4(\nposition.x, position64xyLow.x,\nposition.y, position64xyLow.y);\nproject_position_fp64(position64xy, out_val);\n}\nvec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\nvec2 vertex_pos_clipspace[4];\nmat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,\nvertex_pos_clipspace);\nreturn vec4(\nvertex_pos_clipspace[0].x,\nvertex_pos_clipspace[1].x,\nvertex_pos_clipspace[2].x,\nvertex_pos_clipspace[3].x\n);\n}\nvec4 project_position_to_clipspace(\nvec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition\n) {\nvec2 offset64[4];\nvec4_fp64(vec4(offset, 0.0), offset64);\nfloat z = project_size(position.z);\nvec2 projectedPosition64xy[2];\nproject_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);\nvec2 commonPosition64[4];\ncommonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);\ncommonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);\ncommonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));\ncommonPosition64[3] = vec2(1.0, 0.0);\ncommonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);\nreturn project_common_position_to_clipspace_fp64(commonPosition64);\n}\nvec4 project_position_to_clipspace(\nvec3 position, vec3 position64xyLow, vec3 offset\n) {\nvec4 commonPosition;\nreturn project_position_to_clipspace(\nposition, position64xyLow, offset, commonPosition\n);\n}\n",getUniforms:function(e){if(e&&"viewport"in e){const{viewProjectionMatrix:t,scale:i}=e.viewport;return B({viewProjectionMatrix:t,scale:i})}return{}}};const B=s((function({viewProjectionMatrix:e,scale:t}){const i=I(e),n=R(t);return{project_uViewProjectionMatrixFP64:i,project64_uViewProjectionMatrix:i,project64_uScale:n}}));class D extends t{static{this.extensionName="Fp64Extension"}getShaders(){const{coordinateSystem:e}=this.props;if(e!==r.LNGLAT&&e!==r.DEFAULT)throw new Error("fp64: coordinateSystem must be LNGLAT");return{modules:[O]}}}const S={inject:{"vs:#decl":"\nin vec2 instanceDashArrays;\nin float instanceDashOffsets;\nout vec2 vDashArray;\nout float vDashOffset;\n","vs:#main-end":"\nvDashArray = instanceDashArrays;\nvDashOffset = instanceDashOffsets / width.x;\n","fs:#decl":"\nuniform float dashAlignMode;\nuniform float capType;\nuniform bool dashGapPickable;\nin vec2 vDashArray;\nin float vDashOffset;\n","fs:#main-start":"\nfloat solidLength = vDashArray.x;\nfloat gapLength = vDashArray.y;\nfloat unitLength = solidLength + gapLength;\nfloat offset;\nif (unitLength > 0.0) {\nif (dashAlignMode == 0.0) {\noffset = vDashOffset;\n} else {\nunitLength = vPathLength / round(vPathLength / unitLength);\noffset = solidLength / 2.0;\n}\nfloat unitOffset = mod(vPathPosition.y + offset, unitLength);\nif (gapLength > 0.0 && unitOffset > solidLength) {\nif (capType <= 0.5) {\nif (!(dashGapPickable && bool(picking.isActive))) {\ndiscard;\n}\n} else {\nfloat distToEnd = length(vec2(\nmin(unitOffset - solidLength, unitLength - unitOffset),\nvPathPosition.x\n));\nif (distToEnd > 1.0) {\nif (!(dashGapPickable && bool(picking.isActive))) {\ndiscard;\n}\n}\n}\n}\n}\n"}},N={inject:{"vs:#decl":"\nin float instanceOffsets;\n","vs:DECKGL_FILTER_SIZE":"\nfloat offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\nsize *= offsetWidth;\n","vs:#main-end":"\nfloat offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\nfloat offsetDir = sign(instanceOffsets);\nvPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;\nvPathPosition.y *= offsetWidth;\nvPathLength *= offsetWidth;\n","fs:#main-start":"\nfloat isInside;\nisInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\nif (isInside == 0.0) {\ndiscard;\n}\n"}},V={getDashArray:{type:"accessor",value:[0,0]},getOffset:{type:"accessor",value:0},dashJustified:!1,dashGapPickable:!1};class z extends t{static{this.defaultProps=V}static{this.extensionName="PathStyleExtension"}constructor({dash:e=!1,offset:t=!1,highPrecisionDash:i=!1}={}){super({dash:e||i,offset:t,highPrecisionDash:i})}isEnabled(e){return"pathTesselator"in e.state}getShaders(e){if(!e.isEnabled(this))return null;let t={};return e.opts.dash&&(t=o(t,S)),e.opts.offset&&(t=o(t,N)),t}initializeState(e,t){const i=this.getAttributeManager();i&&t.isEnabled(this)&&(t.opts.dash&&i.addInstanced({instanceDashArrays:{size:2,accessor:"getDashArray"},instanceDashOffsets:t.opts.highPrecisionDash?{size:1,accessor:"getPath",transform:t.getDashOffsets.bind(this)}:{size:1,update:e=>{e.constant=!0,e.value=[0]}}}),t.opts.offset&&i.addInstanced({instanceOffsets:{size:1,accessor:"getOffset"}}))}updateState(e,t){if(!t.isEnabled(this))return;const i={};t.opts.dash&&(i.dashAlignMode=this.props.dashJustified?1:0,i.dashGapPickable=Boolean(this.props.dashGapPickable)),this.state.model?.setUniforms(i)}getDashOffsets(e){const t=[0],i="XY"===this.props.positionFormat?2:3,n=Array.isArray(e[0]),s=n?e.length:e.length/i;let r,o;for(let a=0;a<s-1;a++)r=n?e[a]:e.slice(a*i,a*i+i),r=this.projectPosition(r),a>0&&(t[a]=t[a-1]+h.dist(o,r)),o=r;return t[s-1]=0,t}}const j={name:"fill-pattern",vs:"\n#ifdef NON_INSTANCED_MODEL\n#define FILL_PATTERN_FRAME_ATTRIB fillPatternFrames\n#define FILL_PATTERN_SCALE_ATTRIB fillPatternScales\n#define FILL_PATTERN_OFFSET_ATTRIB fillPatternOffsets\n#else\n#define FILL_PATTERN_FRAME_ATTRIB instanceFillPatternFrames\n#define FILL_PATTERN_SCALE_ATTRIB instanceFillPatternScales\n#define FILL_PATTERN_OFFSET_ATTRIB instanceFillPatternOffsets\n#endif\nin vec4 FILL_PATTERN_FRAME_ATTRIB;\nin float FILL_PATTERN_SCALE_ATTRIB;\nin vec2 FILL_PATTERN_OFFSET_ATTRIB;\nuniform bool fill_patternEnabled;\nuniform vec2 fill_patternTextureSize;\nout vec2 fill_uv;\nout vec4 fill_patternBounds;\nout vec4 fill_patternPlacement;\n",fs:"\nuniform bool fill_patternEnabled;\nuniform bool fill_patternMask;\nuniform sampler2D fill_patternTexture;\nuniform vec2 fill_uvCoordinateOrigin;\nuniform vec2 fill_uvCoordinateOrigin64Low;\nin vec4 fill_patternBounds;\nin vec4 fill_patternPlacement;\nin vec2 fill_uv;\nconst float FILL_UV_SCALE = 512.0 / 40000000.0;\n",inject:{"vs:DECKGL_FILTER_GL_POSITION":"\nfill_uv = geometry.position.xy;\n","vs:DECKGL_FILTER_COLOR":"\nif (fill_patternEnabled) {\nfill_patternBounds = FILL_PATTERN_FRAME_ATTRIB / vec4(fill_patternTextureSize, fill_patternTextureSize);\nfill_patternPlacement.xy = FILL_PATTERN_OFFSET_ATTRIB;\nfill_patternPlacement.zw = FILL_PATTERN_SCALE_ATTRIB * FILL_PATTERN_FRAME_ATTRIB.zw;\n}\n","fs:DECKGL_FILTER_COLOR":"\nif (fill_patternEnabled) {\nvec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;\nvec2 patternUV = mod(mod(fill_uvCoordinateOrigin, scale) + fill_uvCoordinateOrigin64Low + fill_uv, scale) / scale;\npatternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);\nvec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;\nvec4 patternColor = texture(fill_patternTexture, texCoords);\ncolor.a *= patternColor.a;\nif (!fill_patternMask) {\ncolor.rgb = patternColor.rgb;\n}\n}\n"},dependencies:[e],getUniforms:function(e,t){if(!e)return{};if("fillPatternTexture"in e){const{fillPatternTexture:t}=e;return{fill_patternTexture:t,fill_patternTextureSize:[t.width,t.height]}}if("viewport"in e){const{fillPatternMask:i=!0,fillPatternEnabled:n=!0}=e,{project_uCommonOrigin:s}=t,r=[a(s[0]),a(s[1])];return{fill_uvCoordinateOrigin:s.slice(0,2),fill_uvCoordinateOrigin64Low:r,fill_patternMask:i,fill_patternEnabled:n}}return{}}},G={fillPatternEnabled:!0,fillPatternAtlas:{type:"image",value:null,async:!0,parameters:{lodMaxClamp:0}},fillPatternMapping:{type:"object",value:{},async:!0},fillPatternMask:!0,getFillPattern:{type:"accessor",value:e=>e.pattern},getFillPatternScale:{type:"accessor",value:1},getFillPatternOffset:{type:"accessor",value:[0,0]}};class U extends t{static{this.defaultProps=G}static{this.extensionName="FillStyleExtension"}constructor({pattern:e=!1}={}){super({pattern:e})}isEnabled(e){return null!==e.getAttributeManager()&&!("pathTesselator"in e.state)}getShaders(e){return e.isEnabled(this)?{modules:[e.opts.pattern&&j].filter(Boolean)}:null}initializeState(e,t){if(!t.isEnabled(this))return;const i=this.getAttributeManager();t.opts.pattern&&i.add({fillPatternFrames:{size:4,accessor:"getFillPattern",transform:t.getPatternFrame.bind(this),shaderAttributes:{fillPatternFrames:{divisor:0},instanceFillPatternFrames:{divisor:1}}},fillPatternScales:{size:1,accessor:"getFillPatternScale",defaultValue:1,shaderAttributes:{fillPatternScales:{divisor:0},instanceFillPatternScales:{divisor:1}}},fillPatternOffsets:{size:2,accessor:"getFillPatternOffset",shaderAttributes:{fillPatternOffsets:{divisor:0},instanceFillPatternOffsets:{divisor:1}}}}),this.setState({emptyTexture:this.context.device.createTexture({data:new Uint8Array(4),width:1,height:1})})}updateState({props:e,oldProps:t},i){i.isEnabled(this)&&e.fillPatternMapping&&e.fillPatternMapping!==t.fillPatternMapping&&this.getAttributeManager().invalidate("getFillPattern")}draw(e,t){if(!t.isEnabled(this))return;const{fillPatternAtlas:i}=this.props;this.setModuleParameters({fillPatternTexture:i||this.state.emptyTexture})}finalizeState(){const e=this.state.emptyTexture;e?.delete()}getPatternFrame(e){const{fillPatternMapping:t}=this.getCurrentLayer().props,i=t&&t[e];return i?[i.x,i.y,i.width,i.height]:[0,0,0,0]}}const H={clipBounds:[0,0,1,1],clipByInstance:void 0},Y="\nuniform vec4 clip_bounds;\nbool clip_isInBounds(vec2 position) {\nreturn position.x >= clip_bounds[0] && position.y >= clip_bounds[1] && position.x < clip_bounds[2] && position.y < clip_bounds[3];\n}\n",K={name:"clip-vs",vs:Y},W={"vs:#decl":"\nout float clip_isVisible;\n","vs:DECKGL_FILTER_GL_POSITION":"\nclip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));\n","fs:#decl":"\nin float clip_isVisible;\n","fs:DECKGL_FILTER_COLOR":"\nif (clip_isVisible < 0.5) discard;\n"},$={name:"clip-fs",fs:Y},Z={"vs:#decl":"\nout vec2 clip_commonPosition;\n","vs:DECKGL_FILTER_GL_POSITION":"\nclip_commonPosition = geometry.position.xy;\n","fs:#decl":"\nin vec2 clip_commonPosition;\n","fs:DECKGL_FILTER_COLOR":"\nif (!clip_isInBounds(clip_commonPosition)) discard;\n"};class q extends t{static{this.defaultProps=H}static{this.extensionName="ClipExtension"}getShaders(){let e="instancePositions"in this.getAttributeManager().attributes;return void 0!==this.props.clipByInstance&&(e=Boolean(this.props.clipByInstance)),this.state.clipByInstance=e,e?{modules:[K],inject:W}:{modules:[$],inject:Z}}draw({uniforms:e}){const{clipBounds:t}=this.props;if(this.state.clipByInstance)e.clip_bounds=t;else{const i=this.projectPosition([t[0],t[1],0]),n=this.projectPosition([t[2],t[3],0]);e.clip_bounds=[Math.min(i[0],n[0]),Math.min(i[1],n[1]),Math.max(i[0],n[0]),Math.max(i[1],n[1])]}}}var J={name:"collision",dependencies:[e],vs:"\n#ifdef NON_INSTANCED_MODEL\nin float collisionPriorities;\n#else\nin float instanceCollisionPriorities;\n#endif\nuniform sampler2D collision_texture;\nuniform bool collision_sort;\nuniform bool collision_enabled;\nvec2 collision_getCoords(vec4 position) {\nvec4 collision_clipspace = project_common_position_to_clipspace(position);\nreturn (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;\n}\nfloat collision_match(vec2 tex, vec3 pickingColor) {\nvec4 collision_pickingColor = texture(collision_texture, tex);\nfloat delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));\nfloat e = 0.001;\nreturn step(delta, e);\n}\nfloat collision_isVisible(vec2 texCoords, vec3 pickingColor) {\nif (!collision_enabled) {\nreturn 1.0;\n}\nconst int N = 2;\nfloat accumulator = 0.0;\nvec2 step = vec2(1.0 / project_uViewportSize);\nconst float floatN = float(N);\nvec2 delta = -floatN * step;\nfor(int i = -N; i <= N; i++) {\ndelta.x = -step.x * floatN;\nfor(int j = -N; j <= N; j++) {\naccumulator += collision_match(texCoords + delta, pickingColor);\ndelta.x += step.x;\n}\ndelta.y += step.y;\n}\nfloat W = 2.0 * floatN + 1.0;\nreturn pow(accumulator / (W * W), 2.2);\n}\n",inject:{"vs:#decl":"\nfloat collision_fade = 1.0;\n","vs:DECKGL_FILTER_GL_POSITION":"\nif (collision_sort) {\n#ifdef NON_INSTANCED_MODEL\nfloat collisionPriority = collisionPriorities;\n#else\nfloat collisionPriority = instanceCollisionPriorities;\n#endif\nposition.z = -0.001 * collisionPriority * position.w;\n}\nif (collision_enabled) {\nvec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));\nvec2 collision_texCoords = collision_getCoords(collision_common_position);\ncollision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);\nif (collision_fade < 0.0001) {\nposition = vec4(0.0, 0.0, 2.0, 1.0);\n}\n}\n","vs:DECKGL_FILTER_COLOR":"\ncolor.a *= collision_fade;\n"},getUniforms:(e,t)=>{if(!e||!("dummyCollisionMap"in e))return{};const{collisionFBO:i,drawToCollisionMap:n,dummyCollisionMap:s}=e;return{collision_sort:Boolean(n),collision_texture:!n&&i?i.colorAttachments[0]:s}}};class X extends l{renderCollisionMap(e,t){const i=[1,1,e.width-2,e.height-2];this.render({...t,clearColor:[0,0,0,0],scissorRect:i,target:e,pass:"collision"})}getLayerParameters(e,t,i){return{...e.props.parameters,blend:!1,depthRange:[0,1],depthTest:!0}}getModuleParameters(){return{drawToCollisionMap:!0,picking:{isActive:1,isAttribute:!1},lightSources:{}}}}class Q{constructor(){this.id="collision-filter-effect",this.props=null,this.useInPicking=!0,this.order=1,this.channels={},this.collisionFBOs={}}setup(e){this.context=e;const{device:t}=e;this.dummyCollisionMap=t.createTexture({width:1,height:1}),this.collisionFilterPass=new X(t,{id:"default-collision-filter"})}preRender({effects:e,layers:t,layerFilter:i,viewports:n,onViewportActive:s,views:r,isPicking:o,preRenderStats:a={}}){const{device:l}=this.context;if(o)return;const c=t.filter((({props:{visible:e,collisionEnabled:t}})=>e&&t));if(0===c.length)return void(this.channels={});const d=e?.filter((e=>e.useInPicking&&a[e.id])),f=a["mask-effect"]?.didRender,u=this._groupByCollisionGroup(l,c),p=n[0],h=!this.lastViewport||!this.lastViewport.equals(p)||f;for(const e in u){const t=this.collisionFBOs[e],n=u[e],[o,a]=l.canvasContext.getPixelSize();t.resize({width:o/2,height:a/2}),this._render(n,{effects:d,layerFilter:i,onViewportActive:s,views:r,viewport:p,viewportChanged:h})}}_render(e,{effects:t,layerFilter:n,onViewportActive:s,views:r,viewport:o,viewportChanged:a}){const{collisionGroup:l}=e,c=this.channels[l];if(!c)return;const d=a||e===c||!i(c.layers,e.layers,1)||e.layerBounds.some(((e,t)=>!m(e,c.layerBounds[t])))||e.allLayersLoaded!==c.allLayersLoaded||e.layers.some((e=>e.props.transitions));if(this.channels[l]=e,d){this.lastViewport=o;const i=this.collisionFBOs[l];this.collisionFilterPass.renderCollisionMap(i,{pass:"collision-filter",isPicking:!0,layers:e.layers,effects:t,layerFilter:n,viewports:o?[o]:[],onViewportActive:s,views:r,moduleParameters:{dummyCollisionMap:this.dummyCollisionMap,devicePixelRatio:i.device.canvasContext.getDevicePixelRatio()/2}})}}_groupByCollisionGroup(e,t){const i={};for(const e of t){const{collisionGroup:t}=e.props;let n=i[t];n||(n={collisionGroup:t,layers:[],layerBounds:[],allLayersLoaded:!0},i[t]=n),n.layers.push(e),n.layerBounds.push(e.getBounds()),e.isLoaded||(n.allLayersLoaded=!1)}for(const t of Object.keys(i))this.collisionFBOs[t]||this.createFBO(e,t),this.channels[t]||(this.channels[t]=i[t]);for(const e of Object.keys(this.collisionFBOs))i[e]||this.destroyFBO(e);return i}getModuleParameters(e){const{collisionGroup:t}=e.props,{collisionFBOs:i,dummyCollisionMap:n}=this;return{collisionFBO:i[t],dummyCollisionMap:n}}cleanup(){this.dummyCollisionMap&&(this.dummyCollisionMap.delete(),this.dummyCollisionMap=void 0),this.channels={};for(const e of Object.keys(this.collisionFBOs))this.destroyFBO(e);this.collisionFBOs={},this.lastViewport=void 0}createFBO(e,t){const{width:i,height:n}=e.gl.canvas,s=e.createTexture({format:"rgba8unorm",width:i,height:n,sampler:{minFilter:"nearest",magFilter:"nearest",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}}),r=e.createTexture({format:"depth16unorm",width:i,height:n,mipmaps:!1,dataFormat:6402,type:5125});this.collisionFBOs[t]=e.createFramebuffer({id:`collision-${t}`,width:i,height:n,colorAttachments:[s],depthStencilAttachment:r})}destroyFBO(e){const t=this.collisionFBOs[e];t.colorAttachments[0]?.destroy(),t.depthStencilAttachment?.destroy(),t.destroy(),delete this.collisionFBOs[e]}}const ee={getCollisionPriority:{type:"accessor",value:0},collisionEnabled:!0,collisionGroup:{type:"string",value:"default"},collisionTestProps:{}};class te extends t{static{this.defaultProps=ee}static{this.extensionName="CollisionFilterExtension"}getShaders(){return{modules:[J]}}draw({uniforms:e,context:t,moduleParameters:i}){const{collisionEnabled:n}=this.props,{collisionFBO:s,drawToCollisionMap:r}=i,o=n&&Boolean(s);e.collision_enabled=o,r&&(this.props=this.clone(this.props.collisionTestProps).props)}initializeState(e,t){if(null===this.getAttributeManager())return;this.context.deck?._addDefaultEffect(new Q);this.getAttributeManager().add({collisionPriorities:{size:1,accessor:"getCollisionPriority",shaderAttributes:{collisionPriorities:{divisor:0},instanceCollisionPriorities:{divisor:1}}}})}getNeedsPickingBuffer(){return this.props.collisionEnabled}}var ie={name:"mask",dependencies:[e],vs:"\nuniform vec4 mask_bounds;\nuniform bool mask_maskByInstance;\nvec2 mask_getCoords(vec4 position) {\nreturn (position.xy - mask_bounds.xy) / (mask_bounds.zw - mask_bounds.xy);\n}\n",fs:"\nuniform sampler2D mask_texture;\nuniform int mask_channel;\nuniform bool mask_enabled;\nuniform bool mask_inverted;\nbool mask_isInBounds(vec2 texCoords) {\nif (!mask_enabled) {\nreturn true;\n}\nvec4 maskColor = texture(mask_texture, texCoords);\nfloat maskValue = 1.0;\nif (mask_channel == 0) {\nmaskValue = maskColor.r;\n} else if (mask_channel == 1) {\nmaskValue = maskColor.g;\n} else if (mask_channel == 2) {\nmaskValue = maskColor.b;\n} else if (mask_channel == 3) {\nmaskValue = maskColor.a;\n}\nif (mask_inverted) {\nreturn maskValue >= 0.5;\n} else {\nreturn maskValue < 0.5;\n}\n}\n",inject:{"vs:#decl":"\nout vec2 mask_texCoords;\n","vs:#main-end":"\nvec4 mask_common_position;\nif (mask_maskByInstance) {\nmask_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n} else {\nmask_common_position = geometry.position;\n}\nmask_texCoords = mask_getCoords(mask_common_position);\n","fs:#decl":"\nin vec2 mask_texCoords;\n","fs:#main-start":"\nif (mask_enabled) {\nbool mask = mask_isInBounds(mask_texCoords);\nfragColor = texture(mask_texture, mask_texCoords);\nif (!mask) discard;\n}\n"},getUniforms:e=>e&&"maskMap"in e?{mask_texture:e.maskMap}:{}};const ne={blendColorOperation:"subtract",blendColorSrcFactor:"zero",blendColorDstFactor:"one",blendAlphaOperation:"subtract",blendAlphaSrcFactor:"zero",blendAlphaDstFactor:"one"};class se extends l{constructor(e,t){super(e,t);const{mapSize:i=2048}=t;this.maskMap=e.createTexture({format:"rgba8unorm",width:i,height:i,sampler:{minFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}}),this.fbo=e.createFramebuffer({id:"maskmap",width:i,height:i,colorAttachments:[this.maskMap]})}render(e){const t=2**e.channel;super.render({...e,clearColor:[255,255,255,255],colorMask:t,target:this.fbo,pass:"mask"})}getLayerParameters(e,t,i){return{...e.props.parameters,blend:!0,depthTest:!1,...ne}}shouldDrawLayer(e){return e.props.operation.includes("mask")}delete(){this.fbo.delete(),this.maskMap.delete()}}function re(e,t){const i=[1/0,1/0,-1/0,-1/0];for(const n of e){const e=n.getBounds();if(e){const s=n.projectPosition(e[0],{viewport:t,autoOffset:!1}),r=n.projectPosition(e[1],{viewport:t,autoOffset:!1});i[0]=Math.min(i[0],s[0]),i[1]=Math.min(i[1],s[1]),i[2]=Math.max(i[2],r[0]),i[3]=Math.max(i[3],r[1])}}return Number.isFinite(i[0])?i:null}function oe(e){const{bounds:t,viewport:i,border:n=0}=e,{isGeospatial:s}=i;if(t[2]<=t[0]||t[3]<=t[1])return null;const r=i.unprojectPosition([(t[0]+t[2])/2,(t[1]+t[3])/2,0]);let{width:o,height:a,zoom:l}=e;if(void 0===l){o-=2*n,a-=2*n;const e=Math.min(o/(t[2]-t[0]),a/(t[3]-t[1]));l=Math.min(Math.log2(e),20)}else if(!o||!a){const e=2**l;o=Math.round(Math.abs(t[2]-t[0])*e),a=Math.round(Math.abs(t[3]-t[1])*e);const i=2048-2*n;if(o>i||a>i){const e=i/Math.max(o,a);o=Math.round(o*e),a=Math.round(a*e),l+=Math.log2(e)}}return s?new c({id:i.id,x:n,y:n,width:o,height:a,longitude:r[0],latitude:r[1],zoom:l,orthographic:!0}):new d({id:i.id,x:n,y:n,width:o,height:a,target:r,zoom:l,flipY:!1})}function ae(e,t,i){if(!e)return[0,0,1,1];const n=function(e,t){let i;if(t&&2===t.length){const[n,s]=t,r=e.getBounds({z:n}),o=e.getBounds({z:s});i=[Math.min(r[0],o[0]),Math.min(r[1],o[1]),Math.max(r[2],o[2]),Math.max(r[3],o[3])]}else i=e.getBounds();const n=e.projectPosition(i.slice(0,2)),s=e.projectPosition(i.slice(2,4));return[n[0],n[1],s[0],s[1]]}(t,i),s=function(e){const t=e[2]-e[0],i=e[3]-e[1],n=(e[0]+e[2])/2,s=(e[1]+e[3])/2;return[n-t,s-i,n+t,s+i]}(n);return e[2]-e[0]<=s[2]-s[0]&&e[3]-e[1]<=s[3]-s[1]?e:[Math.max(e[0],s[0]),Math.max(e[1],s[1]),Math.min(e[2],s[2]),Math.min(e[3],s[3])]}class le{constructor(){this.id="mask-effect",this.props=null,this.useInPicking=!0,this.order=0,this.channels=[],this.masks=null}setup({device:e}){this.dummyMaskMap=e.createTexture({width:1,height:1}),this.maskPass=new se(e,{id:"default-mask"}),this.maskMap=this.maskPass.maskMap}preRender({layers:e,layerFilter:t,viewports:i,onViewportActive:s,views:r,isPicking:o}){let a=!1;if(o)return{didRender:a};const l=e.filter((e=>e.props.visible&&e.props.operation.includes("mask")));if(0===l.length)return this.masks=null,this.channels.length=0,{didRender:a};this.masks={};const c=this._sortMaskChannels(l),d=i[0],f=!this.lastViewport||!this.lastViewport.equals(d);if(void 0!==d.resolution)return n.warn("MaskExtension is not supported in GlobeView")(),{didRender:a};for(const e in c){const i=this._renderChannel(c[e],{layerFilter:t,onViewportActive:s,views:r,viewport:d,viewportChanged:f});a||=i}return{didRender:a}}_renderChannel(e,{layerFilter:t,onViewportActive:i,views:n,viewport:s,viewportChanged:r}){let o=!1;const a=this.channels[e.index];if(!a)return o;const l=e===a||e.layers.length!==a.layers.length||e.layers.some(((e,t)=>e!==a.layers[t]||e.props.transitions))||e.layerBounds.some(((e,t)=>e!==a.layerBounds[t]));if(e.bounds=a.bounds,e.maskBounds=a.maskBounds,this.channels[e.index]=e,l||r){this.lastViewport=s;const r=re(e.layers,s);if(e.bounds=r&&ae(r,s),l||!m(e.bounds,a.bounds)){const{maskPass:a,maskMap:l}=this,c=r&&oe({bounds:e.bounds,viewport:s,width:l.width,height:l.height,border:1});e.maskBounds=c?c.getBounds():[0,0,1,1],a.render({pass:"mask",channel:e.index,layers:e.layers,layerFilter:t,viewports:c?[c]:[],onViewportActive:i,views:n,moduleParameters:{devicePixelRatio:1}}),o=!0}}return this.masks[e.id]={index:e.index,bounds:e.maskBounds,coordinateOrigin:e.coordinateOrigin,coordinateSystem:e.coordinateSystem},o}_sortMaskChannels(e){const t={};let i=0;for(const s of e){const{id:e}=s.root;let r=t[e];if(!r){if(++i>4){n.warn("Too many mask layers. The max supported is 4")();continue}r={id:e,index:this.channels.findIndex((t=>t?.id===e)),layers:[],layerBounds:[],coordinateOrigin:s.root.props.coordinateOrigin,coordinateSystem:s.root.props.coordinateSystem},t[e]=r}r.layers.push(s),r.layerBounds.push(s.getBounds())}for(let e=0;e<4;e++){const i=this.channels[e];i&&i.id in t||(this.channels[e]=null)}for(const e in t){const i=t[e];i.index<0&&(i.index=this.channels.findIndex((e=>!e)),this.channels[i.index]=i)}return t}getModuleParameters(){return{maskMap:this.masks?this.maskMap:this.dummyMaskMap,maskChannels:this.masks}}cleanup(){this.dummyMaskMap&&(this.dummyMaskMap.delete(),this.dummyMaskMap=void 0),this.maskPass&&(this.maskPass.delete(),this.maskPass=void 0,this.maskMap=void 0),this.lastViewport=void 0,this.masks=null,this.channels.length=0}}const ce={maskId:"",maskByInstance:void 0,maskInverted:!1};class de extends t{static{this.defaultProps=ce}static{this.extensionName="MaskExtension"}initializeState(){this.context.deck?._addDefaultEffect(new le)}getShaders(){let e="instancePositions"in this.getAttributeManager().attributes;return void 0!==this.props.maskByInstance&&(e=Boolean(this.props.maskByInstance)),this.state.maskByInstance=e,{modules:[ie]}}draw({uniforms:e,context:t,moduleParameters:i}){e.mask_maskByInstance=this.state.maskByInstance;const{maskId:s,maskInverted:o}=this.props,{maskChannels:a}=i,{viewport:l}=t;if(a&&a[s]){const{index:t,bounds:i,coordinateOrigin:n}=a[s];let{coordinateSystem:c}=a[s];e.mask_enabled=!0,e.mask_channel=t,e.mask_inverted=o,c===r.DEFAULT&&(c=l.isGeospatial?r.LNGLAT:r.CARTESIAN);const d={modelMatrix:null,fromCoordinateOrigin:n,fromCoordinateSystem:c},f=this.projectPosition([i[0],i[1],0],d),u=this.projectPosition([i[2],i[3],0],d);e.mask_bounds=[f[0],f[1],u[0],u[1]]}else s&&n.warn(`Could not find a mask layer with id: ${s}`)(),e.mask_enabled=!1}}const fe={NONE:0,WRITE_HEIGHT_MAP:1,USE_HEIGHT_MAP:2,USE_COVER:3,USE_COVER_ONLY:4,SKIP:5},ue=Object.keys(fe).map((e=>`const float TERRAIN_MODE_${e} = ${fe[e]}.0;`)).join("\n"),pe={name:"terrain",dependencies:[e],inject:{"vs:#decl":"\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nout vec3 commonPos;\n"+ue,"vs:#main-start":"\nif (terrain_mode == TERRAIN_MODE_SKIP) {\ngl_Position = vec4(0.0);\nreturn;\n}\n","vs:DECKGL_FILTER_GL_POSITION":"\ncommonPos = geometry.position.xyz;\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\nvec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\nposition = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);\ncommonPos.z += project_uCommonOrigin.z;\n}\nif (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {\nvec3 anchor = geometry.worldPosition;\nanchor.z = 0.0;\nvec3 anchorCommon = project_position(anchor);\nvec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;\nif (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {\nfloat terrainZ = texture(terrain_map, texCoords).r;\ngeometry.position.z += terrainZ;\nposition = project_common_position_to_clipspace(geometry.position);\n}\n}\n","fs:#decl":"\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nin vec3 commonPos;\n"+ue,"fs:#main-start":"\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\nfragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);\nreturn;\n}\n","fs:DECKGL_FILTER_COLOR":"\nif ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {\nvec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\nvec4 pixel = texture(terrain_map, texCoords);\nif (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {\ncolor = pixel;\n} else {\ncolor = pixel + color * (1.0 - pixel.a);\n}\nreturn;\n}\n"},getUniforms:(e={},t)=>{if("dummyHeightMap"in e){const{drawToTerrainHeightMap:i,heightMap:n,heightMapBounds:s,dummyHeightMap:r,terrainCover:o,useTerrainHeightMap:a,terrainSkipRender:l}=e,{project_uCommonOrigin:c}=t;let d=l?fe.SKIP:fe.NONE,f=r,u=null;if(i)d=fe.WRITE_HEIGHT_MAP,u=s;else if(a&&n)d=fe.USE_HEIGHT_MAP,f=n,u=s;else if(o){const t=e.picking?.isActive,i=t?o.getPickingFramebuffer():o.getRenderFramebuffer();f=i?.colorAttachments[0].texture,t&&(d=fe.SKIP),f?(d=d===fe.SKIP?fe.USE_COVER_ONLY:fe.USE_COVER,u=o.bounds):f=r}return{terrain_mode:d,terrain_map:f,terrain_bounds:u?[u[0]-c[0],u[1]-c[1],u[2]-u[0],u[3]-u[1]]:[0,0,0,0]}}return null}};function he(e,t){return e.createFramebuffer({id:t.id,colorAttachments:[e.createTexture({id:t.id,...t.float&&{format:"rgba32float",type:5126},mipmaps:!1,sampler:!1===t.interpolate?{minFilter:"nearest",magFilter:"nearest"}:{minFilter:"linear",magFilter:"linear"}})]})}class me{constructor(e){this.isDirty=!0,this.renderViewport=null,this.bounds=null,this.layers=[],this.targetBounds=null,this.targetBoundsCommon=null,this.targetLayer=e,this.tile=_e(e)}get id(){return this.targetLayer.id}get isActive(){return Boolean(this.targetLayer.getCurrentLayer())}shouldUpdate({targetLayer:e,viewport:t,layers:i,layerNeedsRedraw:n}){e&&(this.targetLayer=e);const s=!!t&&this._updateViewport(t);let r=!!i&&this._updateLayers(i);if(n)for(const e of this.layers)if(n[e]){r=!0;break}return r||s}_updateLayers(e){let t=!1;if((e=this.tile?function(e,t){return t.filter((t=>{const i=_e(t);return!i||function(e,t){if(e&&t)return e[0][0]<t[1][0]&&t[0][0]<e[1][0]&&e[0][1]<t[1][1]&&t[0][1]<e[1][1];return!1}(e.boundingBox,i.boundingBox)}))}(this.tile,e):e).length!==this.layers.length)t=!0;else for(let i=0;i<e.length;i++){if(e[i].id!==this.layers[i]){t=!0;break}}return t&&(this.layers=e.map((e=>e.id))),t}_updateViewport(e){const t=this.targetLayer;let i=!1;if(this.tile&&"boundingBox"in this.tile){if(!this.targetBounds){i=!0,this.targetBounds=this.tile.boundingBox;const t=e.projectPosition(this.targetBounds[0]),n=e.projectPosition(this.targetBounds[1]);this.targetBoundsCommon=[t[0],t[1],n[0],n[1]]}}else this.targetBounds!==t.getBounds()&&(i=!0,this.targetBounds=t.getBounds(),this.targetBoundsCommon=re([t],e));if(!this.targetBoundsCommon)return!1;const n=Math.ceil(e.zoom+.5);if(this.tile)this.bounds=this.targetBoundsCommon;else{const t=this.renderViewport?.zoom;i=i||n!==t;const s=ae(this.targetBoundsCommon,e),r=this.bounds;i=i||!r||s.some(((e,t)=>e!==r[t])),this.bounds=s}return i&&(this.renderViewport=oe({bounds:this.bounds,zoom:n,viewport:e})),i}getRenderFramebuffer(){return this.renderViewport&&0!==this.layers.length?(this.fbo||(this.fbo=he(this.targetLayer.context.device,{id:this.id})),this.fbo):null}getPickingFramebuffer(){return!this.renderViewport||0===this.layers.length&&!this.targetLayer.props.pickable?null:(this.pickingFbo||(this.pickingFbo=he(this.targetLayer.context.device,{id:`${this.id}-picking`,interpolate:!1})),this.pickingFbo)}filterLayers(e){return e.filter((({id:e})=>this.layers.includes(e)))}delete(){const{fbo:e,pickingFbo:t}=this;e&&(e.colorAttachments[0].destroy(),e.destroy()),t&&(t.colorAttachments[0].destroy(),t.destroy())}}function _e(e){for(;e;){const{tile:t}=e.props;if(t)return t;e=e.parent}return null}const ge={blendColorOperation:"max",blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaOperation:"max",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one"};class ve extends l{getRenderableLayers(e,t){const{layers:i}=t,n=[],s=this._getDrawLayerParams(e,t,!0);for(let e=0;e<i.length;e++){const t=i[e];!t.isComposite&&s[e].shouldDrawLayer&&n.push(t)}return n}renderHeightMap(e,t){const i=e.getRenderFramebuffer(),n=e.renderViewport;i&&n&&(i.resize(n),this.render({...t,target:i,pass:"terrain-height-map",layers:t.layers,viewports:[n],effects:[],clearColor:[0,0,0,0]}))}renderTerrainCover(e,t){const i=e.getRenderFramebuffer(),n=e.renderViewport;if(!i||!n)return;const s=e.filterLayers(t.layers);i.resize(n),this.render({...t,target:i,pass:`terrain-cover-${e.id}`,layers:s,effects:[],viewports:[n],clearColor:[0,0,0,0]})}getLayerParameters(e,t,i){return{...e.props.parameters,blend:!0,depthTest:!1,...e.props.operation.includes("terrain")&&ge}}}class ye extends f{constructor(){super(...arguments),this.drawParameters={}}getRenderableLayers(e,t){const{layers:i}=t,n=[];this.drawParameters={},this._resetColorEncoder(t.pickZ);const s=this._getDrawLayerParams(e,t);for(let e=0;e<i.length;e++){const t=i[e];!t.isComposite&&s[e].shouldDrawLayer&&(n.push(t),this.drawParameters[t.id]=s[e].layerParameters)}return n}renderTerrainCover(e,t){const i=e.getPickingFramebuffer(),n=e.renderViewport;if(!i||!n)return;const s=e.filterLayers(t.layers),r=e.targetLayer;r.props.pickable&&s.unshift(r),i.resize(n),this.render({...t,pickingFBO:i,pass:`terrain-cover-picking-${e.id}`,layers:s,effects:[],viewports:[n],cullRect:void 0,deviceRect:n,pickZ:!1})}getLayerParameters(e,t,i){let n;return this.drawParameters[e.id]?n=this.drawParameters[e.id]:(n=super.getLayerParameters(e,t,i),n.blend=!0),{...n,depthTest:!1}}}class Te{static isSupported(e){return e.isTextureFormatRenderable("rgba32float")}constructor(e){this.renderViewport=null,this.bounds=null,this.layers=[],this.layersBounds=[],this.layersBoundsCommon=null,this.lastViewport=null,this.device=e}getRenderFramebuffer(){return this.renderViewport?(this.fbo||(this.fbo=he(this.device,{id:"height-map",float:!0})),this.fbo):null}shouldUpdate({layers:e,viewport:t}){const i=e.length!==this.layers.length||e.some(((e,t)=>e!==this.layers[t]||e.props.transitions||e.getBounds()!==this.layersBounds[t]));i&&(this.layers=e,this.layersBounds=e.map((e=>e.getBounds())),this.layersBoundsCommon=re(e,t));const n=!this.lastViewport||!t.equals(this.lastViewport);if(this.layersBoundsCommon){if(i||n){const e=ae(this.layersBoundsCommon,t);if(e[2]<=e[0]||e[3]<=e[1])return this.renderViewport=null,!1;this.bounds=e,this.lastViewport=t;const i=t.scale,n=(e[2]-e[0])*i,s=(e[3]-e[1])*i;return this.renderViewport=n>0||s>0?oe({bounds:[t.center[0]-1,t.center[1]-1,t.center[0]+1,t.center[1]+1],zoom:t.zoom,width:Math.min(n,2048),height:Math.min(s,2048),viewport:t}):null,!0}}else this.renderViewport=null;return!1}delete(){this.fbo&&(this.fbo.colorAttachments[0].delete(),this.fbo.delete())}}class be{constructor(){this.id="terrain-effect",this.props=null,this.useInPicking=!0,this.isPicking=!1,this.isDrapingEnabled=!1,this.terrainCovers=new Map}setup({device:e,deck:t}){this.dummyHeightMap=e.createTexture({width:1,height:1,data:new Uint8Array([0,0,0,0])}),this.terrainPass=new ve(e,{id:"terrain"}),this.terrainPickingPass=new ye(e,{id:"terrain-picking"}),Te.isSupported(e)?this.heightMap=new Te(e):n.warn("Terrain offset mode is not supported by this browser")(),t._addDefaultShaderModule(pe)}preRender(e){if(e.pickZ)return void(this.isDrapingEnabled=!1);const{viewports:t}=e,i=e.pass.startsWith("picking");this.isPicking=i,this.isDrapingEnabled=!0;const n=t[0],s=(i?this.terrainPickingPass:this.terrainPass).getRenderableLayers(n,e),r=s.filter((e=>e.props.operation.includes("terrain")));if(0===r.length)return;if(!i){s.filter((e=>"offset"===e.state.terrainDrawMode)).length>0&&this._updateHeightMap(r,n,e)}const o=s.filter((e=>"drape"===e.state.terrainDrawMode));this._updateTerrainCovers(r,o,n,e)}getModuleParameters(e){const{terrainDrawMode:t}=e.state;return{heightMap:this.heightMap?.getRenderFramebuffer()?.colorAttachments[0].texture||null,heightMapBounds:this.heightMap?.bounds,dummyHeightMap:this.dummyHeightMap,terrainCover:this.isDrapingEnabled?this.terrainCovers.get(e.id):null,useTerrainHeightMap:"offset"===t,terrainSkipRender:"drape"===t||!e.props.operation.includes("draw")}}cleanup({deck:e}){this.dummyHeightMap&&(this.dummyHeightMap.delete(),this.dummyHeightMap=void 0),this.heightMap&&(this.heightMap.delete(),this.heightMap=void 0);for(const e of this.terrainCovers.values())e.delete();this.terrainCovers.clear(),e._removeDefaultShaderModule(pe)}_updateHeightMap(e,t,i){if(!this.heightMap)return;this.heightMap.shouldUpdate({layers:e,viewport:t})&&this.terrainPass.renderHeightMap(this.heightMap,{...i,layers:e,moduleParameters:{heightMapBounds:this.heightMap.bounds,dummyHeightMap:this.dummyHeightMap,devicePixelRatio:1,drawToTerrainHeightMap:!0}})}_updateTerrainCovers(e,t,i,n){const s={};for(const e of t)e.state.terrainCoverNeedsRedraw&&(s[e.id]=!0,e.state.terrainCoverNeedsRedraw=!1);for(const e of this.terrainCovers.values())e.isDirty=e.isDirty||e.shouldUpdate({layerNeedsRedraw:s});for(const s of e)this._updateTerrainCover(s,t,i,n);this.isPicking||this._pruneTerrainCovers()}_updateTerrainCover(e,t,i,n){const s=this.isPicking?this.terrainPickingPass:this.terrainPass;let r=this.terrainCovers.get(e.id);r||(r=new me(e),this.terrainCovers.set(e.id,r));try{const o=r.shouldUpdate({targetLayer:e,viewport:i,layers:t});(this.isPicking||r.isDirty||o)&&(s.renderTerrainCover(r,{...n,layers:t,moduleParameters:{dummyHeightMap:this.dummyHeightMap,terrainSkipRender:!1,devicePixelRatio:1}}),this.isPicking||(r.isDirty=!1))}catch(t){e.raiseError(t,`Error rendering terrain cover ${r.id}`)}}_pruneTerrainCovers(){const e=[];for(const[t,i]of this.terrainCovers)i.isActive||e.push(t);for(const t of e)this.terrainCovers.delete(t)}}const Pe={terrainDrawMode:void 0};class xe extends t{static{this.defaultProps=Pe}static{this.extensionName="TerrainExtension"}getShaders(){return{modules:[pe]}}initializeState(){this.context.deck?._addDefaultEffect(new be)}updateState(e){const{props:t,oldProps:i}=e;if(this.state.terrainDrawMode&&t.terrainDrawMode===i.terrainDrawMode&&t.extruded===i.extruded)return;let{terrainDrawMode:n}=t;if(!n){const e=this.props.extruded,t=this.getAttributeManager()?.attributes;n=e||t&&"instancePositions"in t?"offset":"drape"}this.setState({terrainDrawMode:n})}onNeedsRedraw(){const e=this.state;"drape"===e.terrainDrawMode&&(e.terrainCoverNeedsRedraw=!0)}}export{y as BrushingExtension,q as ClipExtension,te as CollisionFilterExtension,k as DataFilterExtension,U as FillStyleExtension,D as Fp64Extension,de as MaskExtension,z as PathStyleExtension,xe as _TerrainExtension,O as project64};export default null;
