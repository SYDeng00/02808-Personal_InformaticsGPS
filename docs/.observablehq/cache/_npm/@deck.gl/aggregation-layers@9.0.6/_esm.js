/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@deck.gl/aggregation-layers@9.0.6/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{_mergeShaders as e,project32 as t,getShaderAssembler as i,Layer as n,picking as o,log as r,CompositeLayer as a,_compareProps as s,AttributeManager as l,COORDINATE_SYSTEM as g,createIterable as u,gouraudLighting as c,fp64LowPart as d}from"../core@9.0.6/_esm.js";import{Model as h,TextureTransform as p,Geometry as m,CubeGeometry as f}from"../../@luma.gl/engine@9.0.9/_esm.js";import{fp64arithmetic as x}from"../../@luma.gl/shadertools@9.0.9/_esm.js";import"../../@luma.gl/constants@9.0.9/_esm.js";import{GridCellLayer as v,ColumnLayer as S,LineLayer as y,SolidPolygonLayer as b}from"../layers@9.0.6/_esm.js";import{hexbin as C}from"../../d3-hexbin@0.2.2/_esm.js";const M={SUM:1,MEAN:2,MIN:3,MAX:4};function A(e,t){return e+t}function D(e,t){return t>e?t:e}function w(e,t){return t<e?t:e}function P(e,t,i){const n=M[e]||M.SUM;switch(t=function(e,t={}){if(Number.isFinite(e))return e;return i=>(t.index=i.index,e(i.source,t))}(t,i),n){case M.MIN:return e=>function(e,t){if(Number.isFinite(t))return e.length?t:null;const i=e.map(t).filter(Number.isFinite);return i.length?i.reduce(w,1/0):null}(e,t);case M.SUM:return e=>function(e,t){if(Number.isFinite(t))return e.length?e.length*t:null;const i=e.map(t).filter(Number.isFinite);return i.length?i.reduce(A,0):null}(e,t);case M.MEAN:return e=>function(e,t){if(Number.isFinite(t))return e.length?t:null;const i=e.map(t).filter(Number.isFinite);return i.length?i.reduce(A,0)/i.length:null}(e,t);case M.MAX:return e=>function(e,t){if(Number.isFinite(t))return e.length?t:null;const i=e.map(t).filter(Number.isFinite);return i.length?i.reduce(D,-1/0):null}(e,t);default:return null}}function T(e,t={}){return i=>(t.indices=i.map((e=>e.index)),e(i.map((e=>e.source)),t))}const _={projectPoints:!1,viewport:null,createBufferObjects:!0,moduleSettings:{}},z=3402823466e29,E=[32775,32774],B=[32776,32774],N=[32776,32775],W={[M.SUM]:32774,[M.MEAN]:32774,[M.MIN]:E,[M.MAX]:B},O={size:1,operation:M.SUM,needMin:!1,needMax:!1,combineMaxMin:!1};var F="#version 300 es\n#define SHADER_NAME gpu-aggregation-to-grid-vs\nin vec3 positions;\nin vec3 positions64Low;\nin vec3 weights;\nuniform vec2 cellSize;\nuniform vec2 gridSize;\nuniform bool projectPoints;\nuniform vec2 translation;\nuniform vec3 scaling;\nout vec3 vWeights;\nvec2 project_to_pixel(vec4 pos) {\nvec4 result;\npos.xy = pos.xy/pos.w;\nresult = pos + vec4(translation, 0., 0.);\nresult.xy = scaling.z > 0. ? result.xy * scaling.xy : result.xy;\nreturn result.xy;\n}\nvoid main(void) {\nvWeights = weights;\nvec4 windowPos = vec4(positions, 1.);\nif (projectPoints) {\nwindowPos = project_position_to_clipspace(positions, positions64Low, vec3(0));\n}\nvec2 pos = project_to_pixel(windowPos);\nvec2 pixelXY64[2];\npixelXY64[0] = vec2(pos.x, 0.);\npixelXY64[1] = vec2(pos.y, 0.);\nvec2 gridXY64[2];\ngridXY64[0] = div_fp64(pixelXY64[0], vec2(cellSize.x, 0));\ngridXY64[1] = div_fp64(pixelXY64[1], vec2(cellSize.y, 0));\nfloat x = floor(gridXY64[0].x);\nfloat y = floor(gridXY64[1].x);\npos = vec2(x, y);\npos = (pos * (2., 2.) / (gridSize)) - (1., 1.);\nvec2 offset = 1.0 / gridSize;\npos = pos + offset;\ngl_Position = vec4(pos, 0.0, 1.0);\ngl_PointSize = 1.0;\n}\n",I="#version 300 es\n#define SHADER_NAME gpu-aggregation-to-grid-fs\nprecision highp float;\nin vec3 vWeights;\nout vec4 fragColor;\nvoid main(void) {\nfragColor = vec4(vWeights, 1.0);\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",R="#version 300 es\n#define SHADER_NAME gpu-aggregation-all-vs-64\nin vec2 position;\nuniform ivec2 gridSize;\nout vec2 vTextureCoord;\nvoid main(void) {\nvec2 pos = vec2(-1.0, -1.0);\nvec2 offset = 1.0 / vec2(gridSize);\npos = pos + offset;\ngl_Position = vec4(pos, 0.0, 1.0);\nint yIndex = gl_InstanceID / gridSize[0];\nint xIndex = gl_InstanceID - (yIndex * gridSize[0]);\nvec2 yIndexFP64 = vec2(float(yIndex), 0.);\nvec2 xIndexFP64 = vec2(float(xIndex), 0.);\nvec2 gridSizeYFP64 = vec2(gridSize[1], 0.);\nvec2 gridSizeXFP64 = vec2(gridSize[0], 0.);\nvec2 texCoordXFP64 = div_fp64(yIndexFP64, gridSizeYFP64);\nvec2 texCoordYFP64 = div_fp64(xIndexFP64, gridSizeXFP64);\nvTextureCoord = vec2(texCoordYFP64.x, texCoordXFP64.x);\ngl_PointSize = 1.0;\n}\n",U="#version 300 es\n#define SHADER_NAME gpu-aggregation-all-fs\nprecision highp float;\nin vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform bool combineMaxMin;\nout vec4 fragColor;\nvoid main(void) {\nvec4 textureColor = texture(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\nif (textureColor.a == 0.) {\ndiscard;\n}\nfragColor.rgb = textureColor.rgb;\nfragColor.a = combineMaxMin ? textureColor.r : textureColor.a;\n}\n",L="#version 300 es\n#define SHADER_NAME gpu-aggregation-transform-mean-vs\nin vec4 aggregationValues;\nout vec4 meanValues;\nvoid main()\n{\nbool isCellValid = bool(aggregationValues.w > 0.);\nmeanValues.xyz = isCellValid ? aggregationValues.xyz/aggregationValues.w : vec3(0, 0, 0);\nmeanValues.w = aggregationValues.w;\ngl_PointSize = 1.0;\n}\n";const V={minFilter:"nearest",magFilter:"nearest"};function G(e,t){const{width:i=1,height:n=1,data:o=null,parameters:r=V}=t;return e.createTexture({data:o,format:"rgba32float",mipmaps:!1,sampler:r,width:i,height:n})}function j(e,t){const{id:i,width:n=1,height:o=1,texture:r}=t;return e.createFramebuffer({id:i,width:n,height:o,colorAttachments:[r]})}const k=["aggregationBuffer","maxMinBuffer","minBuffer","maxBuffer"],H={maxData:"maxBuffer",minData:"minBuffer",maxMinData:"maxMinBuffer"},$=["float32-renderable-webgl","texture-blend-float-webgl"];class X{static getAggregationData({aggregationData:e,maxData:t,minData:i,maxMinData:n,pixelIndex:o}){const r=4*o,a={};return e&&(a.cellCount=e[r+3],a.cellWeight=e[r]),n?(a.maxCellWieght=n[0],a.minCellWeight=n[3]):(t&&(a.maxCellWieght=t[0],a.totalCount=t[3]),i&&(a.minCellWeight=i[0],a.totalCount=i[3])),a}static getCellData({countsData:e,size:t=1}){const i=e.length/4,n=new Float32Array(i*t),o=new Uint32Array(i);for(let r=0;r<i;r++){for(let i=0;i<t;i++)n[r*t+i]=e[4*r+i];o[r]=e[4*r+3]}return{cellCounts:o,cellWeights:n}}static isSupported(e){return $.every((t=>e.features.has(t)))}constructor(e,t={}){this.state={weightAttributes:{},textures:{},meanTextures:{},buffers:{},framebuffers:{},maxMinFramebuffers:{},minFramebuffers:{},maxFramebuffers:{},equations:{},shaderOptions:{},modelDirty:!1,resources:{},results:{}},this.id=t.id||"gpu-grid-aggregator",this.device=e;this._hasGPUSupport=["float32-renderable-webgl"].every((t=>e.features.has(t))),this._hasGPUSupport&&this._setupModels()}delete(){const{gridAggregationModel:e,allAggregationModel:t,meanTransform:i}=this,{textures:n,framebuffers:o,maxMinFramebuffers:r,minFramebuffers:a,maxFramebuffers:s,meanTextures:l,resources:g}=this.state;e?.destroy(),t?.destroy(),i?.destroy(),function(e){e=Array.isArray(e)?e:[e],e.forEach((e=>{for(const t in e)e[t].delete()}))}([o,n,r,a,s,l,g])}run(e={}){this.setState({results:{}});const t=this._normalizeAggregationParams(e);return this._runAggregation(t)}getData(e){const t={},i=this.state.results;i[e].aggregationData||(i[e].aggregationData=i[e].aggregationBuffer.getData()),t.aggregationData=i[e].aggregationData;for(const n in H){const o=H[n];(i[e][n]||i[e][o])&&(i[e][n]=i[e][n]||i[e][o].getData(),t[n]=i[e][n])}return t}updateShaders(e={}){this.setState({shaderOptions:e,modelDirty:!0})}_normalizeAggregationParams(e){const t={..._,...e},{weights:i}=t;return i&&(t.weights=function(e){const t={};for(const i in e)t[i]={...O,...e[i]};return t}(i)),t}setState(e){Object.assign(this.state,e)}_getAggregateData(e){const t={},{textures:i,framebuffers:n,maxMinFramebuffers:o,minFramebuffers:r,maxFramebuffers:a,resources:s}=this.state,{weights:l}=e;for(const e in l){t[e]={};const{needMin:g,needMax:u,combineMaxMin:c}=l[e];t[e].aggregationTexture=i[e],t[e].aggregationBuffer=this.device.readPixelsToBufferWebGL(n[e],{target:l[e].aggregationBuffer,sourceType:5126}),g&&u&&c?(t[e].maxMinBuffer=this.device.readPixelsToBufferWebGL(o[e],{target:l[e].maxMinBuffer,sourceType:5126}),t[e].maxMinTexture=s[`${e}-maxMinTexture`]):(g&&(t[e].minBuffer=this.device.readPixelsToBufferWebGL(r[e],{target:l[e].minBuffer,sourceType:5126}),t[e].minTexture=s[`${e}-minTexture`]),u&&(t[e].maxBuffer=this.device.readPixelsToBufferWebGL(a[e],{target:l[e].maxBuffer,sourceType:5126}),t[e].maxTexture=s[`${e}-maxTexture`]))}return this._trackGPUResultBuffers(t,l),t}_renderAggregateData(e){const{cellSize:t,projectPoints:i,attributes:n,moduleSettings:o,numCol:r,numRow:a,weights:s,translation:l,scaling:g}=e,{maxMinFramebuffers:u,minFramebuffers:c,maxFramebuffers:d}=this.state,h=[r,a],p={blend:!0,depthTest:!1,blendFunc:[1,1]},m={cellSize:t,gridSize:h,projectPoints:i,translation:l,scaling:g};for(const e in s){const{needMin:t,needMax:i}=s[e],r=t&&i&&s[e].combineMaxMin;this._renderToWeightsTexture({id:e,parameters:p,moduleSettings:o,uniforms:m,gridSize:h,attributes:n,weights:s}),r?this._renderToMaxMinTexture({id:e,parameters:{...p,blendEquation:N},gridSize:h,minOrMaxFb:u[e],clearParams:{clearColor:[0,0,0,z]},combineMaxMin:r}):(t&&this._renderToMaxMinTexture({id:e,parameters:{...p,blendEquation:E},gridSize:h,minOrMaxFb:c[e],clearParams:{clearColor:[z,z,z,0]},combineMaxMin:r}),i&&this._renderToMaxMinTexture({id:e,parameters:{...p,blendEquation:B},gridSize:h,minOrMaxFb:d[e],clearParams:{clearColor:[0,0,0,0]},combineMaxMin:r}))}}_renderToMaxMinTexture(e){const{id:t,gridSize:i,minOrMaxFb:n,combineMaxMin:o,clearParams:r={}}=e,{framebuffers:a}=this.state,{allAggregationModel:s}=this;this.device.withParametersWebGL({...r,framebuffer:n,viewport:[0,0,i[0],i[1]]},(()=>{this.device.clearWebGL({color:!0}),s.setUniforms({gridSize:i,combineMaxMin:o}),s.setBindings({uSampler:a[t].texture}),s.draw()}))}_renderToWeightsTexture(e){const{id:t,parameters:i,moduleSettings:n,uniforms:o,gridSize:r,weights:a}=e,{framebuffers:s,equations:l,weightAttributes:g}=this.state,{gridAggregationModel:u}=this,{operation:c}=a[t],d=c===M.MIN?[z,z,z,0]:[0,0,0,0];if(this.device.withParametersWebGL({framebuffer:s[t],viewport:[0,0,r[0],r[1]],clearColor:d},(()=>{this.device.clearWebGL({color:!0});const e={weights:g[t]};u.draw({parameters:{...i,blendEquation:l[t]},moduleSettings:n,uniforms:o,attributes:e})})),c===M.MEAN){const{meanTextures:e,textures:i}=this.state,n={_sourceTextures:{aggregationValues:e[t]},_targetTexture:i[t],elementCount:i[t].width*i[t].height};this.meanTransform?this.meanTransform.update(n):this.meanTransform=function(e,t){return new p(e,{vs:L,_targetTextureVarying:"meanValues",...t})}(this.device,n),this.meanTransform.run({parameters:{blend:!1,depthTest:!1}}),s[t].attach({36064:i[t]})}}_runAggregation(e){this._updateModels(e),this._setupFramebuffers(e),this._renderAggregateData(e);const t=this._getAggregateData(e);return this.setState({results:t}),t}_setupFramebuffers(e){const{textures:t,framebuffers:i,maxMinFramebuffers:n,minFramebuffers:o,maxFramebuffers:r,meanTextures:a,equations:s}=this.state,{weights:l}=e,{numCol:g,numRow:u}=e,c={width:g,height:u};for(const e in l){const{needMin:d,needMax:h,combineMaxMin:p,operation:m}=l[e];t[e]=l[e].aggregationTexture||t[e]||G(this.device,{id:`${e}-texture`,width:g,height:u}),t[e].resize(c);let f=t[e];m===M.MEAN&&(a[e]=a[e]||G(this.device,{id:`${e}-mean-texture`,width:g,height:u}),a[e].resize(c),f=a[e]),i[e]?i[e].attach({36064:f}):i[e]=j(this.device,{id:`${e}-fb`,width:g,height:u,texture:f}),i[e].resize(c),s[e]=W[m]||W[M.SUM],(d||h)&&(d&&h&&p?n[e]||(f=l[e].maxMinTexture||this._getMinMaxTexture(`${e}-maxMinTexture`),n[e]=j(this.device,{id:`${e}-maxMinFb`,texture:f})):(d&&(o[e]||(f=l[e].minTexture||this._getMinMaxTexture(`${e}-minTexture`),o[e]=j(this.device,{id:`${e}-minFb`,texture:f}))),h&&(r[e]||(f=l[e].maxTexture||this._getMinMaxTexture(`${e}-maxTexture`),r[e]=j(this.device,{id:`${e}-maxFb`,texture:f})))))}}_getMinMaxTexture(e){const{resources:t}=this.state;return t[e]||(t[e]=G(this.device,{id:"resourceName"})),t[e]}_setupModels({numCol:n=0,numRow:o=0}={}){const{shaderOptions:r}=this.state;if(this.gridAggregationModel?.destroy(),this.gridAggregationModel=function(n,o){const r=e({vs:F,fs:I,modules:[x,t]},o);return new h(n,{id:"Grid-Aggregation-Model",vertexCount:1,drawMode:0,shaderAssembler:i(),...r})}(this.device,r),!this.allAggregationModel){const e=n*o;this.allAggregationModel=function(e,t){return new h(e,{id:"All-Aggregation-Model",vs:R,fs:U,modules:[x],vertexCount:1,topology:"point-list",isInstanced:!0,instanceCount:t,attributes:{position:[0,0]}})}(this.device,e)}}_setupWeightAttributes(e){const{weightAttributes:t}=this.state,{weights:i}=e;for(const n in i)t[n]=e.attributes[n]}_trackGPUResultBuffers(e,t){const{resources:i}=this.state;for(const n in e)if(e[n])for(const o of k)if(e[n][o]&&t[n][o]!==e[n][o]){const t=`gpu-result-${n}-${o}`;i[t]&&i[t].delete(),i[t]=e[n][o]}}_updateModels(e){const{vertexCount:t,attributes:i,numCol:n,numRow:o}=e,{modelDirty:r}=this.state;r&&(this._setupModels(e),this.setState({modelDirty:!1})),this._setupWeightAttributes(e),this.gridAggregationModel.setVertexCount(t),this.gridAggregationModel.setAttributes(i),this.allAggregationModel.setInstanceCount(n*o)}}const q=[[255,255,178],[254,217,118],[254,178,76],[253,141,60],[240,59,32],[189,0,38]];function Y(e,t=!1,i=Float32Array){let n;if(Number.isFinite(e[0]))n=new i(e);else{n=new i(4*e.length);let t=0;for(let i=0;i<e.length;i++){const o=e[i];n[t++]=o[0],n[t++]=o[1],n[t++]=o[2],n[t++]=Number.isFinite(o[3])?o[3]:255}}if(t)for(let e=0;e<n.length;e++)n[e]/=255;return n}const K=[0,0,0,0],Z=[0,255,0,255],J=["minColor","maxColor","colorRange","colorDomain"],Q={cellSizePixels:{type:"number",value:100,min:1},cellMarginPixels:{type:"number",value:2,min:0,max:5},colorDomain:null,colorRange:q};class ee extends n{static{this.layerName="ScreenGridCellLayer"}static{this.defaultProps=Q}getShaders(){return{vs:"#version 300 es\n#define SHADER_NAME screen-grid-layer-vertex-shader\n#define RANGE_COUNT 6\nin vec3 positions;\nin vec3 instancePositions;\nin vec4 instanceCounts;\nin vec3 instancePickingColors;\nuniform float opacity;\nuniform vec3 cellScale;\nuniform vec4 minColor;\nuniform vec4 maxColor;\nuniform vec4 colorRange[RANGE_COUNT];\nuniform vec2 colorDomain;\nuniform bool shouldUseMinMax;\nuniform sampler2D maxTexture;\nout vec4 vColor;\nout float vSampleCount;\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\nvec4 outColor = vec4(0., 0., 0., 0.);\nif (value >= domain.x && value <= domain.y) {\nfloat domainRange = domain.y - domain.x;\nif (domainRange <= 0.) {\noutColor = colorRange[0];\n} else {\nfloat rangeCount = float(RANGE_COUNT);\nfloat rangeStep = domainRange / rangeCount;\nfloat idx = floor((value - domain.x) / rangeStep);\nidx = clamp(idx, 0., rangeCount - 1.);\nint intIdx = int(idx);\noutColor = colorRange[intIdx];\n}\n}\noutColor = outColor / 255.;\nreturn outColor;\n}\nvoid main(void) {\nvSampleCount = instanceCounts.a;\nfloat weight = instanceCounts.r;\nfloat maxWeight = texture(maxTexture, vec2(0.5)).r;\nfloat step = weight / maxWeight;\nvec4 minMaxColor = mix(minColor, maxColor, step) / 255.;\nvec2 domain = colorDomain;\nfloat domainMaxValid = float(colorDomain.y != 0.);\ndomain.y = mix(maxWeight, colorDomain.y, domainMaxValid);\nvec4 rangeColor = quantizeScale(domain, colorRange, weight);\nfloat rangeMinMax = float(shouldUseMinMax);\nvec4 color = mix(rangeColor, minMaxColor, rangeMinMax);\nvColor = vec4(color.rgb, color.a * opacity);\npicking_setPickingColor(instancePickingColors);\ngl_Position = vec4(instancePositions + positions * cellScale, 1.);\n}\n",fs:"#version 300 es\n#define SHADER_NAME screen-grid-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nin float vSampleCount;\nout vec4 fragColor;\nvoid main(void) {\nif (vSampleCount <= 0.0) {\ndiscard;\n}\nfragColor = vColor;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[o]}}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,update:this.calculateInstancePositions},instanceCounts:{size:4,noAlloc:!0}}),this.setState({model:this._getModel()})}shouldUpdateState({changeFlags:e}){return e.somethingChanged}updateState(e){super.updateState(e);const{oldProps:t,props:i,changeFlags:n}=e,o=this.getAttributeManager();i.numInstances!==t.numInstances?o.invalidateAll():t.cellSizePixels!==i.cellSizePixels&&o.invalidate("instancePositions"),this._updateUniforms(t,i,n)}draw({uniforms:e}){const{parameters:t,maxTexture:i}=this.props,n=this.props.minColor||K,o=this.props.maxColor||Z,r=this.props.colorDomain||[1,0],a=this.state.model;a.setUniforms(e),a.setBindings({maxTexture:i}),a.setUniforms({minColor:n,maxColor:o,colorDomain:r}),a.setParameters({depthWriteEnabled:!1,...t}),a.draw(this.context.renderPass)}calculateInstancePositions(e,{numInstances:t}){const{width:i,height:n}=this.context.viewport,{cellSizePixels:o}=this.props,r=Math.ceil(i/o),{value:a,size:s}=e;for(let e=0;e<t;e++){const t=e%r,l=Math.floor(e/r);a[e*s+0]=t*o/i*2-1,a[e*s+1]=1-l*o/n*2,a[e*s+2]=0}}_getModel(){return new h(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new m({topology:"triangle-list",attributes:{positions:new Float32Array([0,0,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,0])}})})}_shouldUseMinMax(){const{minColor:e,maxColor:t,colorDomain:i,colorRange:n}=this.props;return e||t?(r.deprecated("ScreenGridLayer props: minColor and maxColor","colorRange, colorDomain")(),!0):!i&&!n}_updateUniforms(e,t,i){const n=this.state.model;if(J.some((i=>e[i]!==t[i]))&&n.setUniforms({shouldUseMinMax:this._shouldUseMinMax()}),e.colorRange!==t.colorRange&&n.setUniforms({colorRange:Y(t.colorRange)}),e.cellMarginPixels!==t.cellMarginPixels||e.cellSizePixels!==t.cellSizePixels||i.viewportChanged){const{width:e,height:t}=this.context.viewport,{cellSizePixels:i,cellMarginPixels:o}=this.props,r=i>o?o:0,a=new Float32Array([(i-r)/e*2,-(i-r)/t*2,1]);n.setUniforms({cellScale:a})}}}function te(e,t){const i={};for(const n in e)t.includes(n)||(i[n]=e[n]);return i}class ie extends a{static{this.layerName="AggregationLayer"}initializeAggregationLayer(e){super.initializeState(this.context),this.setState({ignoreProps:te(this.constructor._propTypes,e.data.props),dimensions:e})}updateState(e){super.updateState(e);const{changeFlags:t}=e;if(t.extensionsChanged){const e=this.getShaders({});e&&e.defines&&(e.defines.NON_INSTANCED_MODEL=1),this.updateShaders(e)}this._updateAttributes()}updateAttributes(e){this.setState({changedAttributes:e})}getAttributes(){return this.getAttributeManager().getAttributes()}getModuleSettings(){const{viewport:e,mousePosition:t,device:i}=this.context;return Object.assign(Object.create(this.props),{viewport:e,mousePosition:t,picking:{isActive:0},devicePixelRatio:i.canvasContext.cssToDeviceRatio()})}updateShaders(e){}isAggregationDirty(e,t={}){const{props:i,oldProps:n,changeFlags:o}=e,{compareAll:r=!1,dimension:a}=t,{ignoreProps:l}=this.state,{props:g,accessors:u=[]}=a,{updateTriggersChanged:c}=o;if(o.dataChanged)return!0;if(c){if(c.all)return!0;for(const e of u)if(c[e])return!0}if(r)return!!o.extensionsChanged||s({oldProps:n,newProps:i,ignoreProps:l,propTypes:this.constructor._propTypes});for(const e of g)if(i[e]!==n[e])return!0;return!1}isAttributeChanged(e){const{changedAttributes:t}=this.state;return e?t&&void 0!==t[e]:!function(e){let t=!0;for(const i in e){t=!1;break}return t}(t)}_getAttributeManager(){return new l(this.context.device,{id:this.props.id,stats:this.context.stats})}}function ne(e,t,i){const n=i;return n.domain=()=>e,n.range=()=>t,n}function oe(e,t){return ne(e,t,(i=>function(e,t,i){const n=e[1]-e[0];if(n<=0)return r.warn("quantizeScale: invalid domain, returning range[0]")(),t[0];const o=n/t.length,a=Math.floor((i-e[0])/o),s=Math.max(Math.min(a,t.length-1),0);return t[s]}(e,t,i)))}function re(e,t){return ne(e,t,(i=>function(e,t,i){return(i-e[0])/(e[1]-e[0])*(t[1]-t[0])+t[0]}(e,t,i)))}function ae(e,t){const i=e.sort(se);let n=0;const o=Math.max(1,t.length),r=new Array(o-1);for(;++n<o;)r[n-1]=le(i,n/o);const a=e=>function(e,t,i){return t[function(e,t){let i=0,n=e.length;for(;i<n;){const o=i+n>>>1;se(e[o],t)>0?n=o:i=o+1}return i}(e,i)]}(r,t,e);return a.thresholds=()=>r,ne(e,t,a)}function se(e,t){return e-t}function le(e,t){const i=e.length;if(t<=0||i<2)return e[0];if(t>=1)return e[i-1];const n=(i-1)*t,o=Math.floor(n),r=e[o];return r+(e[o+1]-r)*(n-o)}function ge(e,t){const i=new Map,n=[];for(const t of e){const e=`${t}`;i.has(e)||i.set(e,n.push(t))}return ne(e,t,(e=>function(e,t,i,n){const o=`${n}`;let r=t.get(o);return void 0===r&&(r=e.push(n),t.set(o,r)),i[(r-1)%i.length]}(n,i,t,e)))}function ue(e){return null!=e}function ce(e,t){return("function"==typeof t?e.map(t):e).filter(ue)}function de(e,t){return function(e){const t=[];return e.forEach((e=>{!t.includes(e)&&ue(e)&&t.push(e)})),t}(ce(e,t))}const he=e=>e.length,pe=e=>e.points,me=e=>e.index,fe=(e,t)=>e<t?-1:e>t?1:e>=t?0:NaN,xe={getValue:he,getPoints:pe,getIndex:me,filterData:null};class ve{constructor(e=[],t=xe){this.aggregatedBins=this.getAggregatedBins(e,t),this._updateMinMaxValues(),this.binMap=this.getBinMap()}getAggregatedBins(e,t){const{getValue:i=he,getPoints:n=pe,getIndex:o=me,filterData:r}=t,a="function"==typeof r,s=e.length,l=[];let g=0;for(let t=0;t<s;t++){const s=e[t],u=n(s),c=o(s),d=a?u.filter(r):u;s.filteredPoints=a?d:null;const h=d.length?i(d):null;null!=h&&(l[g]={i:Number.isFinite(c)?c:t,value:h,counts:d.length},g++)}return l}_percentileToIndex(e){const t=this.sortedBins.length;if(t<2)return[0,0];const[i,n]=e.map((e=>{return t=e,i=0,n=100,Math.max(i,Math.min(n,t));var t,i,n}));return[Math.ceil(i/100*(t-1)),Math.floor(n/100*(t-1))]}getBinMap(){const e={};for(const t of this.aggregatedBins)e[t.i]=t;return e}_updateMinMaxValues(){let e=0,t=0,i=3402823466e29,n=0;for(const o of this.aggregatedBins)e=e>o.counts?e:o.counts,t=t>o.value?t:o.value,i=i<o.value?i:o.value,n+=o.counts;this.maxCount=e,this.maxValue=t,this.minValue=i,this.totalCount=n}getValueRange(e){if(this.sortedBins||(this.sortedBins=this.aggregatedBins.sort(((e,t)=>fe(e.value,t.value)))),!this.sortedBins.length)return[];let t=0,i=this.sortedBins.length-1;if(Array.isArray(e)){const n=this._percentileToIndex(e);t=n[0],i=n[1]}return[this.sortedBins[t].value,this.sortedBins[i].value]}getValueDomainByScale(e,[t=0,i=100]=[]){if(this.sortedBins||(this.sortedBins=this.aggregatedBins.sort(((e,t)=>fe(e.value,t.value)))),!this.sortedBins.length)return[];const n=this._percentileToIndex([t,i]);return this._getScaleDomain(e,n)}_getScaleDomain(e,[t,i]){const n=this.sortedBins;switch(e){case"quantize":case"linear":default:return[n[t].value,n[i].value];case"quantile":return ce(n.slice(t,i+1),(e=>e.value));case"ordinal":return de(n,(e=>e.value))}}}const Se=6378e3;function ye(e){return Number.isFinite(e)?e:0}function be(e,t){const i=e.positions.value;let n,o,r=1/0,a=-1/0,s=1/0,l=-1/0;for(let e=0;e<t;e++)o=i[3*e],n=i[3*e+1],r=n<r?n:r,a=n>a?n:a,s=o<s?o:s,l=o>l?o:l;return{xMin:ye(s),xMax:ye(l),yMin:ye(r),yMax:ye(a)}}function Ce(e,t){const i=e<0?-1:1;let n=i<0?Math.abs(e)+t:Math.abs(e);return n=Math.floor(n/t)*t,n*i}function Me(e,t,i=!0){if(!i)return{xOffset:t,yOffset:t};const{yMin:n,yMax:o}=e;return function(e,t){const i=(a=e,a/Se*(180/Math.PI)),n=(o=t,r=e,r/Se*(180/Math.PI)/Math.cos(o*Math.PI/180));var o,r;var a;return{yOffset:i,xOffset:n}}(t,(n+o)/2)}function Ae(e,t,i,n){const o=Me(e,t,n!==g.CARTESIAN),a=function(e,t,i,n){const{width:o,height:a}=n,s=i===g.CARTESIAN?[-o/2,-a/2]:[-180,-90];r.assert(i===g.CARTESIAN||i===g.LNGLAT||i===g.DEFAULT);const{xMin:l,yMin:u}=e;return[-1*(Ce(l-s[0],t.xOffset)+s[0]),-1*(Ce(u-s[1],t.yOffset)+s[1])]}(e,o,n,i),{xMin:s,yMin:l,xMax:u,yMax:c}=e,d=u-s+o.xOffset,h=c-l+o.yOffset;return{gridOffset:o,translation:a,width:d,height:h,numCol:Math.ceil(d/o.xOffset),numRow:Math.ceil(h/o.yOffset)}}function De(e,t){const i=function(e,t){const{data:i=[],cellSize:n}=e,{attributes:o,viewport:r,projectPoints:a,numInstances:s}=t,l=o.positions.value,{size:g}=o.positions.getAccessor(),c=t.boundingBox||function(e,t){const i=e.value,{size:n}=e.getAccessor();let o,r,a=1/0,s=-1/0,l=1/0,g=-1/0;for(let e=0;e<t;e++)r=i[e*n],o=i[e*n+1],Number.isFinite(r)&&Number.isFinite(o)&&(a=o<a?o:a,s=o>s?o:s,l=r<l?r:l,g=r>g?r:g);return{xMin:l,xMax:g,yMin:a,yMax:s}}(o.positions,s),d=t.posOffset||[180,90],h=t.gridOffset||Me(c,n);if(h.xOffset<=0||h.yOffset<=0)return{gridHash:{},gridOffset:h,offsets:[0,0]};const{width:p,height:m}=r,f=Math.ceil(p/h.xOffset),x=Math.ceil(m/h.yOffset),v={},{iterable:S,objectInfo:y}=u(i),b=new Array(3);for(const e of S){y.index++,b[0]=l[y.index*g],b[1]=l[y.index*g+1],b[2]=g>=3?l[y.index*g+2]:0;const[t,i]=a?r.project(b):b;if(Number.isFinite(t)&&Number.isFinite(i)){const n=Math.floor((i+d[1])/h.yOffset),o=Math.floor((t+d[0])/h.xOffset);if(!a||o>=0&&o<f&&n>=0&&n<x){const t=`${n}-${o}`;v[t]=v[t]||{count:0,points:[],lonIdx:o,latIdx:n},v[t].count+=1,v[t].points.push({source:e,index:y.index})}}}return{gridHash:v,gridOffset:h,offsets:[-1*d[0],-1*d[1]]}}(e,t),n=function({gridHash:e,gridOffset:t,offsets:i}){const n=new Array(Object.keys(e).length);let o=0;for(const r in e){const a=r.split("-"),s=parseInt(a[0],10),l=parseInt(a[1],10),g=o++;n[g]={index:g,position:[i[0]+t.xOffset*l,i[1]+t.yOffset*s],...e[r]}}return n}(i);return{gridHash:i.gridHash,gridOffset:i.gridOffset,data:n}}class we extends ie{static{this.layerName="GridAggregationLayer"}initializeAggregationLayer({dimensions:e}){super.initializeAggregationLayer(e),this.setState({layerData:{},gpuGridAggregator:new X(this.context.device,{id:`${this.id}-gpu-aggregator`}),cpuGridAggregator:De})}updateState(e){super.updateState(e),this.updateAggregationState(e);const{aggregationDataDirty:t,aggregationWeightsDirty:i,gpuAggregation:n}=this.state;if(this.getNumInstances()<=0)return;let o=!1;(t||n&&i)&&(this._updateAggregation(e),o=!0),n||!t&&!i||(this._updateWeightBins(),this._uploadAggregationResults(),o=!0),this.setState({aggregationDirty:o})}finalizeState(e){const{count:t}=this.state.weights;t&&t.aggregationBuffer&&t.aggregationBuffer.delete(),this.state.gpuGridAggregator?.delete(),super.finalizeState(e)}updateShaders(e){this.state.gpuAggregation&&this.state.gpuGridAggregator.updateShaders(e)}updateAggregationState(e){r.assert(!1)}allocateResources(e,t){if(this.state.numRow!==e||this.state.numCol!==t){const i=t*e*4*4,{weights:n}=this.state;for(const e in n){const t=n[e];t.aggregationBuffer&&t.aggregationBuffer.delete(),t.aggregationBuffer=this.context.device.createBuffer({byteLength:i,accessor:{size:4,type:5126,divisor:1}})}}}updateResults({aggregationData:e,maxMinData:t,maxData:i,minData:n}){const{count:o}=this.state.weights;o&&(o.aggregationData=e,o.maxMinData=t,o.maxData=i,o.minData=n)}_updateAggregation(e){const{cpuGridAggregator:t,gpuGridAggregator:i,gridOffset:n,posOffset:o,translation:r=[0,0],scaling:a=[0,0,0],boundingBox:s,projectPoints:l,gpuAggregation:g,numCol:u,numRow:c}=this.state,{props:d}=e,{viewport:h}=this.context,p=this.getAttributes(),m=this.getNumInstances();if(g){const{weights:e}=this.state;i.run({weights:e,cellSize:[n.xOffset,n.yOffset],numCol:u,numRow:c,translation:r,scaling:a,vertexCount:m,projectPoints:l,attributes:p,moduleSettings:this.getModuleSettings()})}else{const e=t(d,{gridOffset:n,projectPoints:l,attributes:p,viewport:h,posOffset:o,boundingBox:s});this.setState({layerData:e})}}_updateWeightBins(){const{getValue:e}=this.state,t=new ve(this.state.layerData.data||[],{getValue:e});this.setState({sortedBins:t})}_uploadAggregationResults(){const{numCol:e,numRow:t}=this.state,{data:i}=this.state.layerData,{aggregatedBins:n,minValue:o,maxValue:r,totalCount:a}=this.state.sortedBins,s=new Float32Array(e*t*4).fill(0);for(const t of n){const{lonIdx:n,latIdx:o}=i[t.i],{value:r,counts:a}=t,l=4*(n+o*e);s[l]=r,s[l+4-1]=a}const l=new Float32Array([r,0,0,o]),g=new Float32Array([r,0,0,a]),u=new Float32Array([o,0,0,a]);this.updateResults({aggregationData:s,maxMinData:l,maxData:g,minData:u})}}const Pe={...ee.defaultProps,getPosition:{type:"accessor",value:e=>e.position},getWeight:{type:"accessor",value:1},gpuAggregation:!1,aggregation:"SUM"},Te="positions",_e={data:{props:["cellSizePixels"]},weights:{props:["aggregation"],accessors:["getWeight"]}};class ze extends we{static{this.layerName="ScreenGridLayer"}static{this.defaultProps=Pe}initializeState(){super.initializeAggregationLayer({dimensions:_e,getCellSize:e=>e.cellSizePixels});const e={count:{size:1,operation:M.SUM,needMax:!0,maxTexture:G(this.context.device,{id:`${this.id}-max-texture`})}};this.setState({supported:!0,projectPoints:!0,weights:e,subLayerData:{attributes:{}},maxTexture:e.count.maxTexture,positionAttributeName:"positions",posOffset:[0,0],translation:[1,-1]});this.getAttributeManager().add({[Te]:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},count:{size:3,accessor:"getWeight"}})}shouldUpdateState({changeFlags:e}){return this.state.supported&&e.somethingChanged}updateState(e){super.updateState(e)}renderLayers(){if(!this.state.supported)return[];const{maxTexture:e,numRow:t,numCol:i,weights:n}=this.state,{updateTriggers:o}=this.props,{aggregationBuffer:r}=n.count;return new(this.getSubLayerClass("cells",ee))(this.props,this.getSubLayerProps({id:"cell-layer",updateTriggers:o}),{data:{attributes:{instanceCounts:r}},maxTexture:e,numInstances:t*i})}finalizeState(e){super.finalizeState(e);const{aggregationBuffer:t,maxBuffer:i,maxTexture:n}=this.state;t?.delete(),i?.delete(),n?.delete()}getPickingInfo({info:e}){const{index:t}=e;if(t>=0){const{gpuGridAggregator:i,gpuAggregation:n,weights:o}=this.state,r=n?i.getData("count"):o.count;e.object=X.getAggregationData({pixelIndex:t,...r})}return e}updateResults({aggregationData:e,maxData:t}){const{count:i}=this.state.weights;i.aggregationData=e,i.aggregationBuffer.write(e),i.maxData=t,i.maxTexture.setImageData({data:t})}updateAggregationState(e){const t=e.props.cellSizePixels,i=e.oldProps.cellSizePixels!==t,{viewportChanged:n}=e.changeFlags;let o=e.props.gpuAggregation;this.state.gpuAggregation!==e.props.gpuAggregation&&o&&!X.isSupported(this.context.device)&&(r.warn("GPU Grid Aggregation not supported, falling back to CPU")(),o=!1);const a=o!==this.state.gpuAggregation;this.setState({gpuAggregation:o});const s=this.isAttributeChanged(Te),{dimensions:l}=this.state,{data:g,weights:u}=l,c=s||a||n||this.isAggregationDirty(e,{compareAll:o,dimension:g}),d=this.isAggregationDirty(e,{dimension:u});this.setState({aggregationDataDirty:c,aggregationWeightsDirty:d});const{viewport:h}=this.context;if(n||i){const{width:e,height:i}=h,n=Math.ceil(e/t),o=Math.ceil(i/t);this.allocateResources(o,n),this.setState({scaling:[e/2,-i/2,1],gridOffset:{xOffset:t,yOffset:t},width:e,height:i,numCol:n,numRow:o})}d&&this._updateAccessors(e),(c||d)&&this._resetResults()}_updateAccessors(e){const{getWeight:t,aggregation:i,data:n}=e.props,{count:o}=this.state.weights;o&&(o.getWeight=t,o.operation=M[i]),this.setState({getValue:P(i,t,{data:n})})}_resetResults(){const{count:e}=this.state.weights;e&&(e.aggregationData=null)}}function Ee(){}const Be=["getBins","getDomain","getScaleFunc"],Ne=[{key:"fillColor",accessor:"getFillColor",pickingInfo:"colorValue",getBins:{triggers:{value:{prop:"getColorValue",updateTrigger:"getColorValue"},weight:{prop:"getColorWeight",updateTrigger:"getColorWeight"},aggregation:{prop:"colorAggregation"},filterData:{prop:"_filterData",updateTrigger:"_filterData"}}},getDomain:{triggers:{lowerPercentile:{prop:"lowerPercentile"},upperPercentile:{prop:"upperPercentile"},scaleType:{prop:"colorScaleType"}}},getScaleFunc:{triggers:{domain:{prop:"colorDomain"},range:{prop:"colorRange"}},onSet:{props:"onSetColorDomain"}},nullValue:[0,0,0,0]},{key:"elevation",accessor:"getElevation",pickingInfo:"elevationValue",getBins:{triggers:{value:{prop:"getElevationValue",updateTrigger:"getElevationValue"},weight:{prop:"getElevationWeight",updateTrigger:"getElevationWeight"},aggregation:{prop:"elevationAggregation"},filterData:{prop:"_filterData",updateTrigger:"_filterData"}}},getDomain:{triggers:{lowerPercentile:{prop:"elevationLowerPercentile"},upperPercentile:{prop:"elevationUpperPercentile"},scaleType:{prop:"elevationScaleType"}}},getScaleFunc:{triggers:{domain:{prop:"elevationDomain"},range:{prop:"elevationRange"}},onSet:{props:"onSetElevationDomain"}},nullValue:-1}],We=e=>e.cellSize;class Oe{constructor(e){this.state={layerData:{data:void 0},dimensions:{}},this.changeFlags={},this.dimensionUpdaters={},this._getCellSize=e.getCellSize||We,this._getAggregator=e.getAggregator,this._addDimension(e.dimensions||Ne)}static defaultDimensions(){return Ne}updateState(e,t){const{oldProps:i,props:n,changeFlags:o}=e;this.updateGetValueFuncs(i,n,o);const r=this.needsReProjectPoints(i,n,o);let a=!1;if(o.dataChanged||r)this.getAggregatedData(n,t),a=!0;else{(this.getDimensionChanges(i,n,o)||[]).forEach((e=>"function"==typeof e&&e())),a=!0}return this.setState({aggregationDirty:a}),this.state}setState(e){this.state={...this.state,...e}}setDimensionState(e,t){this.setState({dimensions:{...this.state.dimensions,[e]:{...this.state.dimensions[e],...t}}})}normalizeResult(e={}){return e.hexagons?{data:e.hexagons,...e}:e.layerData?{data:e.layerData,...e}:e}getAggregatedData(e,t){const i=this._getAggregator(e)(e,t);this.setState({layerData:this.normalizeResult(i)}),this.changeFlags={layerData:!0},this.getSortedBins(e)}updateGetValueFuncs(e,t,i){for(const n in this.dimensionUpdaters){const{value:o,weight:r,aggregation:a}=this.dimensionUpdaters[n].getBins.triggers;let s=t[o.prop];this.needUpdateDimensionStep(this.dimensionUpdaters[n].getBins,e,t,i)&&(s=s?T(s,{data:t.data}):P(t[a.prop],t[r.prop],{data:t.data})),s&&this.setDimensionState(n,{getValue:s})}}needsReProjectPoints(e,t,i){return this._getCellSize(e)!==this._getCellSize(t)||this._getAggregator(e)!==this._getAggregator(t)||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPosition)}addDimension(e){this._addDimension(e)}_addDimension(e=[]){e.forEach((e=>{const{key:t}=e;this.dimensionUpdaters[t]=this.getDimensionUpdaters(e),this.state.dimensions[t]={getValue:null,domain:null,sortedBins:null,scaleFunc:Ee}}))}getDimensionUpdaters({key:e,accessor:t,pickingInfo:i,getBins:n,getDomain:o,getScaleFunc:r,nullValue:a}){return{key:e,accessor:t,pickingInfo:i,getBins:{updater:this.getDimensionSortedBins.bind(this),...n},getDomain:{updater:this.getDimensionValueDomain.bind(this),...o},getScaleFunc:{updater:this.getDimensionScale.bind(this),...r},attributeAccessor:this.getSubLayerDimensionAttribute(e,a)}}needUpdateDimensionStep(e,t,i,n){return Object.values(e.triggers).some((e=>e.updateTrigger?n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged[e.updateTrigger]):t[e.prop]!==i[e.prop]))}getDimensionChanges(e,t,i){const n=[];for(const o in this.dimensionUpdaters){const r=Be.find((n=>this.needUpdateDimensionStep(this.dimensionUpdaters[o][n],e,t,i)));r&&n.push(this.dimensionUpdaters[o][r].updater.bind(this,t,this.dimensionUpdaters[o]))}return n.length?n:null}getUpdateTriggers(e){const t=e.updateTriggers||{},i={};for(const n in this.dimensionUpdaters){const{accessor:o}=this.dimensionUpdaters[n];i[o]={},Be.forEach((r=>{Object.values(this.dimensionUpdaters[n][r].triggers).forEach((({prop:n,updateTrigger:r})=>{if(r){const e=t[r];"object"!=typeof e||Array.isArray(e)?void 0!==e&&(i[o][n]=e):Object.assign(i[o],e)}else i[o][n]=e[n]}))}))}return i}getSortedBins(e){for(const t in this.dimensionUpdaters)this.getDimensionSortedBins(e,this.dimensionUpdaters[t])}getDimensionSortedBins(e,t){const{key:i}=t,{getValue:n}=this.state.dimensions[i],o=new ve(this.state.layerData.data||[],{getValue:n,filterData:e._filterData});this.setDimensionState(i,{sortedBins:o}),this.getDimensionValueDomain(e,t)}getDimensionValueDomain(e,t){const{getDomain:i,key:n}=t,{triggers:{lowerPercentile:o,upperPercentile:r,scaleType:a}}=i,s=this.state.dimensions[n].sortedBins.getValueDomainByScale(e[a.prop],[e[o.prop],e[r.prop]]);this.setDimensionState(n,{valueDomain:s}),this.getDimensionScale(e,t)}getDimensionScale(e,t){const{key:i,getScaleFunc:n,getDomain:o}=t,{domain:r,range:a}=n.triggers,{scaleType:s}=o.triggers,{onSet:l}=n,g=e[a.prop],u=e[r.prop]||this.state.dimensions[i].valueDomain,c=function(e){switch(e){case"quantize":default:return oe;case"linear":return re;case"quantile":return ae;case"ordinal":return ge}}(s&&e[s.prop]),d=c(u,g);"object"==typeof l&&"function"==typeof e[l.props]&&e[l.props](d.domain()),this.setDimensionState(i,{scaleFunc:d})}getSubLayerDimensionAttribute(e,t){return i=>{const{sortedBins:n,scaleFunc:o}=this.state.dimensions[e],r=n.binMap[i.index];if(r&&0===r.counts)return t;const a=r&&r.value,s=o.domain();return a>=s[0]&&a<=s[s.length-1]?o(a):t}}getSubLayerAccessors(e){const t={};for(const i in this.dimensionUpdaters){const{accessor:n}=this.dimensionUpdaters[i];t[n]=this.getSubLayerDimensionAttribute(e,i)}return t}getPickingInfo({info:e}){let t=null;if(e.picked&&e.index>-1){const i=this.state.layerData.data[e.index],n={};for(const e in this.dimensionUpdaters){const{pickingInfo:t}=this.dimensionUpdaters[e],{sortedBins:o}=this.state.dimensions[e],r=o.binMap[i.index]&&o.binMap[i.index].value;n[t]=r}t=Object.assign(n,i,{points:i.filteredPoints||i.points})}return e.picked=Boolean(t),e.object=t,e}getAccessor(e){return this.dimensionUpdaters.hasOwnProperty(e)?this.dimensionUpdaters[e].attributeAccessor:Ee}}function Fe(){}const Ie={colorDomain:null,colorRange:q,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",min:0,max:100,value:0},upperPercentile:{type:"number",min:0,max:100,value:100},colorScaleType:"quantize",onSetColorDomain:Fe,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationLowerPercentile:{type:"number",min:0,max:100,value:0},elevationUpperPercentile:{type:"number",min:0,max:100,value:100},elevationScale:{type:"number",min:0,value:1},elevationScaleType:"linear",onSetElevationDomain:Fe,gridAggregator:De,cellSize:{type:"number",min:0,max:1e3,value:1e3},coverage:{type:"number",min:0,max:1,value:1},getPosition:{type:"accessor",value:e=>e.position},extruded:!1,material:!0,_filterData:{type:"function",value:null,optional:!0}};class Re extends ie{static{this.layerName="CPUGridLayer"}static{this.defaultProps=Ie}initializeState(){const e=new Oe({getAggregator:e=>e.gridAggregator,getCellSize:e=>e.cellSize});this.state={cpuAggregator:e,aggregatorState:e.state};this.getAttributeManager().add({positions:{size:3,type:"float64",accessor:"getPosition"}})}updateState(e){super.updateState(e),this.setState({aggregatorState:this.state.cpuAggregator.updateState(e,{viewport:this.context.viewport,attributes:this.getAttributes(),numInstances:this.getNumInstances()})})}getPickingInfo({info:e}){return this.state.cpuAggregator.getPickingInfo({info:e})}_onGetSublayerColor(e){return this.state.cpuAggregator.getAccessor("fillColor")(e)}_onGetSublayerElevation(e){return this.state.cpuAggregator.getAccessor("elevation")(e)}_getSublayerUpdateTriggers(){return this.state.cpuAggregator.getUpdateTriggers(this.props)}renderLayers(){const{elevationScale:e,extruded:t,cellSize:i,coverage:n,material:o,transitions:r}=this.props,{cpuAggregator:a}=this.state,s=this.getSubLayerClass("grid-cell",v),l=this._getSublayerUpdateTriggers();return new s({cellSize:i,coverage:n,material:o,elevationScale:e,extruded:t,getFillColor:this._onGetSublayerColor.bind(this),getElevation:this._onGetSublayerElevation.bind(this),transitions:r&&{getFillColor:r.getColorValue||r.getColorWeight,getElevation:r.getElevationValue||r.getElevationWeight}},this.getSubLayerProps({id:"grid-cell",updateTriggers:l}),{data:a.state.layerData.data})}}function Ue(){}const Le={colorDomain:null,colorRange:q,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",value:0,min:0,max:100},upperPercentile:{type:"number",value:100,min:0,max:100},colorScaleType:"quantize",onSetColorDomain:Ue,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationLowerPercentile:{type:"number",value:0,min:0,max:100},elevationUpperPercentile:{type:"number",value:100,min:0,max:100},elevationScale:{type:"number",min:0,value:1},elevationScaleType:"linear",onSetElevationDomain:Ue,radius:{type:"number",value:1e3,min:1},coverage:{type:"number",min:0,max:1,value:1},extruded:!1,hexagonAggregator:function(e,t){const{data:i,radius:n}=e,{viewport:o,attributes:a}=t,s=i.length?function(e,t){const{attributes:i}=t,n=i.positions.value,{size:o}=i.positions.getAccessor();let r,a=1/0,s=1/0,l=-1/0,g=-1/0;for(r=0;r<o*e.length;r+=o){const e=n[r],t=n[r+1];Number.isFinite(e)&&Number.isFinite(t)&&(a=Math.min(e,a),l=Math.max(e,l),s=Math.min(t,s),g=Math.max(t,g))}return[a,s,l,g].every(Number.isFinite)?[(a+l)/2,(s+g)/2]:null}(i,t):null,l=function(e,t,i){const{unitsPerMeter:n}=t.getDistanceScales(i);return e*n[0]}(n,o,s),g=[],{iterable:c,objectInfo:d}=u(i),h=a.positions.value,{size:p}=a.positions.getAccessor();for(const e of c){d.index++;const t=d.index*p,i=[h[t],h[t+1]];Number.isFinite(i[0])&&Number.isFinite(i[1])?g.push({screenCoord:o.projectFlat(i),source:e,index:d.index}):r.warn("HexagonLayer: invalid position")()}return{hexagons:C().radius(l).x((e=>e.screenCoord[0])).y((e=>e.screenCoord[1]))(g).map(((e,t)=>({position:o.unprojectFlat([e.x,e.y]),points:e,index:t}))),radiusCommon:l}},getPosition:{type:"accessor",value:e=>e.position},material:!0,_filterData:{type:"function",value:null,optional:!0}};class Ve extends ie{static{this.layerName="HexagonLayer"}static{this.defaultProps=Le}initializeState(){const e=new Oe({getAggregator:e=>e.hexagonAggregator,getCellSize:e=>e.radius});this.state={cpuAggregator:e,aggregatorState:e.state,vertices:null};this.getAttributeManager().add({positions:{size:3,type:"float64",accessor:"getPosition"}})}updateState(e){if(super.updateState(e),e.changeFlags.propsOrDataChanged){const t=this.state.cpuAggregator.updateState(e,{viewport:this.context.viewport,attributes:this.getAttributes()});if(this.state.aggregatorState.layerData!==t.layerData){const{hexagonVertices:e}=t.layerData||{};this.setState({vertices:e&&this.convertLatLngToMeterOffset(e)})}this.setState({aggregatorState:t})}}convertLatLngToMeterOffset(e){const{viewport:t}=this.context;if(Array.isArray(e)&&6===e.length){const i=e[0],n=e[3],o=[(i[0]+n[0])/2,(i[1]+n[1])/2],r=t.projectFlat(o),{metersPerUnit:a}=t.getDistanceScales(o);return e.map((e=>{const i=t.projectFlat(e);return[(i[0]-r[0])*a[0],(i[1]-r[1])*a[1]]}))}return r.error("HexagonLayer: hexagonVertices needs to be an array of 6 points")(),null}getPickingInfo({info:e}){return this.state.cpuAggregator.getPickingInfo({info:e})}_onGetSublayerColor(e){return this.state.cpuAggregator.getAccessor("fillColor")(e)}_onGetSublayerElevation(e){return this.state.cpuAggregator.getAccessor("elevation")(e)}_getSublayerUpdateTriggers(){return this.state.cpuAggregator.getUpdateTriggers(this.props)}renderLayers(){const{elevationScale:e,extruded:t,coverage:i,material:n,transitions:o}=this.props,{aggregatorState:r,vertices:a}=this.state,s=this.getSubLayerClass("hexagon-cell",S),l=this._getSublayerUpdateTriggers();return new s({...a?{vertices:a,radius:1}:{radius:r.layerData.radiusCommon||1,radiusUnits:"common",angle:90},diskResolution:6,elevationScale:e,extruded:t,coverage:i,material:n,getFillColor:this._onGetSublayerColor.bind(this),getElevation:this._onGetSublayerElevation.bind(this),transitions:o&&{getFillColor:o.getColorValue||o.getColorWeight,getElevation:o.getElevationValue||o.getElevationWeight}},this.getSubLayerProps({id:"hexagon-cell",updateTriggers:l}),{data:r.layerData.data})}}const Ge=.5,je=1/6,ke={N:[0,Ge],E:[Ge,0],S:[0,-.5],W:[-.5,0],NE:[Ge,Ge],NW:[-.5,Ge],SE:[Ge,-.5],SW:[-.5,-.5]},He=[ke.W,ke.SW,ke.S],$e=[ke.S,ke.SE,ke.E],Xe=[ke.E,ke.NE,ke.N],qe=[ke.NW,ke.W,ke.N],Ye=[[-.5,je],[-.5,-je],[-je,-.5],[je,-.5]],Ke=[[-je,-.5],[je,-.5],[Ge,-je],[Ge,je]],Ze=[[Ge,-je],[Ge,je],[je,Ge],[-je,Ge]],Je=[[-.5,je],[-.5,-je],[je,Ge],[-je,Ge]],Qe=[ke.W,ke.SW,ke.SE,ke.E],et=[ke.S,ke.SE,ke.NE,ke.N],tt=[ke.NW,ke.W,ke.E,ke.NE],it=[ke.NW,ke.SW,ke.S,ke.N],nt=[[-.5,je],[-.5,-je],[Ge,-je],[Ge,je]],ot=[[-je,-.5],[je,-.5],[je,Ge],[-je,Ge]],rt=[ke.NW,ke.SW,ke.SE,ke.NE],at=[ke.NW,ke.SW,ke.SE,ke.E,ke.N],st=[ke.W,ke.SW,ke.SE,ke.NE,ke.N],lt=[ke.NW,ke.W,ke.S,ke.SE,ke.NE],gt=[ke.NW,ke.SW,ke.S,ke.E,ke.NE],ut=[ke.NW,ke.W,[Ge,-je],[Ge,je],ke.N],ct=[[-je,-.5],[je,-.5],ke.E,ke.NE,ke.N],dt=[[-.5,je],[-.5,-je],ke.S,ke.SE,ke.E],ht=[ke.W,ke.SW,ke.S,[je,Ge],[-je,Ge]],pt=[ke.NW,ke.W,[-je,-.5],[je,-.5],ke.N],mt=[[-.5,je],[-.5,-je],ke.E,ke.NE,ke.N],ft=[ke.S,ke.SE,ke.E,[je,Ge],[-je,Ge]],xt=[ke.W,ke.SW,ke.S,[Ge,-je],[Ge,je]],vt=[ke.W,ke.SW,ke.SE,ke.E,[je,Ge],[-je,Ge]],St=[[-.5,je],[-.5,-je],ke.S,ke.SE,ke.NE,ke.N],yt=[ke.NW,ke.W,[-je,-.5],[je,-.5],ke.E,ke.NE],bt=[ke.NW,ke.SW,ke.S,[Ge,-je],[Ge,je],ke.N],Ct=[ke.W,ke.SW,ke.S,ke.E,ke.NE,ke.N],Mt=[ke.NW,ke.W,ke.S,ke.SE,ke.E,ke.N],At=[[-.5,je],[-.5,-je],[-je,-.5],[je,-.5],ke.E,ke.NE,ke.N],Dt=[ke.W,ke.SW,ke.S,[Ge,-je],[Ge,je],[je,Ge],[-je,Ge]],wt=[ke.NW,ke.W,[-je,-.5],[je,-.5],[Ge,-je],[Ge,je],ke.N],Pt=[[-.5,je],[-.5,-je],ke.S,ke.SE,ke.E,[je,Ge],[-je,Ge]],Tt=[[-.5,je],[-.5,-je],[-je,-.5],[je,-.5],[Ge,-je],[Ge,je],[je,Ge],[-je,Ge]],_t={0:[],1:[[ke.W,ke.S]],2:[[ke.S,ke.E]],3:[[ke.W,ke.E]],4:[[ke.N,ke.E]],5:{0:[[ke.W,ke.S],[ke.N,ke.E]],1:[[ke.W,ke.N],[ke.S,ke.E]]},6:[[ke.N,ke.S]],7:[[ke.W,ke.N]],8:[[ke.W,ke.N]],9:[[ke.N,ke.S]],10:{0:[[ke.W,ke.N],[ke.S,ke.E]],1:[[ke.W,ke.S],[ke.N,ke.E]]},11:[[ke.N,ke.E]],12:[[ke.W,ke.E]],13:[[ke.S,ke.E]],14:[[ke.W,ke.S]],15:[]};function zt(e){return parseInt(e,4)}const Et={[zt("0000")]:[],[zt("2222")]:[],[zt("2221")]:[He],[zt("2212")]:[$e],[zt("2122")]:[Xe],[zt("1222")]:[qe],[zt("0001")]:[He],[zt("0010")]:[$e],[zt("0100")]:[Xe],[zt("1000")]:[qe],[zt("2220")]:[Ye],[zt("2202")]:[Ke],[zt("2022")]:[Ze],[zt("0222")]:[Je],[zt("0002")]:[Ye],[zt("0020")]:[Ke],[zt("0200")]:[Ze],[zt("2000")]:[Je],[zt("0011")]:[Qe],[zt("0110")]:[et],[zt("1100")]:[tt],[zt("1001")]:[it],[zt("2211")]:[Qe],[zt("2112")]:[et],[zt("1122")]:[tt],[zt("1221")]:[it],[zt("2200")]:[nt],[zt("2002")]:[ot],[zt("0022")]:[nt],[zt("0220")]:[ot],[zt("1111")]:[rt],[zt("1211")]:[at],[zt("2111")]:[st],[zt("1112")]:[lt],[zt("1121")]:[gt],[zt("1011")]:[at],[zt("0111")]:[st],[zt("1110")]:[lt],[zt("1101")]:[gt],[zt("1200")]:[ut],[zt("0120")]:[ct],[zt("0012")]:[dt],[zt("2001")]:[ht],[zt("1022")]:[ut],[zt("2102")]:[ct],[zt("2210")]:[dt],[zt("0221")]:[ht],[zt("1002")]:[pt],[zt("2100")]:[mt],[zt("0210")]:[ft],[zt("0021")]:[xt],[zt("1220")]:[pt],[zt("0122")]:[mt],[zt("2012")]:[ft],[zt("2201")]:[xt],[zt("0211")]:[vt],[zt("2110")]:[St],[zt("1102")]:[yt],[zt("1021")]:[bt],[zt("2011")]:[vt],[zt("0112")]:[St],[zt("1120")]:[yt],[zt("1201")]:[bt],[zt("2101")]:[Ct],[zt("0121")]:[Ct],[zt("1012")]:[Mt],[zt("1210")]:[Mt],[zt("0101")]:{0:[He,Xe],1:[Ct],2:[Ct]},[zt("1010")]:{0:[qe,$e],1:[Mt],2:[Mt]},[zt("2121")]:{0:[Ct],1:[Ct],2:[He,Xe]},[zt("1212")]:{0:[Mt],1:[Mt],2:[qe,$e]},[zt("2120")]:{0:[At],1:[At],2:[Ye,Xe]},[zt("2021")]:{0:[Dt],1:[Dt],2:[He,Ze]},[zt("1202")]:{0:[wt],1:[wt],2:[qe,Ke]},[zt("0212")]:{0:[Pt],1:[Pt],2:[$e,Je]},[zt("0102")]:{0:[Ye,Xe],1:[At],2:[At]},[zt("0201")]:{0:[He,Ze],1:[Dt],2:[Dt]},[zt("1020")]:{0:[qe,Ke],1:[wt],2:[wt]},[zt("2010")]:{0:[$e,Je],1:[Pt],2:[Pt]},[zt("2020")]:{0:[Je,Ke],1:[Tt],2:[Ye,Ze]},[zt("0202")]:{0:[Ze,Ye],1:[Tt],2:[Je,Ke]}},Bt={ISO_LINES:1,ISO_BANDS:2},Nt={zIndex:0,zOffset:.005};function Wt(e,t){return Array.isArray(t)?e<t[0]?0:e<t[1]?1:2:e>=t?1:0}function Ot(e){const{cellWeights:t,x:i,y:n,width:o,height:a}=e;let s=e.threshold;e.thresholdValue&&(r.deprecated("thresholdValue","threshold")(),s=e.thresholdValue);const l=i<0,g=i>=o-1,u=n<0,c=n>=a-1,d=l||g||u||c,h={},p={};l||c?p.top=0:(h.top=t[(n+1)*o+i],p.top=Wt(h.top,s)),g||c?p.topRight=0:(h.topRight=t[(n+1)*o+i+1],p.topRight=Wt(h.topRight,s)),g||u?p.right=0:(h.right=t[n*o+i+1],p.right=Wt(h.right,s)),l||u?p.current=0:(h.current=t[n*o+i],p.current=Wt(h.current,s));const{top:m,topRight:f,right:x,current:v}=p;let S=-1;Number.isFinite(s)&&(S=m<<3|f<<2|x<<1|v),Array.isArray(s)&&(S=m<<6|f<<4|x<<2|v);let y=0;return d||(y=Wt((h.top+h.topRight+h.right+h.current)/4,s)),{code:S,meanCode:y}}function Ft(e){const{gridOrigin:t,cellSize:i,x:n,y:o,code:r,meanCode:a,type:s=Bt.ISO_LINES}=e,l={...Nt,...e.thresholdData};let g=s===Bt.ISO_BANDS?Et[r]:_t[r];Array.isArray(g)||(g=g[a]);const u=l.zIndex*l.zOffset,c=(n+1)*i[0],d=(o+1)*i[1],h=t[0]+c,p=t[1]+d;if(s===Bt.ISO_BANDS){const e=[];return g.forEach((t=>{const n=[];t.forEach((e=>{const t=h+e[0]*i[0],o=p+e[1]*i[1];n.push([t,o,u])})),e.push(n)})),e}const m=[];return g.forEach((e=>{e.forEach((e=>{const t=h+e[0]*i[0],n=p+e[1]*i[1];m.push([t,n,u])}))})),m}const It=[255,255,255,255],Rt={cellSize:{type:"number",min:1,max:1e3,value:1e3},getPosition:{type:"accessor",value:e=>e.position},getWeight:{type:"accessor",value:1},gpuAggregation:!1,aggregation:"SUM",contours:{type:"object",value:[{threshold:1}],optional:!0,compare:3},zOffset:.005},Ut="positions",Lt={data:{props:["cellSize"]},weights:{props:["aggregation"],accessors:["getWeight"]}};class Vt extends we{static{this.layerName="ContourLayer"}static{this.defaultProps=Rt}initializeState(){super.initializeAggregationLayer({dimensions:Lt}),this.setState({contourData:{},projectPoints:!1,weights:{count:{size:1,operation:M.SUM}}});this.getAttributeManager().add({[Ut]:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},count:{size:3,accessor:"getWeight"}})}updateState(e){super.updateState(e);let t=!1;const{oldProps:i,props:n}=e,{aggregationDirty:o}=this.state;i.contours===n.contours&&i.zOffset===n.zOffset||(t=!0,this._updateThresholdData(e.props)),this.getNumInstances()>0&&(o||t)&&this._generateContours()}renderLayers(){const{contourSegments:e,contourPolygons:t}=this.state.contourData,i=this.getSubLayerClass("lines",y),n=this.getSubLayerClass("bands",b);return[e&&e.length>0&&new i(this.getSubLayerProps({id:"lines"}),{data:this.state.contourData.contourSegments,getSourcePosition:e=>e.start,getTargetPosition:e=>e.end,getColor:e=>e.contour.color||It,getWidth:e=>e.contour.strokeWidth||1}),t&&t.length>0&&new n(this.getSubLayerProps({id:"bands"}),{data:this.state.contourData.contourPolygons,getPolygon:e=>e.vertices,getFillColor:e=>e.contour.color||It})]}updateAggregationState(e){const{props:t,oldProps:i}=e,{cellSize:n,coordinateSystem:o}=t,{viewport:a}=this.context,s=i.cellSize!==n;let l=t.gpuAggregation;this.state.gpuAggregation!==t.gpuAggregation&&l&&!X.isSupported(this.context.device)&&(r.warn("GPU Grid Aggregation not supported, falling back to CPU")(),l=!1);const g=l!==this.state.gpuAggregation;this.setState({gpuAggregation:l});const{dimensions:u}=this.state,c=this.isAttributeChanged(Ut),{data:d,weights:h}=u;let{boundingBox:p}=this.state;if(c&&(p=be(this.getAttributes(),this.getNumInstances()),this.setState({boundingBox:p})),c||s){const{gridOffset:e,translation:t,width:i,height:r,numCol:s,numRow:l}=Ae(p,n,a,o);this.allocateResources(l,s),this.setState({gridOffset:e,boundingBox:p,translation:t,posOffset:t.slice(),gridOrigin:[-1*t[0],-1*t[1]],width:i,height:r,numCol:s,numRow:l})}const m=c||g||this.isAggregationDirty(e,{dimension:d,compareAll:l}),f=this.isAggregationDirty(e,{dimension:h});f&&this._updateAccessors(e),(m||f)&&this._resetResults(),this.setState({aggregationDataDirty:m,aggregationWeightsDirty:f})}_updateAccessors(e){const{getWeight:t,aggregation:i,data:n}=e.props,{count:o}=this.state.weights;o&&(o.getWeight=t,o.operation=M[i]),this.setState({getValue:P(i,t,{data:n})})}_resetResults(){const{count:e}=this.state.weights;e&&(e.aggregationData=null)}_generateContours(){const{numCol:e,numRow:t,gridOrigin:i,gridOffset:n,thresholdData:o}=this.state,{count:r}=this.state.weights;let{aggregationData:a}=r;a||(a=r.aggregationBuffer.readSyncWebGL(),r.aggregationData=a);const{cellWeights:s}=X.getCellData({countsData:a}),l=function({thresholdData:e,cellWeights:t,gridSize:i,gridOrigin:n,cellSize:o}){const r=[],a=[],s=i[0],l=i[1];let g=0,u=0;for(const i of e){const{contour:e}=i,{threshold:c}=e;for(let d=-1;d<s;d++)for(let h=-1;h<l;h++){const{code:p,meanCode:m}=Ot({cellWeights:t,threshold:c,x:d,y:h,width:s,height:l}),f={type:Bt.ISO_BANDS,gridOrigin:n,cellSize:o,x:d,y:h,width:s,height:l,code:p,meanCode:m,thresholdData:i};if(Array.isArray(c)){f.type=Bt.ISO_BANDS;const t=Ft(f);for(const i of t)a[u++]={vertices:i,contour:e}}else{f.type=Bt.ISO_LINES;const t=Ft(f);for(let i=0;i<t.length;i+=2)r[g++]={start:t[i],end:t[i+1],contour:e}}}}return{contourSegments:r,contourPolygons:a}}({thresholdData:o,cellWeights:s,gridSize:[e,t],gridOrigin:i,cellSize:[n.xOffset,n.yOffset]});this.setState({contourData:l})}_updateThresholdData(e){const{contours:t,zOffset:i}=e,n=t.length,o=new Array(n);for(let e=0;e<n;e++){const n=t[e];o[e]={contour:n,zIndex:n.zIndex||e,zOffset:i}}this.setState({thresholdData:o})}}const Gt={colorDomain:null,colorRange:q,elevationDomain:null,elevationRange:[0,1e3],elevationScale:{type:"number",min:0,value:1},gridSize:{type:"array",value:[1,1]},gridOrigin:{type:"array",value:[0,0]},gridOffset:{type:"array",value:[0,0]},cellSize:{type:"number",min:0,max:1e3,value:1e3},offset:{type:"array",value:[1,1]},coverage:{type:"number",min:0,max:1,value:1},extruded:!0,material:!0};class jt extends n{static{this.layerName="GPUGridCellLayer"}static{this.defaultProps=Gt}getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME gpu-grid-cell-layer-vertex-shader\n#define RANGE_COUNT 6\nin vec3 positions;\nin vec3 normals;\nin vec4 colors;\nin vec4 elevations;\nin vec3 instancePickingColors;\nuniform vec2 offset;\nuniform bool extruded;\nuniform float cellSize;\nuniform float coverage;\nuniform float opacity;\nuniform float elevationScale;\nuniform ivec2 gridSize;\nuniform vec2 gridOrigin;\nuniform vec2 gridOriginLow;\nuniform vec2 gridOffset;\nuniform vec2 gridOffsetLow;\nuniform vec4 colorRange[RANGE_COUNT];\nuniform vec2 elevationRange;\nuniform vec2 colorDomain;\nuniform bool colorDomainValid;\nuniform vec2 elevationDomain;\nuniform bool elevationDomainValid;\nlayout(std140) uniform;\nuniform ColorData\n{\nvec4 maxMinCount;\n} colorData;\nuniform ElevationData\n{\nvec4 maxMinCount;\n} elevationData;\n#define EPSILON 0.00001\nout vec4 vColor;\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\nvec4 outColor = vec4(0., 0., 0., 0.);\nif (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {\nfloat domainRange = domain.y - domain.x;\nif (domainRange <= 0.) {\noutColor = colorRange[0];\n} else {\nfloat rangeCount = float(RANGE_COUNT);\nfloat rangeStep = domainRange / rangeCount;\nfloat idx = floor((value - domain.x) / rangeStep);\nidx = clamp(idx, 0., rangeCount - 1.);\nint intIdx = int(idx);\noutColor = colorRange[intIdx];\n}\n}\nreturn outColor;\n}\nfloat linearScale(vec2 domain, vec2 range, float value) {\nif (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {\nreturn ((value - domain.x) / (domain.y - domain.x)) * (range.y - range.x) + range.x;\n}\nreturn -1.;\n}\nvoid main(void) {\nvec2 clrDomain = colorDomainValid ? colorDomain : vec2(colorData.maxMinCount.a, colorData.maxMinCount.r);\nvec4 color = quantizeScale(clrDomain, colorRange, colors.r);\nfloat elevation = 0.0;\nif (extruded) {\nvec2 elvDomain = elevationDomainValid ? elevationDomain : vec2(elevationData.maxMinCount.a, elevationData.maxMinCount.r);\nelevation = linearScale(elvDomain, elevationRange, elevations.r);\nelevation = elevation  * (positions.z + 1.0) / 2.0 * elevationScale;\n}\nfloat shouldRender = float(color.r > 0.0 && elevations.r >= 0.0);\nfloat dotRadius = cellSize / 2. * coverage * shouldRender;\nint yIndex = (gl_InstanceID / gridSize[0]);\nint xIndex = gl_InstanceID - (yIndex * gridSize[0]);\nvec2 instancePositionXFP64 = mul_fp64(vec2(gridOffset[0], gridOffsetLow[0]), vec2(float(xIndex), 0.));\ninstancePositionXFP64 = sum_fp64(instancePositionXFP64, vec2(gridOrigin[0], gridOriginLow[0]));\nvec2 instancePositionYFP64 = mul_fp64(vec2(gridOffset[1], gridOffsetLow[1]), vec2(float(yIndex), 0.));\ninstancePositionYFP64 = sum_fp64(instancePositionYFP64, vec2(gridOrigin[1], gridOriginLow[1]));\nvec3 centroidPosition = vec3(instancePositionXFP64[0], instancePositionYFP64[0], elevation);\nvec3 centroidPosition64Low = vec3(instancePositionXFP64[1], instancePositionYFP64[1], 0.0);\ngeometry.worldPosition = centroidPosition;\nvec3 pos = vec3(project_size(positions.xy + offset) * dotRadius, 0.);\npicking_setPickingColor(instancePickingColors);\ngl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\nvec3 normals_commonspace = project_normal(normals);\nif (extruded) {\nvec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, normals_commonspace);\nvColor = vec4(lightColor, color.a * opacity) / 255.;\n} else {\nvColor = vec4(color.rgb, color.a * opacity) / 255.;\n}\n}\n",fs:"#version 300 es\n#define SHADER_NAME gpu-grid-cell-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nout vec4 fragColor;\nvoid main(void) {\nfragColor = vColor;\nfragColor = picking_filterColor(fragColor);\n}\n",modules:[t,c,o,x]})}initializeState(){this.getAttributeManager().addInstanced({colors:{size:4,noAlloc:!0},elevations:{size:4,noAlloc:!0}});const e=this._getModel();this._setupUniformBuffer(e),this.setState({model:e})}_getModel(){return new h(this.context.device,{...this.getShaders(),id:this.props.id,geometry:new f,isInstanced:!0})}draw({uniforms:e}){const{cellSize:t,offset:i,extruded:n,elevationScale:o,coverage:r,gridSize:a,gridOrigin:s,gridOffset:l,elevationRange:g,colorMaxMinBuffer:u,elevationMaxMinBuffer:c}=this.props,h=this.state.model,p=[d(s[0]),d(s[1])],m=[d(l[0]),d(l[1])],f=this.getDomainUniforms(),x=Y(this.props.colorRange);this.bindUniformBuffers(u,c),h.setUniforms(e),h.setUniforms(f),h.setUniforms({cellSize:t,offset:i,extruded:n,elevationScale:o,coverage:r,gridSize:a,gridOrigin:s,gridOriginLow:p,gridOffset:l,gridOffsetLow:m,colorRange:x,elevationRange:g}),h.draw(this.context.renderPass),this.unbindUniformBuffers(u,c)}bindUniformBuffers(e,t){e.bind({target:35345,index:0}),t.bind({target:35345,index:1})}unbindUniformBuffers(e,t){e.unbind({target:35345,index:0}),t.unbind({target:35345,index:1})}getDomainUniforms(){const{colorDomain:e,elevationDomain:t}=this.props,i={};return null!==e?(i.colorDomainValid=!0,i.colorDomain=e):i.colorDomainValid=!1,null!==t?(i.elevationDomainValid=!0,i.elevationDomain=t):i.elevationDomainValid=!1,i}_setupUniformBuffer(e){const t=e.pipeline.handle,i=this.context.gl,n=i.getUniformBlockIndex(t,"ColorData"),o=i.getUniformBlockIndex(t,"ElevationData");i.uniformBlockBinding(t,n,0),i.uniformBlockBinding(t,o,1)}}const kt={colorDomain:null,colorRange:q,getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",elevationDomain:null,elevationRange:[0,1e3],getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationScale:{type:"number",min:0,value:1},cellSize:{type:"number",min:1,max:1e3,value:1e3},coverage:{type:"number",min:0,max:1,value:1},getPosition:{type:"accessor",value:e=>e.position},extruded:!1,material:!0},Ht={data:{props:["cellSize","colorAggregation","elevationAggregation"]}},$t="positions";class Xt extends we{static{this.layerName="GPUGridLayer"}static{this.defaultProps=kt}initializeState({device:e}){const t=X.isSupported(e);t||r.error("GPUGridLayer is not supported on this browser, use GridLayer instead")(),super.initializeAggregationLayer({dimensions:Ht}),this.setState({gpuAggregation:!1,projectPoints:!1,isSupported:t,weights:{color:{needMin:!0,needMax:!0,combineMaxMin:!0,maxMinBuffer:e.createBuffer({byteLength:16,accessor:{size:4,type:5126,divisor:1}})},elevation:{needMin:!0,needMax:!0,combineMaxMin:!0,maxMinBuffer:e.createBuffer({byteLength:16,accessor:{size:4,type:5126,divisor:1}})}},positionAttributeName:"positions"});this.getAttributeManager().add({[$t]:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},color:{size:3,accessor:"getColorWeight"},elevation:{size:3,accessor:"getElevationWeight"}})}updateState(e){if(!1===this.state.isSupported)return;super.updateState(e);const{aggregationDirty:t}=this.state;t&&this.setState({gridHash:null})}getHashKeyForIndex(e){const{numRow:t,numCol:i,boundingBox:n,gridOffset:o}=this.state,r=[i,t],a=[n.xMin,n.yMin],s=[o.xOffset,o.yOffset],l=Math.floor(e/r[0]),g=e-l*r[0];return`${Math.floor((l*s[1]+a[1]+90+s[1]/2)/s[1])}-${Math.floor((g*s[0]+a[0]+180+s[0]/2)/s[0])}`}getPositionForIndex(e){const{numRow:t,numCol:i,boundingBox:n,gridOffset:o}=this.state,r=[i,t],a=[n.xMin,n.yMin],s=[o.xOffset,o.yOffset],l=Math.floor(e/r[0]);return[(e-l*r[0])*s[0]+a[0],l*s[1]+a[1]]}getPickingInfo({info:e,mode:t}){const{index:i}=e;let n=null;if(i>=0){const e=this.state.gpuGridAggregator,o=this.getPositionForIndex(i),r=X.getAggregationData({pixelIndex:i,...e.getData("color")}),a=X.getAggregationData({pixelIndex:i,...e.getData("elevation")});if(n={colorValue:r.cellWeight,elevationValue:a.cellWeight,count:r.cellCount||a.cellCount,position:o,totalCount:r.totalCount||a.totalCount},"hover"!==t){const{props:e}=this;let{gridHash:t}=this.state;if(!t){const{gridOffset:i,translation:n,boundingBox:o}=this.state,{viewport:r}=this.context;t=De(e,{gridOffset:i,attributes:this.getAttributes(),viewport:r,translation:n,boundingBox:o}).gridHash,this.setState({gridHash:t})}const o=t[this.getHashKeyForIndex(i)];Object.assign(n,o)}}return e.picked=Boolean(n),e.object=n,e}renderLayers(){if(!this.state.isSupported)return null;const{elevationScale:e,extruded:t,cellSize:i,coverage:n,material:o,elevationRange:r,colorDomain:a,elevationDomain:s}=this.props,{weights:l,numRow:g,numCol:u,gridOrigin:c,gridOffset:d}=this.state,{color:h,elevation:p}=l,m=Y(this.props.colorRange);return new(this.getSubLayerClass("gpu-grid-cell",jt))({gridSize:[u,g],gridOrigin:c,gridOffset:[d.xOffset,d.yOffset],colorRange:m,elevationRange:r,colorDomain:a,elevationDomain:s,cellSize:i,coverage:n,material:o,elevationScale:e,extruded:t},this.getSubLayerProps({id:"gpu-grid-cell"}),{data:{attributes:{colors:h.aggregationBuffer,elevations:p.aggregationBuffer}},colorMaxMinBuffer:h.maxMinBuffer,elevationMaxMinBuffer:p.maxMinBuffer,numInstances:u*g})}finalizeState(e){const{color:t,elevation:i}=this.state.weights;[t,i].forEach((e=>{const{aggregationBuffer:t,maxMinBuffer:i}=e;i?.destroy(),t?.destroy()})),super.finalizeState(e)}updateAggregationState(e){const{props:t,oldProps:i}=e,{cellSize:n,coordinateSystem:o}=t,{viewport:r}=this.context,a=i.cellSize!==n,{dimensions:s}=this.state,l=this.isAttributeChanged($t),g=l||this.isAttributeChanged();let{boundingBox:u}=this.state;if(l&&(u=be(this.getAttributes(),this.getNumInstances()),this.setState({boundingBox:u})),l||a){const{gridOffset:e,translation:t,width:i,height:a,numCol:s,numRow:l}=Ae(u,n,r,o);this.allocateResources(l,s),this.setState({gridOffset:e,translation:t,gridOrigin:[-1*t[0],-1*t[1]],width:i,height:a,numCol:s,numRow:l})}const c=g||this.isAggregationDirty(e,{dimension:s.data,compareAll:!0});c&&this._updateAccessors(e),this.setState({aggregationDataDirty:c})}_updateAccessors(e){const{colorAggregation:t,elevationAggregation:i}=e.props,{color:n,elevation:o}=this.state.weights;n.operation=M[t],o.operation=M[i]}}const qt={...Xt.defaultProps,...Re.defaultProps,gpuAggregation:!1};class Yt extends a{static{this.layerName="GridLayer"}static{this.defaultProps=qt}initializeState(){this.state={useGPUAggregation:!1}}updateState({props:e}){this.setState({useGPUAggregation:!1})}renderLayers(){const{data:e,updateTriggers:t}=this.props,i=this.state.useGPUAggregation?"GPU":"CPU";return new(this.state.useGPUAggregation?this.getSubLayerClass("GPU",Xt):this.getSubLayerClass("CPU",Re))(this.props,this.getSubLayerProps({id:i,updateTriggers:t}),{data:e})}canUseGPUAggregation(e){const{gpuAggregation:t,lowerPercentile:i,upperPercentile:n,getColorValue:o,getElevationValue:r,colorScaleType:a}=e;return!!t&&(!!X.isSupported(this.context.device)&&(0===i&&100===n&&(null===o&&null===r&&("quantile"!==a&&"ordinal"!==a))))}}const Kt=new Float32Array(12);function Zt(e,t=2){let i=0;for(const n of e)for(let e=0;e<t;e++)Kt[i++]=n[e]||0;return Kt}class Jt extends n{static{this.layerName="TriangleLayer"}getShaders(){return{vs:"#version 300 es\n#define SHADER_NAME heatp-map-layer-vertex-shader\nuniform sampler2D maxTexture;\nuniform float intensity;\nuniform vec2 colorDomain;\nuniform float threshold;\nuniform float aggregationMode;\nin vec3 positions;\nin vec2 texCoords;\nout vec2 vTexCoords;\nout float vIntensityMin;\nout float vIntensityMax;\nvoid main(void) {\ngl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));\nvTexCoords = texCoords;\nvec4 maxTexture = texture(maxTexture, vec2(0.5));\nfloat maxValue = aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;\nfloat minValue = maxValue * threshold;\nif (colorDomain[1] > 0.) {\nmaxValue = colorDomain[1];\nminValue = colorDomain[0];\n}\nvIntensityMax = intensity / maxValue;\nvIntensityMin = intensity / minValue;\n}\n",fs:"#version 300 es\n#define SHADER_NAME triangle-layer-fragment-shader\nprecision highp float;\nuniform float opacity;\nuniform sampler2D weightsTexture;\nuniform sampler2D colorTexture;\nuniform float aggregationMode;\nin vec2 vTexCoords;\nin float vIntensityMin;\nin float vIntensityMax;\nout vec4 fragColor;\nvec4 getLinearColor(float value) {\nfloat factor = clamp(value * vIntensityMax, 0., 1.);\nvec4 color = texture(colorTexture, vec2(factor, 0.5));\ncolor.a *= min(value * vIntensityMin, 1.0);\nreturn color;\n}\nvoid main(void) {\nvec4 weights = texture(weightsTexture, vTexCoords);\nfloat weight = weights.r;\nif (aggregationMode > 0.5) {\nweight /= max(1.0, weights.a);\n}\nif (weight <= 0.) {\ndiscard;\n}\nvec4 linearColor = getLinearColor(weight);\nlinearColor.a *= opacity;\nfragColor = linearColor;\n}\n",modules:[t]}}initializeState({device:e}){this.setState({model:this._getModel(e)})}_getModel(e){const{vertexCount:t,data:i,weightsTexture:n,maxTexture:o,colorTexture:r}=this.props;return new h(e,{...this.getShaders(),id:this.props.id,bindings:{weightsTexture:n,maxTexture:o,colorTexture:r},attributes:i.attributes,bufferLayout:[{name:"positions",format:"float32x3"},{name:"texCoords",format:"float32x2"}],topology:"triangle-fan-webgl",vertexCount:t})}draw({uniforms:e}){const{model:t}=this.state,{intensity:i,threshold:n,aggregationMode:o,colorDomain:r}=this.props;t.setUniforms({...e,intensity:i,threshold:n,aggregationMode:o,colorDomain:r}),t.draw(this.context.renderPass)}}var Qt="#version 300 es\nin vec3 positions;\nin vec3 positions64Low;\nin float weights;\nout vec4 weightsTexture;\nuniform float radiusPixels;\nuniform float textureWidth;\nuniform vec4 commonBounds;\nuniform float weightsScale;\nvoid main()\n{\nweightsTexture = vec4(weights * weightsScale, 0., 0., 1.);\nfloat radiusTexels = project_pixel_size(radiusPixels) * textureWidth / (commonBounds.z - commonBounds.x);\ngl_PointSize = radiusTexels * 2.;\nvec3 commonPosition = project_position(positions, positions64Low);\ngl_Position.xy = (commonPosition.xy - commonBounds.xy) / (commonBounds.zw - commonBounds.xy) ;\ngl_Position.xy = (gl_Position.xy * 2.) - (1.);\ngl_Position.w = 1.0;\n}\n",ei="#version 300 es\nin vec4 weightsTexture;\nout vec4 fragColor;\nfloat gaussianKDE(float u){\nreturn pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);\n}\nvoid main()\n{\nfloat dist = length(gl_PointCoord - vec2(0.5, 0.5));\nif (dist > 0.5) {\ndiscard;\n}\nfragColor = weightsTexture * gaussianKDE(2. * dist);\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n";const ti={format:"rgba8unorm",mipmaps:!1,sampler:{minFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}},ii=[0,0],ni={SUM:0,MEAN:1},oi={getPosition:{type:"accessor",value:e=>e.position},getWeight:{type:"accessor",value:1},intensity:{type:"number",min:0,value:1},radiusPixels:{type:"number",min:1,max:100,value:50},colorRange:q,threshold:{type:"number",min:0,max:1,value:.05},colorDomain:{type:"array",value:null,optional:!0},aggregation:"SUM",weightsTextureSize:{type:"number",min:128,max:2048,value:2048},debounceTimeout:{type:"number",min:0,max:1e3,value:500}},ri=["float32-renderable-webgl","texture-blend-float-webgl"],ai={data:{props:["radiusPixels"]}};class si extends ie{static{this.layerName="HeatmapLayer"}static{this.defaultProps=oi}initializeState(){super.initializeAggregationLayer(ai),this.setState({colorDomain:ii}),this._setupTextureParams(),this._setupAttributes(),this._setupResources()}shouldUpdateState({changeFlags:e}){return e.somethingChanged}updateState(e){super.updateState(e),this._updateHeatmapState(e)}_updateHeatmapState(e){const{props:t,oldProps:i}=e,n=this._getChangeFlags(e);(n.dataChanged||n.viewportChanged)&&(n.boundsChanged=this._updateBounds(n.dataChanged),this._updateTextureRenderingBounds()),n.dataChanged||n.boundsChanged?(clearTimeout(this.state.updateTimer),this.setState({isWeightMapDirty:!0})):n.viewportZoomChanged&&this._debouncedUpdateWeightmap(),t.colorRange!==i.colorRange&&this._updateColorTexture(e),this.state.isWeightMapDirty&&this._updateWeightmap(),this.setState({zoom:e.context.viewport.zoom})}renderLayers(){const{weightsTexture:e,triPositionBuffer:t,triTexCoordBuffer:i,maxWeightsTexture:n,colorTexture:o,colorDomain:r}=this.state,{updateTriggers:a,intensity:s,threshold:l,aggregation:u}=this.props;return new(this.getSubLayerClass("triangle",Jt))(this.getSubLayerProps({id:"triangle-layer",updateTriggers:a}),{coordinateSystem:g.DEFAULT,data:{attributes:{positions:t,texCoords:i}},vertexCount:4,maxTexture:n,colorTexture:o,aggregationMode:ni[u]||0,weightsTexture:e,intensity:s,threshold:l,colorDomain:r})}finalizeState(e){super.finalizeState(e);const{weightsTransform:t,weightsTexture:i,maxWeightTransform:n,maxWeightsTexture:o,triPositionBuffer:r,triTexCoordBuffer:a,colorTexture:s,updateTimer:l}=this.state;t?.destroy(),i?.destroy(),n?.destroy(),o?.destroy(),r?.destroy(),a?.destroy(),s?.destroy(),l&&clearTimeout(l)}_getAttributeManager(){return new l(this.context.device,{id:this.props.id,stats:this.context.stats})}_getChangeFlags(e){const t={},{dimensions:i}=this.state;t.dataChanged=this.isAttributeChanged()?"attribute changed":this.isAggregationDirty(e,{compareAll:!0,dimension:i.data})&&"aggregation is dirty",t.viewportChanged=e.changeFlags.viewportChanged;const{zoom:n}=this.state;return e.context.viewport&&e.context.viewport.zoom===n||(t.viewportZoomChanged=!0),t}_createTextures(){const{textureSize:e,format:t}=this.state;this.setState({weightsTexture:this.context.device.createTexture({...ti,width:e,height:e,format:t}),maxWeightsTexture:this.context.device.createTexture({...ti,width:1,height:1,format:t})})}_setupAttributes(){this.getAttributeManager().add({positions:{size:3,type:"float64",accessor:"getPosition"},weights:{size:1,accessor:"getWeight"}}),this.setState({positionAttributeName:"positions"})}_setupTextureParams(){const{device:e}=this.context,{weightsTextureSize:t}=this.props,i=Math.min(t,e.limits.maxTextureDimension2D),n=ri.every((t=>e.features.has(t))),o=n?"rgba32float":"rgba8unorm",a=n?1:1/255;this.setState({textureSize:i,format:o,weightsScale:a}),n||r.warn(`HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`)()}_createWeightsTransform(e){let{weightsTransform:t}=this.state;const{weightsTexture:i}=this.state,n=this.getAttributeManager();t?.destroy(),t=new p(this.context.device,{id:`${this.id}-weights-transform`,bufferLayout:n.getBufferLayouts(),vertexCount:1,targetTexture:i,parameters:{depthWriteEnabled:!1,blendColorOperation:"add",blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one"},topology:"point-list",...e}),this.setState({weightsTransform:t})}_setupResources(){this._createTextures();const{device:e}=this.context,{textureSize:t,weightsTexture:i,maxWeightsTexture:n}=this.state,o=this.getShaders({vs:Qt,fs:ei});this._createWeightsTransform(o);const r=this.getShaders({vs:"#version 300 es\nuniform sampler2D inTexture;\nuniform float textureSize;\nout vec4 outTexture;\nvoid main()\n{\nint yIndex = gl_VertexID / int(textureSize);\nint xIndex = gl_VertexID - (yIndex * int(textureSize));\nvec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / textureSize;\noutTexture = texture(inTexture, uv);\ngl_Position = vec4(0.0, 0.0, 0.0, 1.0);\ngl_PointSize = 1.0;\n}\n",fs:"#version 300 es\nin vec4 outTexture;\nout vec4 fragColor;\nvoid main() {\nfragColor = outTexture;\nfragColor.g = outTexture.r / max(1.0, outTexture.a);\n}\n"}),a=new p(e,{id:`${this.id}-max-weights-transform`,bindings:{inTexture:i},uniforms:{textureSize:t},targetTexture:n,...r,vertexCount:t*t,topology:"point-list",parameters:{depthWriteEnabled:!1,blendColorOperation:"max",blendAlphaOperation:"max",blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one"}});this.setState({weightsTexture:i,maxWeightsTexture:n,maxWeightTransform:a,zoom:null,triPositionBuffer:e.createBuffer({byteLength:48}),triTexCoordBuffer:e.createBuffer({byteLength:48})})}updateShaders(e){this._createWeightsTransform({vs:Qt,fs:ei,...e})}_updateMaxWeightValue(){const{maxWeightTransform:e}=this.state;e.run({parameters:{viewport:[0,0,1,1]},clearColor:[0,0,0,0]})}_updateBounds(e=!1){const{viewport:t}=this.context,i=[t.unproject([0,0]),t.unproject([t.width,0]),t.unproject([t.width,t.height]),t.unproject([0,t.height])].map((e=>e.map(Math.fround))),n=function(e){const t=e.map((e=>e[0])),i=e.map((e=>e[1])),n=Math.min.apply(null,t),o=Math.max.apply(null,t);return[n,Math.min.apply(null,i),o,Math.max.apply(null,i)]}(i),o={visibleWorldBounds:n,viewportCorners:i};let r=!1;if(e||!this.state.worldBounds||(a=this.state.worldBounds,!((s=n)[0]>=a[0]&&s[2]<=a[2]&&s[1]>=a[1]&&s[3]<=a[3]))){const e=this._worldToCommonBounds(n),t=this._commonToWorldBounds(e);this.props.coordinateSystem===g.LNGLAT&&(t[1]=Math.max(t[1],-85.051129),t[3]=Math.min(t[3],85.051129),t[0]=Math.max(t[0],-360),t[2]=Math.min(t[2],360));const i=this._worldToCommonBounds(t);o.worldBounds=t,o.normalizedCommonBounds=i,r=!0}var a,s;return this.setState(o),r}_updateTextureRenderingBounds(){const{triPositionBuffer:e,triTexCoordBuffer:t,normalizedCommonBounds:i,viewportCorners:n}=this.state,{viewport:o}=this.context;e.write(Zt(n,3));const r=n.map((e=>function(e,t){const[i,n,o,r]=t;return[(e[0]-i)/(o-i),(e[1]-n)/(r-n)]}(o.projectPosition(e),i)));t.write(Zt(r,2))}_updateColorTexture(e){const{colorRange:t}=e.props;let{colorTexture:i}=this.state;const n=Y(t,!1,Uint8Array);i&&i?.width===t.length?i.setSubImageData({data:n}):(i?.destroy(),i=this.context.device.createTexture({...ti,data:n,width:t.length,height:1})),this.setState({colorTexture:i})}_updateWeightmap(){const{radiusPixels:e,colorDomain:t,aggregation:i}=this.props,{worldBounds:n,textureSize:o,weightsScale:r}=this.state,a=this.state.weightsTransform;this.state.isWeightMapDirty=!1;const s=this._worldToCommonBounds(n,{useLayerCoordinateSystem:!0});if(t&&"SUM"===i){const{viewport:e}=this.context,i=e.distanceScales.metersPerUnit[2]*(s[2]-s[0])/o;this.state.colorDomain=t.map((e=>e*i*r))}else this.state.colorDomain=t||ii;const l=this.getAttributeManager().getAttributes(),g=this.getModuleSettings(),u=l.positions.buffer,c={radiusPixels:e,commonBounds:s,textureWidth:o,weightsScale:r},d=l.weights.buffer;a.model.setAttributes({positions:u,weights:d}),a.model.setVertexCount(this.getNumInstances()),a.model.setUniforms(c),a.model.updateModuleSettings(g),a.run({parameters:{viewport:[0,0,o,o]},clearColor:[0,0,0,0]}),this._updateMaxWeightValue()}_debouncedUpdateWeightmap(e=!1){let{updateTimer:t}=this.state;const{debounceTimeout:i}=this.props;e?(t=null,this._updateBounds(!0),this._updateTextureRenderingBounds(),this.setState({isWeightMapDirty:!0})):(this.setState({isWeightMapDirty:!1}),clearTimeout(t),t=setTimeout(this._debouncedUpdateWeightmap.bind(this,!0),i)),this.setState({updateTimer:t})}_worldToCommonBounds(e,t={}){const{useLayerCoordinateSystem:i=!1}=t,[n,o,r,a]=e,{viewport:s}=this.context,{textureSize:l}=this.state,{coordinateSystem:u}=this.props,c=i&&(u===g.LNGLAT_OFFSETS||u===g.METER_OFFSETS),d=c?s.projectPosition(this.props.coordinateOrigin):[0,0],h=2*l/s.scale;let p,m;return i&&!c?(p=this.projectPosition([n,o,0]),m=this.projectPosition([r,a,0])):(p=s.projectPosition([n,o,0]),m=s.projectPosition([r,a,0])),function(e,t,i){const[n,o,r,a]=e,s=r-n,l=a-o;let g=s,u=l;s/l<t/i?g=t/i*l:u=i/t*s,g<t&&(g=t,u=i);const c=(r+n)/2,d=(a+o)/2;return[c-g/2,d-u/2,c+g/2,d+u/2]}([p[0]-d[0],p[1]-d[1],m[0]-d[0],m[1]-d[1]],h,h)}_commonToWorldBounds(e){const[t,i,n,o]=e,{viewport:r}=this.context,a=r.unprojectPosition([t,i]),s=r.unprojectPosition([n,o]);return a.slice(0,2).concat(s.slice(0,2))}}export{M as AGGREGATION_OPERATION,Re as CPUGridLayer,Vt as ContourLayer,Xt as GPUGridLayer,Yt as GridLayer,si as HeatmapLayer,Ve as HexagonLayer,ze as ScreenGridLayer,ie as _AggregationLayer,ve as _BinSorter,Oe as _CPUAggregator,X as _GPUGridAggregator};export default null;
